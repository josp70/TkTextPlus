// Friday, 2012/11/30 12:09:31.00
#Require Rcluster;


// Friday, 2012/11/30 12:09:14.00
Real TolPackage::UpdateAll(?);


// Friday, 2012/11/30 12:05:11.00
#Require Rcluster;


// Thursday, 2012/11/29 19:16:07.00
Code ObjectExist


// Thursday, 2012/11/29 19:16:04.00
Code ObjectExists


// Tuesday, 2012/11/20 11:03:50.00
MMS::Container::GetEstimation(1)::GetModel(?)::GetMVariable(1)::GetBegin(?)

// Tuesday, 2012/11/20 11:03:32.00
MMS::Container::GetEstimation(1)::GetModel(?)::GetMVariable(1)::GetBegin(?)


// Monday, 2012/11/19 23:31:32.00
NameBlock DS.ECI::GetVariable( "Client1" );

// Monday, 2012/11/19 23:31:05.00
Real DS.ECI::FindVariable( "Client1" );

// Monday, 2012/11/19 23:30:40.00
NameBlock kk = DS.ECI::FindVariable( "Client1" );

// Monday, 2012/11/19 23:11:28.00
Set GetArimaFromLabel( "P1DIF0AR1MA0" );


// Monday, 2012/11/19 23:06:38.00
Set GetArimaFromLabel( "P1AR1MA0" );


// Monday, 2012/11/19 23:06:23.00
GetArimaFromLabel( "P1AR1MA0" );


// Monday, 2012/11/19 19:50:53.00
Real Ois.Store( obs, "/tmp/obsECI.oza" );


// Monday, 2012/11/19 19:50:19.00
Ois.Store

// Monday, 2012/11/05 11:36:56.00
Code StdLib::SolvePrecondSym;


// Monday, 2012/11/05 11:36:48.00
Code TolCore::SolvePrecondSym;


// Monday, 2012/11/05 11:35:40.00
NameBlock kk = TolCore::SolvePrecondSym;


// Monday, 2012/11/05 11:34:21.00
NameBlock StdLib::SolvePrecondSym;

// Monday, 2012/11/05 11:32:59.00
NameBlock kk = SolvePrecondSym;


// Monday, 2012/11/05 11:32:42.00
NameBlock kk = StdLib::SolvePrecondSym;


// Monday, 2012/11/05 11:32:32.00
NameBlock StdLib::SolvePrecondSym;


// Monday, 2012/11/05 11:32:28.00
NameBlock StdLib::SolvePrecondSym;


// Monday, 2012/11/05 11:32:20.00
NameBlock StdLib::SolvePrecondSym


// Monday, 2012/11/05 11:32:17.00
NameBlock StdLib::SolvePrecondSym


// Monday, 2012/11/05 11:32:04.00
NameBlock StdLib::PrecondSym


// Monday, 2012/10/22 09:11:08.00
Anything a:= 2;

// Monday, 2012/10/22 09:11:05.00
Real a = 1;
Text k = "eee";

// Monday, 2012/10/22 08:52:49.00
#Require GuiTools;

NameBlock Example =
[[
  Class @TestA {
    Real value = 1.0
  };

  Class @Variable {
    Set _value = Copy( Empty );

    Text getSubType( Real void )
    {
      Grammar( _value[1] )
    };
    
    Static @Variable newSerie( Real void )
      {
        @Variable aux = [[ Set _value = [[ Serie Gaussian( 0, 1 ) ]] ]];
        aux
      };
    
    Static @Variable newMatrix( Real row, Real column )
      {
        @Variable aux = [[Set _value = [[Matrix Gaussian(row, column, 0, 1)]]]];
        aux
      }
  };

  Text getIconForVariable( @Variable instance )
  {
    // retornamos el subtipo de la @Variable que concide con el nombre de una
    // imagen registrada
    Text instance::getSubType(?)
  }
]];

Real GuiTools::ImageManager::defineImageFromData
( "checkedBox",
"R0lGODdhCwALAJEAAH9/f////wAAAP///ywAAAAACwALAAACLISPRvEPAE8oAMUXCYAgJSEiAYRIQkSCAgTJjgiAoEgSEQGEJIRiA9wdwUcrADs=" );

Real GuiTools::ImageManager::defineImageFromFile( "Matrix", "Matrix.gif" );

Real GuiTools::ImageManager::defineImageFromFile( "Serie", "Serie.gif" );

Real GuiTools::ImageManager::setIconForClass( "Example::@TestA", "checkedBox" );
  
Real GuiTools::ImageManager::setIconForClass( "Example::@Variable",
 					       Example::getIconForVariable );

// Creo algunas instancias del ejemplo
Example::@TestA inst1 = [[ Real value = 1.0 ]];

Example::@Variable instSerie = Example::@Variable::newSerie(?);
Example::@Variable instMatrix = Example::@Variable::newMatrix(10,10);



// Monday, 2012/10/22 08:51:08.00
#Require GuiTools;

NameBlock Example =
[[
  Class @TestA {
    Real value = 1.0
  };

  Class @Variable {
    Set _value = Copy( Empty );

    Text getSubType( Real void )
    {
      Grammar( _value[1] )
    };
    
    Static @Variable newSerie( Real void )
      {
        @Variable aux = [[ Set _value = [[ Serie Gaussian( 0, 1 ) ]] ]];
        aux
      };
    
    Static @Variable newMatrix( Real row, Real column )
      {
        @Variable aux = [[Set _value = [[Matrix Gaussian(row, column, 0, 1)]]]];
        aux
      }
  };

  Text getIconForVariable( @Variable instance )
  {
    // retornamos el subtipo de la @Variable que concide con el nombre de una
    // imagen registrada
    Text instance::getSubType(?)
  }
]];

Real GuiTools::ImageManager::defineImageFromData
( "checkedBox",
"R0lGODdhCwALAJEAAH9/f////wAAAP///ywAAAAACwALAAACLISPRvEPAE8oAMUXCYAgJSEiAYRIQkSCAgTJjgiAoEgSEQGEJIRiA9wdwUcrADs=" );

Real GuiTools::ImageManager::defineImageFromFile( "Matrix", "Matrix.gif" );

Real GuiTools::ImageManager::defineImageFromFile( "Serie", "Serie.gif" );

Real GuiTools::ImageManager::setIconForClass( "Example::@TestA", "checkedBox" );
  
Real GuiTools::ImageManager::setIconForClass( "Example::@Variable",
 					              Example::getIconForVariable );

// Creo algunas instancias del ejemplo
Example::@TestA inst1 = [[ Real value = 1.0 ]];

Example::@Variable instSerie = Test0004::@Variable::newSerie(?);
Example::@Variable instMatrix = Test0004::@Variable::newMatrix(10,10);



// Monday, 2012/10/22 08:50:36.00
#Require GuiTools;

NameBlock Example =
[[
  Class @TestA {
    Real value = 1.0
  };

  Class @Variable {
    Set _value = Copy( Empty );

    Text getSubType( Real void )
    {
      Grammar( _value[1] )
    };
    
    Static @Variable newSerie( Real void )
      {
        @Variable aux = [[ Set _value = [[ Serie Gaussian( 0, 1 ) ]] ]];
        aux
      };
    
    Static @Variable newMatrix( Real row, Real column )
      {
        @Variable aux = [[Set _value = [[Matrix Gaussian(row, column, 0, 1)]]]];
        aux
      }
  };

  Text getIconForVariable( @Variable instance )
  {
    // retornamos el subtipo de la @Variable que concide con el nombre de una
    // imagen registrada
    Text instance::getSubType(?)
  }
]];

Real GuiTools::ImageManager::defineImageFromData
( "checkedBox",
"R0lGODdhCwALAJEAAH9/f////wAAAP///ywAAAAACwALAAACLISPRvEPAE8oAMUXCYAgJSEiAYRIQkSCAgTJjgiAoEgSEQGEJIRiA9wdwUcrADs=" );

Real GuiTools::ImageManager::defineImageFromFile( "Matrix", "Matrix.gif" );

Real GuiTools::ImageManager::defineImageFromFile( "Serie", "Serie.gif" );

Real GuiTools::ImageManager::setIconForClass( "Example::@TestA", "checkedBox" );
  
Real GuiTools::ImageManager::setIconForClass( "Example::@Variable",
 					              Example::getIconForVariable );

// Creo algunas instancias del ejemplo
Example::@TestA inst1 = [[ Real value = 1.0 ]];

Example::@Variable instSerie = Test0004::@Variable::newSerie(?);
Example::@Variable instMatrix = Test0004::@Variable::newMatrix(10,10);



// Monday, 2012/10/22 08:49:26.00
NameBlock Example =
[[
  Class @TestA {
    Real value = 1.0
  };

  Class @Variable {
    Set _value = Copy( Empty );

    Text getSubType( Real void )
    {
      Grammar( _value[1] )
    };
    
    Static @Variable newSerie( Real void )
      {
        @Variable aux = [[ Set _value = [[ Serie Gaussian( 0, 1 ) ]] ]];
        aux
      };
    
    Static @Variable newMatrix( Real row, Real column )
      {
        @Variable aux = [[Set _value = [[Matrix Gaussian(row, column, 0, 1)]]]];
        aux
      }
  };

  Text getIconForVariable( @Variable instance )
  {
    // retornamos el subtipo de la @Variable que concide con el nombre de una
    // imagen registrada
    Text instance::getSubType(?)
  }
]];

Real GuiTools::ImageManager::defineImageFromData
( "checkedBox",
"R0lGODdhCwALAJEAAH9/f////wAAAP///ywAAAAACwALAAACLISPRvEPAE8oAMUXCYAgJSEiAYRIQkSCAgTJjgiAoEgSEQGEJIRiA9wdwUcrADs=" );

Real GuiTools::ImageManager::defineImageFromFile( "Matrix", "Matrix.gif" );

Real GuiTools::ImageManager::defineImageFromFile( "Serie", "Serie.gif" );

Real GuiTools::ImageManager::setIconForClass( "Example::@TestA", "checkedBox" );
  
Real GuiTools::ImageManager::setIconForClass( "Example::@Variable",
 					              Example::getIconForVariable );

// Creo algunas instancias del ejemplo
Example::@TestA inst1 = [[ Real value = 1.0 ]];

Example::@Variable instSerie = Test0004::@Variable::newSerie(?);
Example::@Variable instMatrix = Test0004::@Variable::newMatrix(10,10);



// Friday, 2012/10/19 22:30:52.00
#Require GuiTools;

Real GuiTools::ImageManager::defineImageFromData("checkedBox",
"R0lGODdhCwALAJEAAH9/f////wAAAP///ywAAAAACwALAAACLISPRvEPAE8oAMUXCYAgJSEiAYRIQkSCAgTJjgiAoEgSEQGEJIRiA9wdwUcrADs=" );



// Friday, 2012/10/19 22:30:41.00
Real GuiTools::ImageManager::defineImageFromData("checkedBox",
"R0lGODdhCwALAJEAAH9/f////wAAAP///ywAAAAACwALAAACLISPRvEPAE8oAMUXCYAgJSEiAYRIQkSCAgTJjgiAoEgSEQGEJIRiA9wdwUcrADs=" );



// Friday, 2012/10/19 13:49:45.00
Text EncodeBase64FromFile( "/tmp/package.gif" );


// Wednesday, 2012/10/10 10:15:32.00
#Require MMS;


// Monday, 2012/10/08 13:45:45.00

Code FormatInt;

// Monday, 2012/10/08 13:45:36.00
Code IntFormat;

// Monday, 2012/10/08 13:40:42.00
Set TolPackage::Client::GetPackageInfo( "TclCoreLinux32" );

// Monday, 2012/10/08 13:40:11.00
Set TolPackage::Client::GetPackageInfo( pkg );

// Monday, 2012/10/08 13:40:00.00
Set TolPackage::Client::GetCatalog(?)::GetPackageInfo( pkg );

// Monday, 2012/10/08 13:39:21.00


Text pkg = TolPackage::Client::GetCatalog(?)::ObtainLastCompatible("TclCoreLinux32");


// Monday, 2012/10/08 13:33:44.00
      Set minTclCorePlat = {
        [[ Real Linux32 = 401, Real Win32 = 401 ]]
      };



// Friday, 2012/10/05 07:49:53.00
#Require MMS;


// Thursday, 2012/10/04 11:01:10.00
#Require MMS


// Thursday, 2012/10/04 11:00:06.00
Real TolPackage::UpgradeAll(?)


// Thursday, 2012/10/04 10:56:36.00
#Require MMS;


// Thursday, 2012/10/04 10:45:32.00
#Require MMS;


// Thursday, 2012/10/04 10:32:30.00
#Require MMS


// Thursday, 2012/10/04 10:20:33.00
Text Version



// Thursday, 2012/10/04 10:19:25.00
#Require StdLib

// Thursday, 2012/10/04 10:17:53.00
#Require MMS


// Thursday, 2012/09/27 20:26:25.00
Real AvrS(DatCh(ser, D(1)*M(4), FirstS));

// Thursday, 2012/09/27 20:22:33.00

Serie ser1 = DatCh(ser, D(1)*M(4), FirstS);

// Thursday, 2012/09/27 20:22:15.00
Serie ser = SubSer(CalVar(Daily, Monthly), y2000, y2020);



Serie ser1 = DatCh(ser, D(1)*M(4));

// Thursday, 2012/09/27 20:22:08.00
#Require StdLib;

// Thursday, 2012/09/27 20:21:18.00
Serie ser = SubSer(CalVar(Daily, Monthly), y2000, y2020);



Serie ser1 = DatCh(ser, D(1)*M(4));

// Thursday, 2012/09/27 20:21:04.00
Serie ser = SubSer(CalVar(Daily, Monthly), y2000, y2020);



Serie ser1 = DatCh(ser, D(1)*M(4);

// Thursday, 2012/09/27 19:41:29.00


Serie s = SubSer(Gaussian(0, 1, C), y2002, y2003);
Real FirstS(s, y2001, y2002);


// Thursday, 2012/09/27 16:48:00.00
Matrix Group( "|", [[ Constant( 3,1,1),Constant( 3,1,2) ]] );

// Thursday, 2012/09/27 15:56:30.00
Matrix Constant( 2, 2, 1 ) $/ SetMat( tt );

// Thursday, 2012/09/27 15:55:32.00
Matrix 1 $/ SetMat( tt );


// Thursday, 2012/09/27 15:44:26.00
Set tt = [[ [[ 1, 2 ]], [[ 3, 4 ]] ]];
Matrix SetMat( tt );


// Thursday, 2012/09/27 14:06:26.00
Matrix M - (Real 1);

// Thursday, 2012/09/27 14:06:16.00
Matrix 1- M ;

// Thursday, 2012/09/27 14:05:59.00
Matrix M - 1;

// Thursday, 2012/09/27 14:05:16.00
Matrix M $-$ 1;

// Thursday, 2012/09/27 14:05:06.00
Matrix M $-1;

// Thursday, 2012/09/27 14:04:58.00
Matrix M -1;

// Thursday, 2012/09/27 13:03:48.00
   r0 = startRow[ k ];


// Thursday, 2012/09/27 13:03:42.00
Real k = 1;

// Thursday, 2012/09/27 13:03:00.00
  Real n = Columns( X );
  Real m = Rows( Y );
  Real m1 =  Round( m / nBlocks );
  Set startRow = Range( 1, m, m1 );


// Thursday, 2012/09/27 12:50:05.00
Real 100/6;
Real 100/7;

// Thursday, 2012/09/27 12:49:35.00
Set Range( 1, 100, 17 );

// Thursday, 2012/09/27 12:48:47.00
Set Range( 1, 100, 3 );

Matrix M = Rand( 10, 2, 0, 1);
Matrix MtMSqr( M );


// Thursday, 2012/09/27 12:48:21.00
Set Range( 1, 100, 2 );

Matrix M = Rand( 10, 2, 0, 1);
Matrix MtMSqr( M );


// Thursday, 2012/09/27 12:47:59.00
Set Range( 1, 100, 1 );

// Thursday, 2012/09/27 12:44:45.00
Set Range( 1, 1000, 1000 );

// Thursday, 2012/09/27 11:31:36.00
Set Range( 1, 1000, 9 );

// Thursday, 2012/09/27 11:04:36.00
Matrix MtMSqr( M );

// Thursday, 2012/09/27 11:04:28.00
Matrix M = Rand( 10, 2, 0, 1);
Matrix MtSqr( M );


// Thursday, 2012/09/27 10:47:33.00
Set Range( 1, 1000, 10 );


// Thursday, 2012/09/27 10:46:52.00
Set Range( 1, 1000, 1 );


// Thursday, 2012/09/27 10:46:35.00
Set Range( 1, 1000, 2 );


// Thursday, 2012/09/27 10:45:59.00
Set Range( 1, 1000, 100 );


// Tuesday, 2012/09/25 11:47:55.00
Real K = 3;
Real S = 0.5;
Real ig = 1/RandGamma( K, 1/S );

Set For( 1, 1000, Real( Real j ) {
  Real 1/RandGamma( K, 1/S )
} );


// Tuesday, 2012/09/25 11:46:16.00
Set For( 1, 1000, Real( Real j ) {
  Real 1/RandGamma( K, 1/S )
} );

// Tuesday, 2012/09/25 11:46:11.00
Set For( 1, 1000, Real( Real j ) {
  Real 1/RandGamma( K, 1/S );
} );

// Tuesday, 2012/09/25 11:45:28.00
Real K = 6;
Real S = 0.5;
Real ig = 1/RandGamma( K, 1/S );


// Tuesday, 2012/09/25 11:44:58.00
Real ig = 1/RandGamma( K, 1/S );

// Tuesday, 2012/09/25 11:44:54.00
Real K = 10;
Real S = 0.5;

// Tuesday, 2012/09/25 08:31:29.00
Set SpainMaps::GetRegionLevelInfo( "comm" );


// Thursday, 2012/09/20 11:10:58.00
//Cambio de fechado conservando los omitidos
 Serie serie_dc_unk = DatChUnk(serie,D(31),FirstS);

// Thursday, 2012/09/20 11:10:51.00
#Require StdLib

// Thursday, 2012/09/20 11:08:33.00
Serie serie = IfSer(Pulse(y2011m06d15,Daily),?,
   SubSer(Rand(4, 8, Daily), y2011, y2011m12d31));
 //Cambio de fechado obviando los omitidos
 Serie serie_dc = DatCh(serie,D(31),FirstS);
 //Cambio de fechado conservando los omitidos
 Serie serie_dc_unk = DatChUnk(serie,D(31),FirstS);


// Thursday, 2012/09/20 10:09:20.00
FirstS

// Thursday, 2012/09/20 10:08:29.00
Serie sr1_d = DatCh(sr_1, D(31), FirstS);

// Thursday, 2012/09/20 10:05:54.00
 Real BeginS(Serie serie, Date begin, Date end) {
   SerDat(serie, begin)
 };

Serie sr_1 = SubSer(Rand(4, 8, Daily), y2011, y2011m12d31);
 Serie sr_d = DatCh(sr_1, D(31), BeginS);


// Tuesday, 2012/09/18 21:45:18.00
#Require StdLib


// Tuesday, 2012/09/18 20:33:43.00
#Require MMS


// Tuesday, 2012/09/18 20:33:29.00
#Require StdLib


// Tuesday, 2012/09/18 20:31:29.00
#Require MMS



// Tuesday, 2012/09/18 20:31:09.00
#Require StdLib



// Tuesday, 2012/09/18 19:50:03.00
#Require MMS;

Real DoDiagnostics := True;



// Tuesday, 2012/09/18 17:43:31.00
Real DoDiagnostics := False;

// Tuesday, 2012/09/18 17:39:30.00
Real DoDiagnostics := True;

// Tuesday, 2012/09/18 17:36:53.00
#Require MMS;


// Tuesday, 2012/09/18 17:36:22.00
StdLib

// Tuesday, 2012/09/18 17:36:16.00
#Require StdLib


// Friday, 2012/08/31 15:30:35.00
#Require GuiTools;


// Friday, 2012/08/31 15:28:12.00
#Require GuiTools;


// Friday, 2012/08/31 15:00:20.00
#Require MMS;


// Friday, 2012/08/31 14:59:49.00
#Require GuiTools;


// Friday, 2012/08/31 14:47:41.00
#Require MMS


// Friday, 2012/08/31 14:28:51.00
#Require GuiTools


// Friday, 2012/08/31 14:18:05.00
#Require GuiTools


// Friday, 2012/08/31 14:15:16.00
#Require GuiTools


// Monday, 2012/08/27 12:31:26.00
#Require MmsReports;


// Monday, 2012/08/27 12:11:06.00
#Require MMS;


// Friday, 2012/08/24 16:46:08.00
Set kk = { Include( "/tmp/eDarlingSeries.oza" ) }


// Friday, 2012/08/24 16:45:16.00
Set kk = { Include( "/tmp/eDarlingsSeries.oza" ) }


// Friday, 2012/08/24 16:44:52.00
Set kk = { Include( "/tmp/eDarlingSeries.oza" ) }


// Monday, 2012/08/20 19:02:22.00
#Require MMS


// Monday, 2012/08/20 18:58:57.00
#Require MMS;


// Tuesday, 2012/08/14 18:58:04.00
Set init_result= Prepare( args0 );

// Tuesday, 2012/08/14 18:54:36.00
Set resultTOLGridProcess7=Worker(Set Empty);


// Thursday, 2012/08/09 18:12:52.00
Real {
WriteLn("hola");
Real Stop;
WriteLn("mundo");
Real 1
}




// Thursday, 2012/08/09 18:12:39.00

WriteLn("hola");
Real Stop;
WriteLn("mundo");
Real 1




// Thursday, 2012/08/09 18:12:19.00
Real {
WriteLn("hola");
Real Stop;
WriteLn("mundo");
Real 1
}



// Thursday, 2012/08/09 18:11:47.00
WriteLn("hola");
Real Stop;
WriteLn("mundo");



// Thursday, 2012/08/09 17:48:44.00
Set Include( "/tmp/Series.MeMoCC.oza" );


// Monday, 2012/08/06 18:07:58.00
Text Language;
Text TolConfigManager::Config::Various::Language;



// Monday, 2012/08/06 17:44:24.00
#Require MMS


// Monday, 2012/08/06 17:42:55.00
Text Language;
Text TolConfigManager::Config::Various::Language;



// Lunes, 2012/08/06 17:41:44.00
Text TolConfigManager::Config::Various::Language

// Lunes, 2012/08/06 17:41:31.00
Text Language


// Monday, 2012/08/06 13:34:45.00
#Require MMS


// Monday, 2012/08/06 13:34:13.00
#Require MMS


// Monday, 2012/08/06 13:17:01.00
#Require MMS


// Monday, 2012/08/06 13:01:59.00
#Require MMS


// Monday, 2012/08/06 12:32:08.00
#Require MMS


// Monday, 2012/08/06 12:31:17.00
#Require RandVar


// Monday, 2012/08/06 12:30:46.00
GuiTools

// Monday, 2012/08/06 12:30:36.00
#Require GuiTools


// Monday, 2012/08/06 12:22:25.00
#Require MMS


// Monday, 2012/08/06 12:10:14.00
#Require RandVar


// Monday, 2012/08/06 11:47:53.00
Text Language;
Text TolConfigManager::Config::Various::Language;


// Friday, 2012/08/03 08:27:46.00
#Require MMS


// Friday, 2012/08/03 08:21:56.00
#Require MMS


// Friday, 2012/08/03 08:19:28.00
#Require MMS


// Thursday, 2012/08/02 23:58:37.00
#Require MMS


// Thursday, 2012/08/02 23:45:21.00
#Require MMS


// Thursday, 2012/08/02 18:44:32.00
#Require MMS


// Wednesday, 2012/08/01 20:35:39.00
Real 1577 * 1.21


// Wednesday, 2012/08/01 19:34:49.00
TimeSet Easter


// Wednesday, 2012/07/11 20:22:38.00
Set test = [[
  Matrix Rand(11000, 10000, 0, 1)
]];
// El tamaño del conjunto quizá puede depender de la RAM del equipo
Real Ois.Store(test, "/tmp/test.oza");



// Thursday, 2012/06/28 19:40:25.00
Text GetSourcePath( NameBlock TolCore );

// Thursday, 2012/06/28 19:39:24.00
Text GetSourcePath( NameBlock StdLib );

// Thursday, 2012/06/28 19:39:16.00
Text GetTOLPath( NameBlock StdLib );

// Thursday, 2012/06/28 19:39:10.00
Text GetTolPath( NameBlock StdLib );

// Thursday, 2012/06/28 19:38:41.00
Text TOLPath( NameBlock StdLib );

// Thursday, 2012/06/28 19:38:31.00
Text TOLPath( StdLib );

// Thursday, 2012/06/28 19:38:23.00
Text TolPath( StdLib );

// Thursday, 2012/06/28 19:37:46.00
NameBlock StdLib



// Wednesday, 2012/06/13 18:27:31.00
Code SerTms



// Tuesday, 2012/06/12 21:46:39.00
 VMatrix CholeskiFactor(Mat2VMat(Matrix Row(0.01,0)<<Row(0,0.04)), "XtX");
VMatrix CholeskiFactor(Mat2VMat(Matrix Row(0.01,0)<<Row(0,0.04)), "X");


// Monday, 2012/06/11 20:24:18.00
#Require RmtPsClient;



// Monday, 2012/06/11 20:24:09.00
#Require RmtpsClient;



// Monday, 2012/06/11 18:54:13.00
Real Rapi::CleanTemporalFiles:= 0;
Set sol1 = { 
Matrix obj = ((2,4,3)); 
Matrix mat = ((3,4,2), 
(2,1,2), 
(1,3,2)); 
Matrix rhs = ((60,40,80)); 

Set sol=Rglpk::solveLP(obj, mat, rhs, 
{[[Real verbose=TRUE, Real max=TRUE]]}) 
}; 



// Monday, 2012/06/11 18:53:57.00
Rapi

// Monday, 2012/06/11 18:53:36.00
Set sol1 = { 
Matrix obj = ((2,4,3)); 
Matrix mat = ((3,4,2), 
(2,1,2), 
(1,3,2)); 
Matrix rhs = ((60,40,80)); 

Set sol=Rglpk::solveLP(obj, mat, rhs, 
{[[Real verbose=TRUE, Real max=TRUE]]}) 
}; 



// Monday, 2012/06/11 18:49:59.00
#Require StdLib;

Set sol1 = { 
Matrix obj = ((2,4,3)); 
Matrix mat = ((3,4,2), 
(2,1,2), 
(1,3,2)); 
Matrix rhs = ((60,40,80)); 

Set sol=Rglpk::solveLP(obj, mat, rhs, 
{[[Real verbose=TRUE, Real max=TRUE]]}) 
}; 



// Monday, 2012/06/11 18:49:41.00
Set sol1 = { 
Matrix obj = ((2,4,3)); 
Matrix mat = ((3,4,2), 
(2,1,2), 
(1,3,2)); 
Matrix rhs = ((60,40,80)); 

Set sol=Rglpk::solveLP(obj, mat, rhs, 
{[[Real verbose=TRUE, Real max=TRUE]]}) 
}; 



// Monday, 2012/06/11 18:48:37.00
#Require StdLib;


// Monday, 2012/06/11 18:47:07.00
Set sol1 = { 
Matrix obj = ((2,4,3)); 
Matrix mat = ((3,4,2), 
(2,1,2), 
(1,3,2)); 
Matrix rhs = ((60,40,80)); 

Set sol=Rglpk::solveLP(obj, mat, rhs, 
{[[Real verbose=TRUE, Real max=TRUE]]}) 
}; 



// Monday, 2012/06/11 18:44:25.00
Set sol1 = { 
Matrix obj = ((2,4,3)); 
Matrix mat = ((3,4,2), 
(2,1,2), 
(1,3,2)); 
Matrix rhs = ((60,40,80)); 

Set sol=Rglpk::solveLP(obj, mat, rhs, 
{[[Real verbose=TRUE, Real max=TRUE]]}) 
}; 



// Monday, 2012/06/11 18:43:29.00
#Require StdLib;


// Monday, 2012/06/11 11:41:12.00
Matrix a = Rand( 10, 1, 0, 1 );
Matrix b = Rand( 10, 3, 0, 1 );

Text _n = "";
Text n = If( _n == "", "unamed", _n );



// Monday, 2012/06/11 11:24:38.00
Matrix a = Rand( 10, 1, 0, 1 );
Matrix b = Rand( 10, 3, 0, 1 );



// Thursday, 2012/06/07 19:17:39.00
C - unknownTS

// Thursday, 2012/06/07 12:34:45.00
Set b = Include( "test.oza" );

// Wednesday, 2012/06/06 17:18:51.00
MMS

// Wednesday, 2012/06/06 17:18:20.00
#Require MMS;


// Wednesday, 2012/06/06 10:25:51.00
Real Ois.Store( [[ Real aaa = 1 ]], "/tmp/kk.oza" );


// Wednesday, 2012/06/06 10:13:55.00
Real Ois.Store( NCopy( 10, 10 ), "/tmp/kk.oza" );


// Tuesday, 2012/06/05 21:05:44.00
Real ( 4 * ss ) / 1000000

// Tuesday, 2012/06/05 21:05:00.00
Real ss = SetSum( [[  157254, 156967, 157288, 157054, 156980]] );


// Tuesday, 2012/06/05 19:01:12.00
Code NCopy


// Monday, 2012/06/04 11:30:53.00
BStoreArguments::TableParameters

// Sunday, 2012/06/03 21:55:54.00
Serie auxser = SubSer(CalInd(Daily,C),y2012m01d01,y2012m02d01) >> Serie 2*SubSer(CalInd(Daily,C),y2012m03d01,y2012m04d01) ; 



// Sunday, 2012/06/03 21:53:22.00
Serie s1 = SubSer(CalInd(Daily,C),y2012m01d01,y2012m02d01);
Serie s2 = Serie 2*SubSer(CalInd(Daily,C),y2012m03d01,y2012m04d01);
Serie s3 = s1 >> s2;
Serie s4 = SubSer(CalInd(Daily,C),y2012m01d01,y2012m02d01) >> Serie 2*SubSer(CalInd(Daily,C),y2012m03d01,y2012m04d01);
Serie s5 = SubSer(CalInd(Daily,C),y2012m01d01,y2012m02d01) >> (Serie 2*SubSer(CalInd(Daily,C),y2012m03d01,y2012m04d01));




// Sunday, 2012/06/03 21:53:07.00
Serie s1 = SubSer(CalInd(Daily,C),y2012m01d01,y2012m02d01);
Serie s2 = Serie 2*SubSer(CalInd(Daily,C),y2012m03d01,y2012m04d01);
Serie s3 = s1 >> s2;
Serie s4 = SubSer(CalInd(Daily,C),y2012m01d01,y2012m02d01) >> Serie 2*SubSer(CalInd(Daily,C),y2012m03d01,y2012m04d01);
Serie s2 = SubSer(CalInd(Daily,C),y2012m01d01,y2012m02d01) >> (Serie 2*SubSer(CalInd(Daily,C),y2012m03d01,y2012m04d01));




// Sunday, 2012/06/03 21:52:21.00
Serie s1 = SubSer(CalInd(Daily,C),y2012m01d01,y2012m02d01);
Serie s2 = Serie 2*SubSer(CalInd(Daily,C),y2012m03d01,y2012m04d01);
Serie s3 = s1 >>  s2;
Serie s4 = SubSer(CalInd(Daily,C),y2012m01d01,y2012m02d01) >> Serie 2*SubSer(CalInd(Daily,C),y2012m03d01,y2012m04d01);




// Sunday, 2012/06/03 21:51:54.00
Serie s1 = SubSer(CalInd(Daily,C),y2012m01d01,y2012m02d01);
Serie s2 = Serie 2*SubSer(CalInd(Daily,C),y2012m03d01,y2012m04d01);
Serie s3 = s1 >>  s2;
Serie s4 = SubSer(CalInd(Daily,C),y2012m01d01,y2012m02d01) >> (Serie 2*SubSer(CalInd(Daily,C),y2012m03d01,y2012m04d01));




// Sunday, 2012/06/03 21:50:34.00
Serie s1 = SubSer(CalInd(Daily,C),y2012m01d01,y2012m02d01);
Serie s2 = Serie 2*SubSer(CalInd(Daily,C),y2012m03d01,y2012m04d01);
Serie auxser = s1 >>  s2;

// Sunday, 2012/06/03 21:49:15.00
Serie auxser = SubSer(CalInd(Daily,C),y2012m01d01,y2012m02d01) >> Serie 2*SubSer(CalInd(Daily,C),y2012m03d01,y2012m04d01) ;




// Tuesday, 2012/05/29 21:25:07.00
#Require PubDatMeteoSpain


// Tuesday, 2012/05/29 21:24:55.00
#Require PutDatMeteoSpain


// Tuesday, 2012/05/29 09:11:22.00
#Require MMS


// Tuesday, 2012/05/29 08:27:02.00
#Require MMS



// Monday, 2012/05/28 23:56:12.00
Serie UnknownSer = ?*SubSer(CalInd(C,Daily),y2007,y2014);
Serie ser = SubSer(CalInd(C,Daily),y2010,y2011);
Serie truncser = SubSer(ser<<UnknownSer,First(ser),y2012);


// Monday, 2012/05/28 18:14:21.00
/* 
Simple mixed integer linear program. 
maximize:    3 x_1 + 1 x_2 + 3 x_3 
subject to: -1 x_1 + 2 x_2 +   x_3 <= 4 
4 x_2 - 3 x_3 <= 2 
x_1 - 3 x_2 + 2 x_3 <= 3 
x_1, x_3 are non-negative integers 
x_2 is a non-negative real number 
*/ 

Set sol2 = { 
Matrix obj = ((2,1,3)); 
Matrix mat = ((-1,2,1), 
(0,4,-3), 
(1,-3,2)); 
Matrix rhs = ((4,2,3)); 

Set idxInt = [[1,3]]; 

Set sol=Rglpk::solveLP(obj, mat, rhs, 
{[[Set idxInt, Real verbose=TRUE, Real max=TRUE]]}) 
}; 



// Monday, 2012/05/28 17:38:05.00
#Require MMS;


// Monday, 2012/05/28 15:56:11.00
UnknownMatrix


// Monday, 2012/05/28 12:34:49.00
Set sol1 = { 
Matrix obj = ((2,4,3)); 
Matrix mat = ((3,4,2), 
(2,1,2), 
(1,3,2)); 
Matrix rhs = ((60,40,80)); 

Set sol=Rglpk::solveLP(obj, mat, rhs, 
{[[Real verbose=TRUE, Real max=TRUE]]}) 
}; 



// Monday, 2012/05/28 00:26:54.00


Constant( 2, 1, Inf )


// Sunday, 2012/05/27 21:32:13.00
Code TolGlpk::_.CppTools::solveLP


// Sunday, 2012/05/27 21:31:43.00
Code TolGlpk::solveLP


// Sunday, 2012/05/27 21:30:13.00
#Require TolGlpk


// Friday, 2012/05/25 12:03:43.00
Real WeekDay( y2012m1d8 );

// Friday, 2012/05/25 12:03:35.00
Real WeekDay( y2009m7d24 );

// Friday, 2012/05/25 11:45:32.00
Date fEnd0 = y2009m7d24;
Date fEnd1 = Succ( fEnd0, WD(6), 1 );
Real d = DateDif( C, fEnd0, fEnd1 );



// Friday, 2012/05/25 11:44:12.00
Date fEnd0 = y2009m7d25;
Date fEnd1 = Succ( fEnd0, WD(6), 1 );
Real d = DateDif( C, fEnd0, fEnd1 );



// Friday, 2012/05/25 11:43:57.00
Date fEnd0 = y2009m7d24;
Date fEnd1 = Succ( fEnd0, WD(6), 1 );
Real d = DateDif( C, fEnd0, fEnd1 );



// Friday, 2012/05/25 11:43:23.00
Date fEnd0 = y2009m7d18;
Date fEnd1 = Succ( fEnd0, WD(6), 1 );
Real d = DateDif( C, fEnd0, fEnd1 );



// Friday, 2012/05/25 11:43:05.00
Date fEnd0 = y2009m7d19;
Date fEnd1 = Succ( fEnd0, WD(6), 1 );
Real d = DateDif( C, fEnd0, fEnd1 );



// Friday, 2012/05/25 11:37:28.00
Date Succ(y2009m7d19,WD(6),0)

// Friday, 2012/05/25 11:32:30.00
Date fEnd = y2009m7d19;
Real DateDif( WD(6),fEnd, Succ(fEnd,WD(6),1) )


// Friday, 2012/05/25 11:32:12.00
Date fEnd = y2009m7d18;
Real DateDif( WD(6),fEnd, Succ(fEnd,WD(6),1) )


// Friday, 2012/05/25 11:30:59.00
Real DateDif( WD(6),y2009m7d26, Succ(y2009m7d24,WD(6),1) )


// Friday, 2012/05/25 11:30:42.00
Real DateDif( WD(6),y2009m7d23, Succ(y2009m7d24,WD(6),1) )


// Friday, 2012/05/25 11:30:41.00
Real DateDif( WD(6),y2009m7d23, Succ(y2009m7d24,WD(6),1) )


// Friday, 2012/05/25 11:30:40.00
Real DateDif( WD(6),y2009m7d23, Succ(y2009m7d24,WD(6),1) )


// Friday, 2012/05/25 11:30:37.00
Real DateDif( WD(6),y2009m7d23, Succ(y2009m7d24,WD(6),1) )


// Friday, 2012/05/25 11:30:32.00
Real DateDif( WD(6),y2009m7d25, Succ(y2009m7d24,WD(6),1) )


// Friday, 2012/05/25 11:30:31.00
Real DateDif( WD(6),y2009m7d25, Succ(y2009m7d24,WD(6),1) )


// Friday, 2012/05/25 11:30:28.00
Real DateDif( WD(6),y2009m7d25, Succ(y2009m7d24,WD(6),1) )


// Friday, 2012/05/25 11:29:54.00
Real DateDif( WD(6),y2009m7d24, Succ(y2009m7d24,WD(6),1) )


// Friday, 2012/05/25 11:29:35.00
Real DateDif( WD(6),y2009m7d24, Succ(WD(6),y2009m7d24,1) )


// Friday, 2012/05/25 11:29:30.00
Date DateDif( WD(6),y2009m7d24, Succ(WD(6),y2009m7d24,1) )


// Friday, 2012/05/25 11:25:41.00
Date Succ( y2009m7d24, WD(6), 1 )


// Friday, 2012/05/25 10:59:10.00
  Set aux.1 = Classify(registers,Real (Set a, Set b)
  {
    Compare(a::ComAut, b::ComAut)
  });
  
  Set aux.2 = EvalSet(aux.1, Serie(Set cl)
  {
    Set aux = Sort(cl, Real(Set a, Set b)
    { 
      Compare(a::EndDate, b::EndDate)
    });
    Text name = Name(aux[1]);
    Set dates = Traspose(Extract(aux,2))[1];
    Matrix data = SetMat(Extract(aux,10));
    TimeSet tms = DatesOfSet(dates);
    Serie ser.tms = MatSerSet(Tra(data),tms,dates[1])[1];
    Serie ser = DatCh(ser.tms,WD(7),FirstS);
    Eval(name+"=ser")
  });
 

// Monday, 2012/05/21 22:33:14.00
Matrix m = Gaussian( 10, 2, 0, 1 );
Matrix Cor( m );


// Monday, 2012/05/21 22:24:06.00
Code SerCorrelation


// Thursday, 2012/05/17 19:16:09.00
NameBlock kk = DBConnect::Create(
   "bysforofitolkk", "", "",
   "PostgreSQL", "bysforofitol", "p-pgsql01.localbayes.es", 
    "Almacén de repositorios de paquetes TOL de Bayes"
  );

Set NameBlockToSet( kk );


// Thursday, 2012/05/17 19:15:43.00
NameBlock kk = DBConnect::Create(
   "bysforofitol", "", "",
   "PostgreSQL", "bysforofitol", "p-pgsql01.localbayes.es", 
    "Almacén de repositorios de paquetes TOL de Bayes"
  );

Set NameBlockToSet( kk );


// Thursday, 2012/05/17 19:13:55.00
Set NameBlockToSet( kk );

// Thursday, 2012/05/17 19:13:39.00
NameBlock kk = DBConnect::Create(
   "bysforofitol", "toldevel", "",
   "PostgreSQL", "bysforofitol", "p-pgsql01.localbayes.es", 
    "Almacén de repositorios de paquetes TOL de Bayes"
  )


// Thursday, 2012/05/17 19:13:31.00
NameBlock DBConnect::Create(
   "bysforofitol", "toldevel", "",
   "PostgreSQL", "bysforofitol", "p-pgsql01.localbayes.es", 
    "Almacén de repositorios de paquetes TOL de Bayes"
  )


// Thursday, 2012/05/17 18:44:16.00
#Require PtswClient



// Thursday, 2012/05/17 18:36:51.00
#Require PtswClient;


// Thursday, 2012/05/17 18:36:13.00
#Require PtswClient;


// Thursday, 2012/05/17 18:36:12.00
#Require PtswClient;


// Thursday, 2012/05/17 18:34:56.00
#Require PtswClient;


// Thursday, 2012/05/17 18:34:20.00
#Require PtswClient


// Thursday, 2012/05/17 11:25:01.00
Date TextToDate( "2000M01", "%YM%m" );

// Thursday, 2012/05/17 11:24:29.00
Date TextToDate( "2000M01", "%YM%" );

// Thursday, 2012/05/17 11:24:19.00
Date TextToDate( "2000M01", "%YM%" );

// Thursday, 2012/05/17 11:22:56.00
Code TextToDate

// Thursday, 2012/05/17 11:22:46.00
TextToDate

// Thursday, 2012/05/17 11:22:24.00
Date TextToDate( "2000M01", "%yM%m" );


// Thursday, 2012/05/17 11:22:15.00
Date TextToDate( "2000M01", "%y" );


// Thursday, 2012/05/17 11:22:00.00
Date TextToDate( "2000M01" );


// Sunday, 2012/05/13 00:42:33.00
Text Qry =
"
select a, b
from tabla
";

// Sunday, 2012/05/13 00:16:26.00
#Require MMS;

// Sunday, 2012/05/13 00:08:13.00
Text PutDescription( "Esto es una descripción 
    lasdlkaalsd", t );

// Saturday, 2012/05/12 22:19:03.00
Text t =
"  Hola
   Adios";



// Friday, 2012/05/11 22:33:53.00
Set sol1 = {
Matrix obj = ((2,4,3));
Matrix mat = ((3,4,2),
                    (2,1,2),
                    (1,3,2));
Matrix rhs = ((60,40,80));

Set sol=Rglpk::solveLP(obj, mat, rhs,
                                   {[[Real verbose=TRUE, Real max=TRUE]]})
}; 


// Friday, 2012/05/11 22:19:31.00
Set sol2 = { 
Matrix obj = ((2,1,3)); 
Matrix mat = ((-1,2,1), 
(0,4,-3), 
(1,-3,2)); 
Matrix rhs = ((4,2,3)); 

Set idxInt = [[1,3]]; 

Set sol=Rglpk::solveLP(obj, mat, rhs, 
{[[Set idxInt, Real verbose=TRUE, Real max=TRUE]]}) 
}; 


// Friday, 2012/05/11 22:18:14.00
Set sol2 = { 
Matrix obj = ((2,1,3)); 
Matrix mat = ((-1,2,1), 
(0,4,-3), 
(1,-3,2)); 
Matrix rhs = ((4,2,3)); 

Set idxInt = [[1,3]]; 

Set sol=Rglpk::solveLP(obj, mat, rhs, 
{[[Set idxInt, Real verbose=TRUE, Real max=TRUE]]}) 
}; 


// Friday, 2012/05/11 22:16:58.00
Set sol1 = { 
Matrix obj = ((2,4,3)); 
Matrix mat = ((3,4,2), 
(2,1,2), 
(1,3,2)); 
Matrix rhs = ((60,40,80)); 

Set sol=Rglpk::solveLP(obj, mat, rhs, 
{[[Real verbose=TRUE, Real max=TRUE]]}) 
}; 


// Thursday, 2012/05/10 13:09:17.00
#Require MMS;

NameBlock GetProjectRepository( Text projectID, Text pathRepository )
{
  Set MMS::Network::GetConnections(?);
  Text connName = ReplaceTable( projectID,
                                [[ [[ "/", "_._" ]], [[ "\\", "_._" ]] ]] );
  NameBlock repo = If( MMS::Network::FindRepository( connName ),
                       MMS::Network::GetRepository( connName ),
                       If( MMS::Network::FindConnection( connName ),
                           MMS::Network::OpenRepository( connName ), {
                             Real MMS::Network::DefineConnection( connName, "Folder", 
                                                                  pathRepository,
                                                                  "Repositorio de " + projectID );
                             NameBlock MMS::Network::OpenRepository( connName ) } ) )
};

NameBlock repo1 = GetProjectRepository( "PrjBysForTest",
                                       "/media/nas/bmr/NoClient/PrjBysForTest" );


Real RunMmsEstimation_AtRepository( Text projectID,
                                    Text pathRepository,
                                    Text estimationID )
{
  NameBlock repo = GetProjectRepository( projectID, pathRepository );
  Text dirLog  = repo::GetEstimationsPath(?) + "/log/";
  Text dirLock  = repo::GetEstimationsPath(?) + "/lock/";
  // create log folder
  Real OSDirMake( dirLog );
  // create lock folder
  Real OSDirMake( dirLock );
  Text oldDump = GetDumpFile( ? );
  //Text PutDumpFile( PathLog + "/" + name + ".log" );
  Text PutDumpFile( dirLog + estimationID + ".log" );
  WriteLn( "Loading estimation " + estimationID );
  NameBlock est = repo::LoadEstimation( estimationID );

  // TODO: create the lock file or refuse estimation if another lock
  // is set on this estimation

  WriteLn( "Starting estimation " + estimationID );
  Real est::Execute(?);
  WriteLn("Estimation finished " + estimationID );


  Real hasResults = GT(Card(est::GetParameters(?)), 0);
  Real est::SetAttribute("_.hasResults", IntText(hasResults));
  Real est::SetAttribute("_.executed", "1");
  
  Real est::Save( "Heavy" );

  // TODO: release the lock file

  // Restore dump file
  Text PutDumpFile( oldDump, 0 );
  Real 1
};

Real RunMmsEstimation_AtRepository
( "PrjBysForTest",
  "/media/nas/bmr/NoClient/PrjBysForTest",
  "A1_Estimate__1.0" );



// Thursday, 2012/05/10 13:08:16.00
#Require MMS;

NameBlock GetProjectRepository( Text projectID, Text pathRepository )
{
  Set MMS::Network::GetConnections(?);
  Text connName = ReplaceTable( projectID,
                                [[ [[ "/", "_._" ]], [[ "\\", "_._" ]] ]] );
  NameBlock repo = If( MMS::Network::FindRepository( connName ),
                       MMS::Network::GetRepository( connName ),
                       If( MMS::Network::FindConnection( connName ),
                           MMS::Network::OpenRepository( connName ), {
                             Real MMS::Network::DefineConnection( connName, "Folder", 
                                                                  pathRepository,
                                                                  "Repositorio de " + projectID );
                             NameBlock MMS::Network::OpenRepository( connName ) } ) )
};

NameBlock repo1 = GetProjectRepository( "PrjBysForTest",
                                       "/media/nas/bmr/NoClient/PrjBysForTest" );


Real RunMmsEstimation_AtRepository( Text projectID,
                                    Text pathRepository,
                                    Text estimationID )
{
  NameBlock repo = GetProjectRepository( projectID, pathRepository );
  Text dirLog  = repo::GetEstimationsPath(?) + "/log/";
  Text dirLock  = repo::GetEstimationsPath(?) + "/lock/";
  // create log folder
  Real OSDirMake( dirLog );
  // create lock folder
  Real OSDirMake( dirLock );
  Text oldDump = GetDumpFile( ? );
  //Text PutDumpFile( PathLog + "/" + name + ".log" );
  Text PutDumpFile( dirLog + EstimationID + ".log" );
  WriteLn( "Loading estimation " + EstimationID );
  NameBlock est = repo::LoadEstimation( EstimationID );

  // TODO: create the lock file or refuse estimation if another lock
  // is set on this estimation

  WriteLn( "Starting estimation " + EstimationID );
  Real est::Execute(?);
  WriteLn("Estimation finished " + EstimationID );


  Real hasResults = GT(Card(est::GetParameters(?)), 0);
  Real est::SetAttribute("_.hasResults", IntText(hasResults));
  Real est::SetAttribute("_.executed", "1");
  
  Real est::Save( "Heavy" );

  // TODO: release the lock file

  // Restore dump file
  Text PutDumpFile( oldDump, 0 );
  Real 1
};

Real RunMmsEstimation_AtRepository
( "PrjBysForTest",
  "/media/nas/bmr/NoClient/PrjBysForTest",
  "A1_Estimate__1.0" );



// Thursday, 2012/05/10 13:07:06.00
MMS

// Thursday, 2012/05/10 13:05:52.00
Real RunMmsEstimation_AtRepository
( "PrjBysForTest",
  "/media/nas/bmr/NoClient/PrjBysForTest",
  "A1_Estimate__1.0" );


// Thursday, 2012/05/10 13:05:30.00
Real RunMmsEstimation_AtRepository( Text projectID,
                                    Text pathRepository,
                                    Text estimationID )
{
  NameBlock repo = GetProjectRepository( projectID, pathRepository );
  Text dirLog  = repo::GetEstimationsPath(?) + "/log/";
  Text dirLock  = repo::GetEstimationsPath(?) + "/lock/";
  // create log folder
  Real OSDirMake( dirLog );
  // create lock folder
  Real OSDirMake( dirLock );
  Text oldDump = GetDumpFile( ? );
  //Text PutDumpFile( PathLog + "/" + name + ".log" );
  Text PutDumpFile( dirLog + EstimationName + ".log" );
  WriteLn( "Loading estimation " + EstimationName );
  NameBlock est = repo::LoadEstimation( EstimationName );

  // TODO: create the lock file or refuse estimation if another lock
  // is set on this estimation

  WriteLn( "Starting estimation " + EstimationName );
  Real est::Execute(?);
  WriteLn("Estimation finished " + EstimationName );


  Real hasResults = GT(Card(est::GetParameters(?)), 0);
  Real est::SetAttribute("_.hasResults", IntText(hasResults));
  Real est::SetAttribute("_.executed", "1");
  
  Real est::Save( "Heavy" );

  // TODO: release the lock file

  // Restore dump file
  Text PutDumpFile( oldDump, 0 );
  Real 1
};

// Thursday, 2012/05/10 13:04:55.00
Real RunMmsEstimation_AtRepository
( "PrjBysForTest",
  "/media/nas/bmr/NoClient/PrjBysForTest",
  "A1_Estimate__1.0" );

// Thursday, 2012/05/10 13:04:19.00
Text MMS::Container::GetEstimation(1)::GetIdentifier(?);

// Thursday, 2012/05/10 13:02:07.00
#Require MMS;

NameBlock GetProjectRepository( Text projectID, Text pathRepository )
{
  Set MMS::Network::GetConnections(?);
  Text connName = ReplaceTable( projectID,
                                [[ [[ "/", "_._" ]], [[ "\\", "_._" ]] ]] );
  NameBlock repo = If( MMS::Network::FindRepository( connName ),
                       MMS::Network::GetRepository( connName ),
                       If( MMS::Network::FindConnection( connName ),
                           MMS::Network::OpenRepository( connName ), {
                             Real MMS::Network::DefineConnection( connName, "Folder", 
                                                                  pathRepository,
                                                                  "Repositorio de " + projectID );
                             NameBlock MMS::Network::OpenRepository( connName ) } ) )
};

NameBlock repo1 = GetProjectRepository( "PrjBysForTest",
                                       "/media/nas/bmr/NoClient/PrjBysForTest" );


// Thursday, 2012/05/10 13:00:42.00
#Require MMS;

NameBlock GetProjectRepository( Text projectID, Text pathRepository )
{
  Set MMS::Network::GetConnections(?);
  Text connName = ReplaceTable( projectID,
                                [[ [[ "/", "_._" ]], [[ "\\", "_._" ]] ]] );
  NameBlock repo = If( MMS::Network::FindRepository( connName ),
                       MMS::Network::GetRepository( connName ),
                       If( MMS::Network::FindConnection( connName ),
                           MMS::Network::OpenRepository( connName ), {
                             Real MMS::Network::DefineConnection( connName, "Folder", 
                                                                  pathRepository,
                                                                  "Repositorio de " + projectID );
                             NameBlock MMS::Network::OpenRepository( connName ) } ) )
};


NameBlock repo1 = GetProjectRepository( "PrjBysForTest",
                                       "/media/nas/bmr/NoClient/PrjBysForTest" );


// Thursday, 2012/05/10 12:59:07.00
MMS

// Thursday, 2012/05/10 12:59:05.00
#Require MMS;


// Thursday, 2012/05/10 12:56:55.00
MMS

// Thursday, 2012/05/10 12:56:28.00
#Require MMS;
NameBlock GetProjectRepository( Text projectID, Text pathRepository )
{
  Set MMS::Network::GetConnections(?);
  Text connName = ReplaceTable( projectID,
                                [[ [[ "/", "_._" ]], [[ "\\", "_._" ]] ]] );
  NameBlock repo = If( MMS::Network::FindRepository( connName ),
                       MMS::Network::GetRepository( connName ),
                       If( MMS::Network::FindConnection( connName ),
                           MMS::Network::OpenRepository( connName ), {
                             MMS::Network::DefineConnection( connName, "Folder", 
                                                             pathRepository,
                                                             "Repositorio de " + projectID );
                             MMS::Network::OpenRepository( connName ) } ) )
};


NameBlock repo1 = GetProjectRepository( "PrjBysForTest",
                                       "/media/nas/bmr/NoClient/PrjBysForTest" );


// Thursday, 2012/05/10 12:55:36.00
#Require MMS;
NameBlock GetProjectRepository( Text projectID, Text pathRepository )
{
  Set MMS::Network::GetConnections(?);
  Text connName = ReplaceTable( projectID,
                                [[ [[ "/", "_._" ]], [[ "\\", "_._" ]] ]] );
  NameBlock repo = If( MMS::Network::FindRepository( connName ),
                       MMS::Network::GetRepository( connName ),
                       If( MMS::Network::FindConnection( connName ),
                           MMS::Network::OpenRepository( connName ), {
                             MMS::Network::DefineConnection( connName, "Folder", 
                                                             pathRepository,
                                                             "Repositorio de " + projectID );
                             MMS::Network::OpenRepository( connName ) } ) )
};


NameBlock repo1 = GetProjectRepository( "PrjBysForTest",
                                       "/media/nas/bmr/NoClient/PrjBysForTest" );


// Thursday, 2012/05/10 12:54:06.00

NameBlock repo1 = GetProjectRepository( "PrjBysForTest",
                                       "/media/nas/bmr/NoClient/PrjBysForTest" );

// Thursday, 2012/05/10 12:50:43.00
NameBlock repo = GetProjectRepository( "PrjBysForTest",
                                       "/media/nas/bmr/NoClient/PrjBysForTest" );

// Thursday, 2012/05/10 12:50:35.00
#Require MMS;
NameBlock GetProjectRepository( Text projectID, Text pathRepository )
{
  Set MMS::Network::GetConnections(?);
  Text connName = ReplaceTable( projectID,
                                [[ [[ "/", "_._" ]], [[ "\\", "_._" ]] ]] );
  NameBlock repo = If( MMS::Network::FindRepository( connName ),
                       MMS::Network::GetRepository( connName ),
                       If( MMS::Network::FindConnection( connName ),
                           MMS::Network::OpenRepository( connName ), {
                             MMS::Network::DefineConnection( connName, "Folder", 
                                                             pathRepository,
                                                             "Repositorio de " + projectID );
                             MMS::Network::OpenRepository( connName ) } ) )
};


// Thursday, 2012/05/10 12:50:20.00
#Require MMS;

NameBlock repo = GetProjectRepository( "PrjBysForTest",
                                       "/media/nas/bmr/NoClient/PrjBysForTest" );


// Thursday, 2012/05/10 12:48:40.00
#Require MMS;


// Thursday, 2012/05/10 12:45:16.00
Real MMS::@RepositoryFolder::Create([[ Text _.path = "/media/nas/bmr/NoClient/PrjBysForTest" ]]);

// Thursday, 2012/05/10 12:44:20.00
Real MMS::@RepositoryFolder::Create([[ Text _.path = "/media/nas/bmr/NoClient/PrjBysForTest" ]]);

// Thursday, 2012/05/10 12:44:05.00

Real MMS::@RepositoryFolder::Create([[ _.path = "/media/nas/bmr/NoClient/PrjBysForTest" ]]);

// Thursday, 2012/05/10 12:43:42.00
Real MMS::@RepositoryFolder::Create([[ "/media/nas/bmr/NoClient/PrjBysForTest" ]]);

// Thursday, 2012/05/10 12:42:09.00
#Require MMS;


// Wednesday, 2012/05/09 19:08:14.00
NameBlock kk =
[[
#Require NonLinGloOpt;
#Require BysSampler;
Real k=0
]]


// Wednesday, 2012/05/09 17:58:50.00
#Require TolExcel;


// Tuesday, 2012/05/08 18:41:26.00
Set PExec( [[ "ooo" ]] );

// Tuesday, 2012/05/08 18:41:17.00
Set PExec( "ooo" );

// Tuesday, 2012/05/08 18:38:50.00
Set PExec( [[ "svn", "ls", "https://www.tol-project.org/svn/tolp/OfficialTolArchiveNetwork/" ]] );


// Tuesday, 2012/05/08 18:38:24.00
Set PExec( [[ "svn ls https://www.tol-project.org/svn/tolp/OfficialTolArchiveNetwork/" ]] );


// Monday, 2012/05/07 18:29:46.00
Real xTarget = SerDat( s2, _.dateReference );

// Monday, 2012/05/07 18:29:42.00
Serie s2 = DatCh( s1, TimeSet Eval( _.datingAggr ), Code FindCode( "Real", _.driverAggr ) );

// Monday, 2012/05/07 18:29:27.00
Serie s2 = DatCh( s1, TimeSet Eval( _.datingAggr ), Code FindCode( "Real", _.driverAggr );

// Monday, 2012/05/07 18:29:06.00
Serie s1 = SubSer( Gaussian( 0, 1, Monthly ), y2000, y2010m12 );

// Monday, 2012/05/07 18:29:02.00
Text _.datingAggr = "Yearly";
Date _.dateReference = y2010;
Text _.driverAggr = "SumS";

// Monday, 2012/05/07 14:46:12.00
#Require MMS;

Real MMS::Container::GetEstimation(1)::GetStrategy(?)::SetSetting( "_.showTraces", 0 );


// Monday, 2012/05/07 12:52:26.00
#Require MMS;


// Friday, 2012/05/04 19:56:05.00
TextLength( "Rec_MetSer.Val.Uni_TPlPre_DDDXX_GeoUFe.XX_TReT.XX_VReXX_FreDia_Cal_FerNacBasReg.WD1_Linear.0_Prior" );

// Friday, 2012/05/04 19:54:59.00
TextLength( TolAppDataPath<<"MMS/" );

// Friday, 2012/05/04 19:53:48.00
NameBlock MMS::Settings

// Friday, 2012/05/04 18:23:35.00
Set PExec( [[ "svn0", "ls" ]] );

// Friday, 2012/05/04 18:21:37.00
#Require MMS;

Code PExec;
Set PExec( [[ "svn", "ls" ]] );



// Friday, 2012/05/04 18:20:10.00
#Require MMS;

Code PExec;


// Wednesday, 2012/05/02 21:55:30.00
Set Include( "/tmp/listA.oza" );


// Wednesday, 2012/05/02 21:55:22.00
Set Include( "/tmp/listA.tol" );


// Wednesday, 2012/05/02 21:50:32.00
Real cat::Update(?);

// Wednesday, 2012/05/02 17:51:39.00
Set Include( "/tmp/listA.oza" );

// Wednesday, 2012/05/02 17:40:41.00
#Require MatAlg;

// Wednesday, 2012/05/02 17:39:16.00
#Require MMS;

// Wednesday, 2012/05/02 17:38:18.00
NameBlock cat = TolPackage::Client::GetCatalog(?);


// Wednesday, 2012/05/02 11:34:51.00
Set TolPackage::Client::GetPackageInfo("MatAlg.2.1");


// Wednesday, 2012/05/02 11:34:24.00
Set TolPackage::Client::GetPackageInfo("MatAlg.2.1");


// Wednesday, 2012/05/02 11:25:23.00
Set TolPackage::Client::GetPackageInfo("MatAlg.2.1");

// Wednesday, 2012/05/02 11:25:05.00
Set TolPackage::Client::GetPackageInfo("MatAlg.2.1");

// Saturday, 2012/04/28 11:01:42.00
Code FileExist

// Saturday, 2012/04/28 11:01:37.00
Code FileExists

// Saturday, 2012/04/28 10:42:32.00
NameBlock cata = TolPackage::Server::GetCatalog(?);


Set cata::GetRecord( cata::ObtainIdentifier( "StdLib", Version, UnknownDate ) );



// Saturday, 2012/04/28 10:39:33.00
Set cata::GetRecord( cata::ObtainIdentifier( "StdLib", Version, UnknownDate ) );

// Saturday, 2012/04/28 10:39:16.00
#Require GuiTools;

NameBlock cata = TolPackage::Server::GetCatalog(?);


Set record := cata::GetRecord( cata::ObtainIdentifier( "StdLib", Version, UnknownDate ) );


// Saturday, 2012/04/28 10:38:00.00

Set record := cata::GetRecord( "StdLib.0.0");

// Saturday, 2012/04/28 10:37:51.00
Set record = cata::GetRecord( "StdLib.0.0");

// Saturday, 2012/04/28 10:37:40.00
Set record = cata::GetRecord( "StdLib");

// Saturday, 2012/04/28 10:37:23.00
Set record = catalog::GetRecord( "StdLib");

// Saturday, 2012/04/28 10:36:50.00

NameBlock cata = TolPackage::Server::GetCatalog(?);

// Saturday, 2012/04/28 10:36:41.00
NameBlock cata = TolPackage::GetCatalog(?);

// Saturday, 2012/04/28 00:14:55.00
Real OSFilRemove( "/tmp/DefaultRequire.tol" );

// Saturday, 2012/04/28 00:14:25.00
Real OSFilRemove( "/tmp/*.tol" );

// Saturday, 2012/04/28 00:13:43.00
#Require GuiTools;

Code OSFilRemove


// Saturday, 2012/04/28 00:13:07.00
Code OSDirExist

// Friday, 2012/04/27 23:41:02.00
Code TolPackage::Packager::TestAutodoc

// Friday, 2012/04/27 22:55:22.00
#Require GuiTools;


// Friday, 2012/04/27 22:53:26.00
  ////////////////////////////////////////////////////////////////////////////
  Real _IsIntegerText(Text integer)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real length = TextLength(integer);
    If(length==0, 0, {
      Real isInteger = True;
      Real position = 1;
      While(isInteger & position<=length, {
        Real ascii = ASCII(Sub(integer, position, position));
        If(ascii>=48 & ascii<=57, {
          Real position := position + 1
        }, {
          Real isInteger := False
        })
      });
      isInteger
    })
  }



// Thursday, 2012/04/26 14:24:29.00
TimeSet Monthly


// Wednesday, 2012/04/25 19:13:58.00
Real row_ini = xls::minRow;
Real col_ini = xls::minCol;
Real row_num = xls::_.maxRow;
Real col_num = xls::_.maxCol;

Real numDat = row_num-row_ini;
Real numSer = col_num-col_ini;


Set serNames = xls::ReadRange(row_ini,col_ini+1,1,numSer,NCopy(numSer,""))[1];


// Wednesday, 2012/04/25 17:56:54.00
Set kk = xls::ReadSeriesByCol(Real row_ini, Real col_ini, Real row_num, Real col_num,
                         TimeSet W, Text "%Y-%m-%d" );

// Wednesday, 2012/04/25 17:48:04.00
Set kk = xls::ReadSeriesByCol( Real row_ini, Real col_ini, Real row_num, Real col_num,
                              Mensual, Text "");

// Wednesday, 2012/04/25 17:31:12.00
Real row_ini = xls::minRow;
Real col_ini = xls::minCol;
Real row_num = xls::_.maxRow;
Real col_num = xls::_.maxCol;

Real numDat = row_num-row_ini;
Real numSer = col_num-col_ini;


// Wednesday, 2012/04/25 17:30:42.00
#Require TolExcel


// Wednesday, 2012/04/25 16:41:29.00
TolExcel

// Wednesday, 2012/04/25 16:41:08.00
#Require TolExcel;



// Tuesday, 2012/04/24 13:14:16.00
Text TclDialogEntry(Copy(Empty));



// Tuesday, 2012/04/24 13:14:10.00
Text TclDialogEntry(Copy(Empty));



// Monday, 2012/04/23 10:01:15.00
#Require MMS


// Thursday, 2012/04/12 09:29:11.00
Real TolCore::CheckTOLRelease(0);

// Thursday, 2012/04/12 09:26:47.00
Real CheckTOLReleaseIsUpdated := If(
TolConfigManager::Config::Upgrading::TolVersion::CheckAllowed,
{
  TolCore::CheckTOLRelease(
    ?
  )
},
{
  ?
});



// Thursday, 2012/04/12 09:26:41.00
Real CheckTOLReleaseIsUpdated := If(
TolConfigManager::Config::Upgrading::TolVersion::CheckAllowed,
{
  TolCore::CheckTOLRelease(
    1
  )
},
{
  ?
});



// Thursday, 2012/04/12 09:26:37.00
Real CheckTOLReleaseIsUpdated := If(
TolConfigManager::Config::Upgrading::TolVersion::CheckAllowed,
{
  TolCore::CheckTOLRelease(
    0
  )
},
{
  ?
});



// Thursday, 2012/04/12 09:26:15.00
Real CheckTOLReleaseIsUpdated := If(
TolConfigManager::Config::Upgrading::TolVersion::CheckAllowed,
{
  TolCore::CheckTOLRelease(
    TolConfigManager::Config::Upgrading::TolVersion::MaxDaysOfDelay
  )
},
{
  ?
});



// Thursday, 2012/04/12 09:26:02.00
Real CheckTOLReleaseIsUpdated = If(
TolConfigManager::Config::Upgrading::TolVersion::CheckAllowed,
{
  TolCore::CheckTOLRelease(
    TolConfigManager::Config::Upgrading::TolVersion::MaxDaysOfDelay
  )
},
{
  ?
});



// Monday, 2012/04/09 19:44:09.00
#Require PtswClient


// Monday, 2012/04/09 19:24:14.00
Code FunEmpty


// Monday, 2012/04/09 19:23:32.00
Code FunEmpty


// Monday, 2012/04/09 19:05:35.00
Code AlgDefGetNode


// Monday, 2012/04/09 19:02:30.00
Code StdLib::FunTrue


// Monday, 2012/04/09 19:02:21.00
Code FunTrue


// Monday, 2012/04/09 19:02:12.00
Code FunEmpty


// Monday, 2012/04/09 18:57:27.00
#Require PtswClient


// Monday, 2012/04/09 18:41:31.00
Code @AlgListValueSt;

// Monday, 2012/04/09 18:41:21.00
Code @AlgListValueSt



// Monday, 2012/04/09 18:41:09.00
Anything @AlgListValueSt

// Monday, 2012/04/09 18:40:57.00
@AlgListValueSt



// Monday, 2012/04/09 18:00:21.00
Text Version


// Monday, 2012/04/09 17:38:22.00
#Require MMS


// Tuesday, 2012/04/03 13:47:27.00
aa << [[ 4, 5, 6 ]];

// Tuesday, 2012/04/03 13:15:29.00
Append( aa, [[ 1, 2, 3 ]] );

// Tuesday, 2012/04/03 13:10:17.00
If( 1!=0, 1, 9)

// Tuesday, 2012/04/03 13:07:58.00
EvalSet( aa, Text( Anything ii ) { Name(ii) } )

// Tuesday, 2012/04/03 13:07:57.00
EvalSet( aa, Text( Anything ii ) { Name(ii) } )

// Tuesday, 2012/04/03 13:07:57.00
EvalSet( aa, Text( Anything ii ) { Name(ii) } )

// Tuesday, 2012/04/03 13:07:55.00
EvalSet( aa, Text( Anything ii ) { Name(ii) } )

// Tuesday, 2012/04/03 13:07:46.00
EvalSet( aa, Text( Anything ii ) { Name(ii) } )

// Tuesday, 2012/04/03 13:07:17.00
EvalSet( aa, Text( ii ) { Name(ii) } )

// Tuesday, 2012/04/03 13:06:41.00
Set aa = [[ Text { expr = "23" }, Text { expr = "24" } ]]


// Tuesday, 2012/04/03 13:06:29.00
Set aa = [[ Text { expr = "23" }, Text { expr = 24 } ]]


// Tuesday, 2012/04/03 13:06:15.00
Set aa = [[ Text { expr = "23" } ]]


// Tuesday, 2012/04/03 13:06:08.00
Set aa = [[ Text { expr = 23 } ]]


// Saturday, 2012/03/31 17:12:58.00
MmsReports


// Thursday, 2012/03/29 14:55:20.00
NameBlock GuiTools::TkNameBlockEditor( [[ Real a = 1 ]], [["-title", "Título" ]] );

// Thursday, 2012/03/29 14:55:07.00
NameBlock GuiTools::TkNameBlockEditor( [[ Real a = 1 ]], [["-title", "Título" ]] );

// Thursday, 2012/03/29 14:54:59.00
#Require GuiTools;

// Thursday, 2012/03/29 14:54:48.00
NameBlock GuiTools::TkNameBlockEditor( [[ Real a = 1 ]], [["-title", "Título" ]] );


// Wednesday, 2012/03/28 11:42:03.00
Set SetTranspose( SerSetTable( [[ Serie SubSer( Gaussian(0,1), y2000, y2001),SubSer( Serie Gaussian(0,1), y2000, y2001 ) ]] ) );


// Wednesday, 2012/03/28 11:41:58.00
Set Transpose( SerSetTable( [[ Serie SubSer( Gaussian(0,1), y2000, y2001),SubSer( Serie Gaussian(0,1), y2000, y2001 ) ]] ) );


// Wednesday, 2012/03/28 11:41:49.00
Transpose( SerSetTable( [[ Serie SubSer( Gaussian(0,1), y2000, y2001),SubSer( Serie Gaussian(0,1), y2000, y2001 ) ]] ) );


// Wednesday, 2012/03/28 11:41:23.00
SerSetTable( [[ Serie SubSer( Gaussian(0,1), y2000, y2001),SubSer( Serie Gaussian(0,1), y2000, y2001 ) ]] );


// Wednesday, 2012/03/28 11:40:48.00
SerSetTable( [[ Serie Gaussian(0,1), Serie Gaussian(0,1) ]] );


// Tuesday, 2012/03/27 20:48:21.00
Code ObjectExist



// Tuesday, 2012/03/27 18:23:47.00
#Require StdLib


// Tuesday, 2012/03/27 18:21:25.00
#Require StdLib;



// Tuesday, 2012/03/27 18:07:40.00
Set Tcl_EvalEx( [[ "tol::info", "struct", "@NonLinearInputDef" ]] );

// Tuesday, 2012/03/27 18:07:33.00
Set Tcl_lEvalEx( [[ "tol::info", "struct", "@NonLinearInputDef" ]] );

// Tuesday, 2012/03/27 18:07:23.00
Set Tol_TclEvalEx( [[ "tol::info", "struct", "@NonLinearInputDef" ]] );

// Thursday, 2012/03/22 21:24:50.00
Code ObjectExist


// Thursday, 2012/03/22 21:23:48.00
Code NameBlockToSet


// Monday, 2012/03/19 13:20:08.00
UsingNameBlock( MatQuery );

// Monday, 2012/03/19 13:19:53.00
#Require MatQuery;

// Monday, 2012/03/19 13:18:56.00
Code StartActions

// Monday, 2012/03/19 13:18:46.00
#Require GuiTools;

UsingNameBlock( GuiTools );


// Monday, 2012/03/19 13:18:32.00
#Require GuiTools;


// Sunday, 2012/03/18 22:06:33.00
#Require MMS;


// Sunday, 2012/03/18 22:00:36.00
#Require MMS;



// Saturday, 2012/03/17 02:52:40.00
Set pkg = Include( "/tmp/info.oza" );

// Saturday, 2012/03/17 02:50:32.00
Set Include( "/tmp/info.oza" );

// Saturday, 2012/03/17 01:02:50.00
#Require MMS;


// Saturday, 2012/03/17 01:02:11.00
NameBlock StdLib


// Friday, 2012/03/16 22:40:02.00
#Require StdLibWrapper


// Friday, 2012/03/16 22:39:25.00
StdLibWrapper::_.PublishAPI(?);


// Friday, 2012/03/16 22:38:39.00
#Require StdLibWrapper


// Friday, 2012/03/16 22:35:56.00
NameBlock StdLib


// Friday, 2012/03/16 20:21:02.00
Text msg = "Hola";

          Set Tcl_EvalEx( [[ "tk_messageBox",
                             "-title", "Check TOL Release",
                             "-message", msg,
                             "-icon", "warning" ]] );



// Thursday, 2012/03/15 16:25:14.00
 EvalSet( TolPackage::Client::_.defaultList, Real( Set pkg ) {
   WriteLn( Name( pkg ) );
   Real 1
 } )


// Thursday, 2012/03/15 16:25:07.00
 EvalSet( TolPackage::Client::_.defaultList, Real( Set pkg ) {
   WriteLn( Name( pkg ) );
   Real 1
 } )


// Thursday, 2012/03/15 14:20:39.00
TextFind( pkg.version, "x" );

// Thursday, 2012/03/15 14:20:21.00
Text pkg.name = Sub( pkg.version, 1, idx - 1 );

// Thursday, 2012/03/15 14:20:00.00
Real idx = TextFind( pkg.version, "." );

// Thursday, 2012/03/15 14:18:19.00
Code TextFind

// Thursday, 2012/03/15 12:57:38.00
Text path + pkg;
      If( 1,
          WriteLn( "Checking default package '" << pkg << "'" ) );



// Thursday, 2012/03/15 12:45:42.00
Text path + pkg;

// Thursday, 2012/03/15 12:45:17.00
Real  FileExist( pkg.local );

// Thursday, 2012/03/15 12:44:50.00
Text pkg.local = TolPackage::Client::LocalOza( pkg.version );

// Thursday, 2012/03/15 12:44:39.00
Text path = TolPackage::Client::_.defaultPackagePath;
Set pkgLst = GetDir(path)[1];

Text pkg = pkgLst[1];

Real TextEndAt( pkg, ".zip" );

Text pkg.version = Sub( pkg, 1, TextLength( pkg ) - 4 );

Text pkg.local = LocalOza( pkg.version );


// Thursday, 2012/03/15 12:44:28.00
Text pkg.version = Sub( pkg, 1, TextLength( pkg ) - 4 );

// Thursday, 2012/03/15 12:44:17.00
Real TextEndAt( pkg, ".zip" );

// Thursday, 2012/03/15 12:44:02.00
Text pkg = pkgLst[1];

// Thursday, 2012/03/15 12:43:55.00
Set pkg = pkgLst[1];

// Thursday, 2012/03/15 12:43:19.00
Text path = TolPackage::Client::_.defaultPackagePath;
Set pkgLst = GetDir(path)[1];


// Thursday, 2012/03/15 12:43:03.00
GetDir(path)

// Thursday, 2012/03/15 12:42:48.00
Text path = TolPackage::Client::_.defaultPackagePath;
Set pkgLst = GetDir(path)[2];

// Monday, 2012/03/12 20:22:42.00
Real x = 1;


// Monday, 2012/03/12 20:21:21.00
Real x = 1


// Monday, 2012/03/12 15:36:45.00
Real 1 & 0



// Monday, 2012/03/12 15:16:11.00
Real x = 1;

// Monday, 2012/03/12 15:15:48.00
#Require GuiTools;

Real RealSquare( Real x, Set args )
{
  Real sqX = x*x;
  WriteLn( "El cuadrado de " << x << " es " << sqX );
  sqX
};

Real GuiTools::MenuManager::defineMenuCommand
( "Real",
  [[ Text name = "Real_SQ",
     Text label = "Cuadrado del Real",
     Real flagGroup = 0,
     Code CmdInvoke = RealSquare ]]
);



// Monday, 2012/03/12 15:08:38.00
#Require GuiTools;

Real RealSquare( Real x, Set args )
{
  Real sqX = x*x;
  WriteLn( "El cuadrado de " << x << " es " << sqX );
  sqX
};

Real GuiTools::MenuManager::defineMenuCommand
( "Real",
  [[ Text name = "Real_SQ",
     Text label = "Cuadrado del Real",
     Real flagGroup = 0,
     Code CmdInvoke = RealSquare ]]
);



// Sunday, 2012/03/11 22:42:22.00
GuiTools::TkSetEditor( s1, Empty );

// Friday, 2012/03/09 18:49:32.00
#Require MMS;


// Wednesday, 2012/03/07 11:46:47.00
Set s2 = GuiTools::TkSetEditor( s1, Empty );

// Wednesday, 2012/03/07 11:46:26.00
Set s1 = { [[ Real a = 1; Real b = 2  ]] };

// Wednesday, 2012/03/07 11:46:16.00
Set s = { [[ Real a = 1; Real b = 2  ]] };

// Wednesday, 2012/03/07 11:45:51.00
Set s = [[ Real a = 1; Real b = 2  ]];

// Wednesday, 2012/03/07 10:46:38.00
Matrix MatEx = Log(Round(Rand(100, 1, 0, 1)|Rand(100, 1, 0, 1)));

Set cjto = For(1, 28, Set(Real n) { [[n, If(EQ(n, 2), ?, n) ]] });
Matrix mat = SetMat(cjto);


// Wednesday, 2012/03/07 10:45:25.00
Matrix MatEx = Log(Round(Rand(100, 1, 0, 1)|Rand(100, 1, 0, 1)));


// Wednesday, 2012/03/07 10:36:48.00
Set s1 = BinGroup("|", For(1, 4, Set (Real i) {
  Set For(1, 10, Set (Real j) {
    [[j, i + j]]
  })
}));
Text TclChartSet(s1, SetOfSet(@TclArgSt("-type", "3")));

Set s2 = BinGroup("|", For(1, 4, Set (Real i) {
  Set For(1, 10, Set (Real j) {
    [[j, If(i==j, ?, i+j)]]
  })
}));
Text TclChartSet(s2, SetOfSet(@TclArgSt("-type", "3")));



// Wednesday, 2012/03/07 10:18:31.00
Set s1 = BinGroup("|", For(1, 4, Set (Real i) {
  Set For(1, 10, Set (Real j) {
    [[j, i + j]]
  })
}));
Text TclChartSet(s1, SetOfSet(@TclArgSt("-type", "3")));

Set s2 = BinGroup("|", For(1, 4, Set (Real i) {
  Set For(1, 10, Set (Real j) {
    [[j, If(i==j, ?, i+j)]]
  })
}));
Text TclChartSet(s2, SetOfSet(@TclArgSt("-type", "3")));



// Wednesday, 2012/03/07 10:15:42.00
TclChartSet(mySetGraText2, SetOfSet (
  @TclArgSt("-title"   , "Mi gráfico 3"),
  @TclArgSt("-type"    , "2"           )
));

// Wednesday, 2012/03/07 09:58:56.00
Text TclChartSerieAutocor(mySer1, SetOfSet(
  @TclArgSt("-title",    ""),
  @TclArgSt("-geometry", "814x692+1+1")));

// Wednesday, 2012/03/07 09:58:33.00
Text TclChartSerieAutocor(mySer1, SetOfSet(
  @TclArgSt("-title",    "Gráfico de Autocorrelaciones"),
  @TclArgSt("-geometry", "814x692+1+1")));

// Wednesday, 2012/03/07 09:58:23.00
ext TclChartSerieAutocor(mySer1, SetOfSet(
  @TclArgSt("-title",    "Gráfico de Autocorrelaciones"),
  @TclArgSt("-geometry", "814x692+1+1")));

// Wednesday, 2012/03/07 09:58:05.00
Serie mySer1 = Rand(-10, 10, Diario);
Serie mySer2 = Rand(-15, 15, Diario);


// Tuesday, 2012/03/06 20:30:47.00
Text myChart1 = TclChartSet(mySetGra, SetOfSet (
  @TclArgSt("-title"   , "Mi gráfico 1"),
  @TclArgSt("-geometry", "400x400+1+1" ),
  @TclArgSt("-gcfFile" , ""            ),
  @TclArgSt("-type"    , "0"           ),
  @TclArgSt("-names"   , TxtListTcl(namess) ),
  @TclArgSt("-pairs"   , TxtListTcl(pairss) )
));


// Tuesday, 2012/03/06 20:30:42.00
Set namess = SetOfText("uno","dos","tres","cuatro");
Set pairss = SetOfSet(SetOfReal(1,2), SetOfReal(3,4));

// Tuesday, 2012/03/06 20:30:18.00
Set mySetGra      = Traspose(mySet);

// Tuesday, 2012/03/06 20:29:45.00
Set mySet = 
  SetOfSet(
    SetOfReal(  1,  2,  3,  4,  5,  6),
    SetOfReal( 12, 34, 35, 65, 76, 43),
    SetOfReal(  3,  7,  4,  2,  9,  6),
    SetOfReal(  2,  4,  5,  5,  6,  3)
  );


// Tuesday, 2012/03/06 15:00:42.00
Real TclActionBox( options, "DoSomething", [[ "-selectmode", "multiple" ]] );

// Tuesday, 2012/03/06 15:00:26.00
  Real TclActionBox( options, DoSomething, [[ "-selectmode", "multiple" ]] );

// Tuesday, 2012/03/06 15:00:10.00
  Set options = [[ "one", "two", "three" ]];
  Real DoSomething( Set selection )
  {
    WriteLn( "Excuting action over :" );
    Set View( selection, "" );
    Real 1
  };
  Real TclActioBox( options, DoSomething, [[ "-selectmode", "multiple" ]] );


// Tuesday, 2012/03/06 14:52:42.00
Real TclActionBox( options, DoSomething, Empty );

// Tuesday, 2012/03/06 14:52:30.00
  Set options = [[ "one", "two", "three" ]];
  Real DoSomething( Set selection )
  {
    WriteLn( "Excuting action over :" );
    Set View( selection, "" );
    Real 1
  };
  Real TclActioBox( options, DoSomething, Empty );


// Tuesday, 2012/03/06 10:26:34.00
  Set s1 = For( 1, 1000, Text( Real k ) { Text "item"<<k } );
  Set s2 = For( 1, 1000, Set( Real k ) { Set [[ k ]] } );
  Set s3 = For( 1, 1000, NameBlock( Real k ) { NameBlock [[ Real id = k ]] } );
  Class @Ej { Text _.name };
  Set s4 = Do For(1, 1000, NameBlock ( Real k ) {
    Text name = "id"<<k;
    @Ej ej = [[ 
      Text _.name = name
    ]];
    PutName( name, ej )
  });



// Monday, 2012/03/05 21:09:02.00
 Set For(1, 500, Real (Real i) {
  Real 1
} )

// Monday, 2012/03/05 21:08:51.00
 Set For(1, 500, NameBlock (Real i) {
  Real 1
} )

// Monday, 2012/03/05 21:05:40.00
Class @Ej {
  Text _.name
 };
 Set For(1, 500, NameBlock (Real i) {
  Text name = "id"<<FormatReal(i, "03.0lf");
  @Ej ej = [[
    Text _.name = name
  ]];
  PutName(name, ej)
 });

// Monday, 2012/03/05 20:56:44.00
Text TclChartSet(s2, SetOfSet(@TclArgSt("-type", "1")));

// Monday, 2012/03/05 20:56:23.00
Text TclChartSet(s1, SetOfSet(@TclArgSt("-type", "1")));

// Monday, 2012/03/05 20:51:23.00
Set s1 = BinGroup("|", For(1, 4, Set (Real i) {
  Set For(1, 10, Set (Real j) {
    [[j, i + j]]
  })
}));
Text TclChartSet(s1, SetOfSet(@TclArgSt("-type", "3")));


// Monday, 2012/03/05 20:43:19.00
Text TclChartSet(s2, SetOfSet(@TclArgSt("-type", "3")));

// Monday, 2012/03/05 20:36:53.00
Set s2 = BinGroup("|", For(1, 4, Set (Real i) {
  Set For(1, 10, Set (Real j) {
    [[j, If(i==j, ?, i+j)]]
  })
}));
Text TclChartSet(s2, SetOfSet(@TclArgSt("-type", "3")));



// Monday, 2012/03/05 14:54:41.00
Text TclChartSet(s2, SetOfSet(@TclArgSt("-type", "3")));

// Monday, 2012/03/05 14:15:59.00
Text TclChartSet(s2, SetOfSet(@TclArgSt("-type", "3")));

// Monday, 2012/03/05 14:09:35.00
Text TclChartSet(s2, SetOfSet(@TclArgSt("-type", "3")));

// Monday, 2012/03/05 10:56:05.00
Text TclChartSet(s2, SetOfSet(@TclArgSt("-type", "3")));

// Monday, 2012/03/05 10:52:55.00
Set s2 = BinGroup("|", For(1, 4, Set (Real i) {
  Set For(1, 10, Set (Real j) {
    [[j, If(i==j, ?, i+j)]]
  })
}));
Text TclChartSet(s2, SetOfSet(@TclArgSt("-type", "3")));


// Friday, 2012/03/02 15:20:24.00
Set s2 = BinGroup("|", For(1, 4, Set (Real i) {
  Set For(1, 10, Set (Real j) {
    [[j, If(i==j, ?, i+j)]]
  })
}));
Text TclChartSet(s2, SetOfSet(@TclArgSt("-type", "3")));


// Friday, 2012/03/02 15:19:09.00
Set s2 = BinGroup("|", For(1, 4, Set (Real i) {
  Set For(1, 10, Set (Real j) {
    [[j, If(i==j, ?, i+j)]]
  })
}));
Text TclChartSet(s2, SetOfSet(@TclArgSt("-type", "3")));


// Thursday, 2012/03/01 18:12:39.00
Set dep = TolPackage::Client::GetCompatibleDeepDependencies(Version, [[ "ToltclLinux32" ]] );


// Thursday, 2012/03/01 18:11:37.00
Real TolPackage::Client::DownloadCompatibleDeepDependencies
( "/tmp/KKK", 1, Text Version, [[ "TclCore", "TclCoreLinux32", "ToltclLinux32" ]] );

// Thursday, 2012/03/01 18:10:27.00
Real TolPackage::Client::DownloadCompatibleDeepDependencies
( "/tmp/KKK", 0, Text Version, [[ "ToltclLinux32" ]] );

// Thursday, 2012/03/01 17:56:52.00
Real TolPackage::Client::DownloadCompatibleDeepDependencies
( "/tmp/MMS", 0, Text Version, [[ "MMS", "TclCore", "TclCoreLinux32", "ToltclLinux32" ]] );


// Wednesday, 2012/02/29 20:49:15.00
Set s2 = BinGroup("|", For(1, 4, Set (Real i) {
  Set For(1, 10, Set (Real j) {
    [[j, If(i==j, ?, i+j)]]
  })
}));
Text TclChartSet(s2, SetOfSet(@TclArgSt("-type", "3")));



// Wednesday, 2012/02/29 20:48:54.00
Set s1 = BinGroup("|", For(1, 4, Set (Real i) {
  Set For(1, 10, Set (Real j) {
    [[j, i + j]]
  })
}));
Text TclChartSet(s1, SetOfSet(@TclArgSt("-type", "3")));



// Wednesday, 2012/02/29 13:28:00.00
Set badF( Set options )
{
  Text addr = GetAddressFromObject( options );
  Set GetObjectFromAddress( addr )
};

Set s := [[ 1, 2 ]];
Set badF( s );




// Wednesday, 2012/02/29 13:27:44.00
Set badF( Set options )
{
  Text addr = GetAddressFromObject( options );
  Set GetObjectFromAddress( addr )
};

Set s = [[ 1, 2 ]];
Set badF( s );



// Wednesday, 2012/02/29 13:27:30.00
Set badF( Set options )
{
  Text addr = GetAddressFromObject( options );
  Set GetObjectFromAddress( addr )
};

Set s = [[ 1, 2 ]];
Set badF( s );



// Wednesday, 2012/02/29 13:27:24.00
Set badF( Set options )
{
  Text addr = GetAddressFromObject( options );
  Set GetObjectFromAddress( addr );
};

Set s = [[ 1, 2 ]];
Set badF( s );



// Tuesday, 2012/02/28 19:22:50.00
NameBlock a1 = 
[[
  Class @b { Real c };
  PutDescription("Clase de ejemplo sencillo dentro de un NameBlock","@b")
]];
NameBlock a2 = 
[[
  Class @b { Real c }
]];
Class @b1 { Real c };
PutDescription("Clase global de ejemplo sencillo","@b1");
Class @b2 { Real c };


// Tuesday, 2012/02/28 19:17:52.00
#Require MMS;

NameBlock a1 = 
[[
  Class @b { Real c };
  PutDescription("Clase de ejemplo sencillo dentro de un NameBlock","@b")
]];
NameBlock a2 = 
[[
  Class @b { Real c }
]];
Class @b1 { Real c };
PutDescription("Clase global de ejemplo sencillo","@b1");
Class @b2 { Real c };


// Tuesday, 2012/02/28 19:16:32.00
MMS

// Tuesday, 2012/02/28 19:15:59.00
#Require MMS;


// Tuesday, 2012/02/28 19:03:23.00
MMS

// Tuesday, 2012/02/28 19:03:17.00
#Require MMS;



// Tuesday, 2012/02/28 11:03:50.00

Set View( [[ NameBlock [[ Real a = 1 ]] ]], "" );

// Tuesday, 2012/02/28 11:03:44.00
Set View( [[ NameBlock [[ Real a = 1 ]] ]] );

// Tuesday, 2012/02/28 10:59:33.00
Real KK( NameBlock k )
{
  WriteLn( Name( k ) );
	Real 1
};

Real KK( NameBlock [[ Real a = 1 ]] )


// Monday, 2012/02/27 19:41:51.00
Text GetSourcePath( StdLib );



// Monday, 2012/02/27 19:41:43.00
Text GetSourcePath( TolConfigManager );



// Monday, 2012/02/27 19:41:36.00
Text SourcePath( TolConfigManager );



// Monday, 2012/02/27 13:56:27.00
#Require MMS;


// Friday, 2012/02/24 16:37:25.00
#Require MMS


// Friday, 2012/02/24 16:32:57.00
MMS

// Friday, 2012/02/24 16:32:20.00
#Require MMS;


// Friday, 2012/02/24 14:15:09.00
#Require MMS;


// Friday, 2012/02/24 12:55:20.00
Anything kk = GetObjectFromAddress( "kk" );

// Friday, 2012/02/24 12:48:01.00
Text sn = "";

Text If( sn != "", "no", "si" );


// Thursday, 2012/02/23 20:21:05.00
Set Include( "kk.tol" );

// Thursday, 2012/02/23 20:14:15.00
Set Tcl_EvalEx( [[ "Tol_StructOfFromReference", [[ "File", path ]] ]] );

// Thursday, 2012/02/23 20:13:00.00
Text path = GetSourcePath( Real TestFantasma );

// Thursday, 2012/02/23 20:12:53.00
Set Include( "TestFantasma.tol" );

// Thursday, 2012/02/23 20:12:43.00
Set Include( "TestFantastma.tol" );

// Thursday, 2012/02/23 20:12:40.00
Text WriteFile( "TestFantasma.tol", "Real TestFantasma = 1" );

// Wednesday, 2012/02/22 18:17:00.00
Set Tcl_Eval( "::TolConfigGUI::Show" );


// Wednesday, 2012/02/22 18:16:50.00
Set Tcl_EvalEx( "::TolConfigGUI::Show" );


// Wednesday, 2012/02/22 17:20:17.00
Set kk = [[ 0, 1]];


// Wednesday, 2012/02/22 16:58:30.00
Set kk = [[ 1,2 ]];


// Tuesday, 2012/02/21 21:35:56.00
Set yy = Ois.Load( "/tmp/test.oza" );

// Tuesday, 2012/02/21 21:34:16.00
Set kk = { Include( "/tmp/test.oza" ) }

// Tuesday, 2012/02/21 21:33:23.00
Real Ois.Store( [[Real 1, Real 2]], "/tmp/test.oza" );


// Tuesday, 2012/02/21 16:01:33.00
Ois.DefDoc



// Tuesday, 2012/02/21 16:00:32.00
#Require MMS


// Tuesday, 2012/02/21 13:06:22.00
#Require GuiTools;


// Tuesday, 2012/02/21 09:44:52.00
Set ReportFit = { Include( "r01_fit_output.oza" ) };

// Tuesday, 2012/02/21 09:39:31.00
Real JsonHelper::JsonWriteField( series );

// Tuesday, 2012/02/21 09:39:27.00
Serie s1 = SubSer( Gaussian( 0, 1 ), y2001m1, y2001m1d3 );
Serie s2 = SubSer( Gaussian( 0, 1 ), y2001m1, y2001m1d3);
Set series = [[ s1, s2 ]];

// Tuesday, 2012/02/21 09:38:33.00
Serie s1 = SubSer( Gaussian( 0, 1 ), y2001m1, y2001m1d3 );
Serie s2 = SubSer( Gaussian( 0, 1 ), y2001m1, y2001m1d3);
Set series = [[ s1, s2 ]];
Set sdata1 = JsonHelper::GetSerieData( series );

Real x = 1;
Date d = y2012;
Text name = "Jorge";

Real JsonHelper::JsonWriteField( x ); WriteLn( "," );
Real JsonHelper::JsonWriteField( d ); WriteLn( "," );
Real JsonHelper::JsonWriteField( name );WriteLn( "," );
Real JsonHelper::JsonWriteField( series );

Set EvalSet( sdata, Text( Anything it ) { Grammar( it ) } )

Real BinGroup( "And", EvalSet( series, Real( Anything it ) {
                      Grammar(it)=="Serie" } ) )


// Tuesday, 2012/02/21 09:36:49.00
Real JsonHelper::JsonWriteField( series );

// Tuesday, 2012/02/21 09:36:46.00
Serie s1 = SubSer( Gaussian( 0, 1 ), y2001m1, y2001m1d3 );
Serie s2 = SubSer( Gaussian( 0, 1 ), y2001m1, y2001m1d3);
Set series = [[ s1, s2 ]];

// Tuesday, 2012/02/21 09:36:06.00
Real JsonHelper::JsonWriteField( series );

// Tuesday, 2012/02/21 09:35:59.00
Serie s1 = SubSer( Gaussian( 0, 1 ), y2001m1, y2001m1d3 );
Serie s2 = SubSer( Gaussian( 0, 1 ), y2001m1, y2001m1d3);
Set series = [[ s1, s2 ]];

// Tuesday, 2012/02/21 09:32:56.00
Set sdata1 = JsonHelper::GetSerieData( series );

// Tuesday, 2012/02/21 09:29:56.00
Real JsonHelper::JsonWriteField( series );

// Tuesday, 2012/02/21 09:29:40.00
Serie s1 = SubSer( Gaussian( 0, 1 ), y2001m1, y2001m1d3 );
Serie s2 = SubSer( Gaussian( 0, 1 ), y2001m1, y2001m1d3);
Set sdata = JsonHelper::GetSerieData( [[s1,s2]] );
Set series = [[ s1, s2 ]];
Real x = 1;
Date d = y2012;
Text name = "Jorge";

// Tuesday, 2012/02/21 09:29:28.00
Set sdata = JsonHelper::GetSerieData( [[s1,s2]] );
Set series = [[ s1, s2 ]];
Real x = 1;
Date d = y2012;
Text name = "Jorge";

// Tuesday, 2012/02/21 09:24:27.00
Real BinGroup( "And", EvalSet( series, Real( Anything it ) {
                      Grammar(it)=="Serie" } ) )

// Tuesday, 2012/02/21 09:24:23.00
Set series = [[ s1, s2 ]];

// Tuesday, 2012/02/21 09:24:02.00
Real BinGroup( "And", EvalSet( series, Real( Anything it ) {
                      Grammar(it)=="Serie" } ) )

// Tuesday, 2012/02/21 09:23:44.00
Set EvalSet( sdata, Text( Anything it ) { Grammar( it ) } )

// Tuesday, 2012/02/21 09:22:44.00
Real BinGroup( "And", EvalSet( sdata, Real( Anything it ) {
                      Grammar(it)=="Serie" } ) )

// Tuesday, 2012/02/21 09:22:27.00
BinGroup( "And", EvalSet( sdata, Real( Anything it ) {
                      Grammar(it)=="Serie" } ) )

// Tuesday, 2012/02/21 09:07:10.00
Real JsonHelper::JsonWriteField( x ); WriteLn( "," );
Real JsonHelper::JsonWriteField( d ); WriteLn( "," );
Real JsonHelper::JsonWriteField( name );

// Tuesday, 2012/02/21 09:06:31.00
Real JsonHelper::JsonWriteField( d );

// Tuesday, 2012/02/21 09:06:26.00
Serie s1 = SubSer( Gaussian( 0, 1 ), y2001m1, y2001m1d3 );
Serie s2 = SubSer( Gaussian( 0, 1 ), y2001m1, y2001m1d3);
Set sdata = JsonHelper::GetSerieData( [[s1,s2]] );

Real x = 1;
Date d = y2012;
Text name = "Jorge";

Real JsonHelper::JsonWriteField( x );

// Tuesday, 2012/02/21 09:05:53.00
Serie s2 = SubSer( Gaussian( 0, 1 ), y2001m1, y2001m1d3);
Set sdata = JsonHelper::GetSerieData( [[s1,s2]] );

Real x = 1;
Date d = y2012;
Text name = "Jorge";

Real JsonHelper::JsonWriteField( x );

// Tuesday, 2012/02/21 09:05:09.00
Real JsonHelper::JsonWriteField( x );

// Tuesday, 2012/02/21 09:04:37.00
Real JsonHelper::JsonWriteField( x );

// Tuesday, 2012/02/21 09:04:20.00
Real JsonWriteField( x );

// Tuesday, 2012/02/21 09:04:17.00

Real x = 1;
Date d = y2012;
Text name = "Jorge";

// Tuesday, 2012/02/21 09:03:10.00
Set sdata = JsonHelper::GetSerieData( [[s1,s2]] );

// Tuesday, 2012/02/21 09:02:51.00
Serie s1 = SubSer( Gaussian( 0, 1 ), y2001m1, y2001m1d3 );
Serie s2 = SubSer( Gaussian( 0, 1 ), y2001m1, y2001m1d3);
Set GetSerieData( [[s1,s2]] );


// Monday, 2012/02/20 23:33:41.00
Set GetSerieData( [[s1,s2]] );

// Monday, 2012/02/20 23:33:20.00
Serie s1 = SubSer( Gaussian( 0, 1 ), y2001m1, y2001m3 );
Serie s2 = SubSer( Gaussian( 0, 1 ), y2001m1, y2001m3);

// Monday, 2012/02/20 23:33:02.00
Serie s1 = SubSer( Gaussian( 0, 1) ), y2001m1, y2001m3 );
Serie s2 = SubSer( Gaussian( 0, 1 ), y2001m1, y2001m3);

// Monday, 2012/02/20 23:32:32.00
    Set GetSerieData( Set series )
    {
      Set dates = Dates( Dating( series[1] ),
                         First( series[1] ), Last( series[1] ) );
      EvalSet( dates, Set ( Date _d ) {
          [[ Date d = _d ]] <<
            EvalSet( series, Real( Serie s ) {
                Real x = SerDat( s, _d );
                PutName( Name( s ), x )
              } )
        } )
    };

Serie s1 = SubSer( Gaussian( 0, 1), y2001m1, y2001m3 );
Serie s2 = Gaussian( 0, 1 , y2001m1, y2001m3);

Set GetSerieData( [[s1,s2]] );


// Monday, 2012/02/20 15:05:40.00
Real Ois.Store( r02_output, "/tmp/r02_deco_output.oza" );

// Monday, 2012/02/20 15:03:54.00
Set r02_output = {
  Text name = r02::GetName(?);
  Set levels = EvalSet( r02::GetDatings(?), Text( TimeSet d ) { Name( d ) } );
  Set groups = EvalSet( r02::_.decomposition, Text( Serie g ) { Name( g ) } );
  Set graphs = For( 1, Card( levels ), Set( Real k ) {
      Set aux = r02::GetDecomposition( k );
      Set PutName( levels[ k ], aux )
    } );
    [[ name, levels, groups, graphs ]]
};



// Monday, 2012/02/20 15:02:37.00
Set r02_output = {
  Text name = r02::GetName(?);
  Set levels = r02::GetDatings(?);
  Set groups = EvalSet( r02::_.decomposition, Text( Serie g ) { Name( g ) } );
  Set graphs = For( 1, Card( levels ), Set( Real k ) {
      Set aux = r02::GetDecomposition( k );
      Set PutName( levels[ k ], aux )
    } );
    [[ name, levels, groups, graphs ]]
};



// Monday, 2012/02/20 14:59:44.00
Set r02_output = {
  Text name = r02::GetName(?);
  Set levels = r02::GetDatings(?);
  Set groups = EvalSet( r02::_.decomposition, Text( Serie g ) { Name( g ) } );
  Set graphs = For( 1, Card( levels ), Set( Real k ) {
      r02::GetDecomposition( k )
    } );
    [[ name, levels, groups, graphs ]]
};



// Monday, 2012/02/20 12:23:36.00
Real TextMatch_Tcl("farola", "*o*A", 1);


// Monday, 2012/02/20 12:23:30.00
Real TextMatch_Tcl("farola", "*o*a", 1);


// Monday, 2012/02/20 12:13:33.00
Real t0 := Copy(Time);
Real n := 100000;
Real k := 0;
While( k < n, {
  Real TextMatch_Tcl0("farola", "*o*a", 1);
  k := k + 1 } );
Real t1 := Time - t0;
Real t0 := Copy(Time);
Real k := 0;
While( k < n, {
  Real TextMatch_Tcl("farola", "*o*a", 1);
  k := k + 1 } );
Real t2 := Time - t0;



// Monday, 2012/02/20 12:12:47.00
Real t0 := Copy(Time);
Real n := 100000;
Real k := 0;
While( k < n, {
  Real TextMatch_Tcl0("farola", "*o*a", 1);
  k := k + 1 } );
Real t1 = Time - t0;
Real t0 := Copy(Time);
Real k := 0;
While( k < n, {
  Real TextMatch_Tcl("farola", "*o*a", 1);
  k := k + 1 } );
Real t2 := Time - t0;



// Monday, 2012/02/20 12:11:29.00
Real t0 = Copy(Time);
Real n = 10000;
Real k = 0;
While( k < n, {
  Real TextMatch_Tcl0("farola", "*o*a", 1);
  k := k + 1 } );
Real t1 = Time - t0;
Real t0 := Copy(Time);
Real k := 0;
While( k < n, {
  Real TextMatch_Tcl("farola", "*o*a", 1);
  k := k + 1 } );
Real t2 = Time - t0;

// Monday, 2012/02/20 12:07:30.00
Real TextMatch_Tcl0("farola", "*o*a", 1);

// Monday, 2012/02/20 12:07:24.00
Real TextMatch_Tcl0("farola", "*o*A", 1);

// Monday, 2012/02/20 12:07:19.00
Real TextMatch_Tcl0("farola", "*o*A", 0);

// Monday, 2012/02/20 12:07:15.00
Real TextMatch_Tcl0(Text text, Text pattern, Real case)
{
  Set tclScript = [[ "string", "match" ]];
  Set If( Not(case), Set Append( tclScript, [[ "-nocase" ]] ) );
  Set Append( tclScript, [[ pattern, text ]] );
  TextToReal( Tcl_EvalEx( tclScript )[1] )
};

// Monday, 2012/02/20 12:06:38.00

Real TextMatch_Tcl0("farola", "*o*A", 0);

// Monday, 2012/02/20 12:06:31.00
Real TextMatch_Tcl0("farola", "*o*a", 0);

// Monday, 2012/02/20 12:06:23.00
Real TextMatch_Tcl0("farola", "*o*a", 1);

// Monday, 2012/02/20 12:06:20.00
Real TextMatch_Tcl0(Text text, Text pattern, Real case)
{
  Set tclScript = [[ "string", "match" ]];
  Set If( case, Set Append( tclScript, [[ "-nocase" ]] ) );
  Set Append( tclScript, [[ pattern, text ]] );
  TextToReal( Tcl_EvalEx( tclScript )[1] )
};


// Monday, 2012/02/20 12:05:46.00
Real TextMatch_Tcl0("farola", "*o*a", 1);

// Monday, 2012/02/20 12:05:40.00
Real TextMatch_Tcl0(Text text, Text pattern, Real case)
{
  Set tclScript = [[ "string", "match" ]];
  If( case, Set Append( tclScript, [[ "-nocase" ]] ) );
  Set Append( tclScript, [[ pattern, text ]] );
  TextToReal( Tcl_EvalEx( tclScript )[1] )
};

// Monday, 2012/02/20 12:04:36.00
Real TextMatch_Tcl0("farola", "*o*a", 1);

// Monday, 2012/02/20 12:04:31.00
Real TextMatch_Tcl0(Text text, Text pattern, Real case)
{
  Set tclScript = [[ "string", "match" ]];
  If( case, Set Append( tclScript, [[ "-nocase" ]] ) );
  Set Append( tclScript, [[ pattern, text ]] );
  Tcl_EvalEx( tclScript )[1]
};


// Monday, 2012/02/20 12:04:16.00
Real TextMatch_Tcl0("farola", "*o*a", 1);

// Monday, 2012/02/20 12:04:14.00
Real TextMatch_Tcl0(Text text, Text pattern, Real case)
{
  Set tclScript = [[ "string", "match" ]];
  If( case, Append( tclScript, [[ "-nocase" ]] ) );
  Set Append( tclScript, [[ pattern, text ]] );
  Tcl_EvalEx( tclScript )[1]
};


// Monday, 2012/02/20 12:03:54.00
Real TextMatch_Tcl0("farola", "*o*a", 1);

// Monday, 2012/02/20 12:03:42.00
Real TextMatch_Tcl0("farola", "*o*a");

// Monday, 2012/02/20 12:01:55.00
Real TextMatch_Tcl0(Text text, Text pattern, Real case)
{
  Set tclScript = [[ "string", "match" ]];
  If( case, Append( tclScript, [[ "-nocase" ]] ) );
  Append( tclScript, [[ pattern, text ]] );
  Tcl_EvalEx( tclScript )[1]
};


// Sunday, 2012/02/19 23:42:14.00
Set aa = [[ 1, 2 ]];
NameBlock bb = [[ Real k = 1 ]];

// Saturday, 2012/02/18 19:58:17.00
#Require MMS;


// Friday, 2012/02/17 11:30:26.00
Set ReportFit = { Include( "ReportFit.oza" ) };


// Thursday, 2012/02/16 22:06:19.00
Set ReportFit = { Include( "/tmp/ReportFit.oza" ) };


// Thursday, 2012/02/16 22:06:10.00
Set ReportFit = { Include( "/tmp/ReportFit.oza" );


// Thursday, 2012/02/16 22:05:10.00
Real Ois.Store( ReportFit, "/tmp/ReportFit.oza" );

// Thursday, 2012/02/16 22:03:37.00
Set ReportFit = [[ {Text name = "Ajuste"}, graphs, tables ]]; 


// Thursday, 2012/02/16 22:03:28.00
Set ReportFit = [[ {Text name = "Ajuste", graphs, tables ]]; 


// Wednesday, 2012/02/15 13:23:08.00
AllLinear

// Wednesday, 2012/02/15 12:32:11.00
Class @A {  Real v };
@A a = [[ Real v=1 ]];

// Wednesday, 2012/02/15 12:14:14.00
Text GetSourcePath( MMS );

// Wednesday, 2012/02/15 11:58:43.00
MMS

// Wednesday, 2012/02/15 11:58:31.00
#Require MMS


// Tuesday, 2012/02/14 14:11:24.00
TOLSH_PATH<<"/../lib/toltk/images/about.gif"

// Tuesday, 2012/02/14 12:54:40.00
SetOfText("un texto","otro texto \"distinto\"")

// Tuesday, 2012/02/14 12:45:52.00
Text WriteLn("Texto corto 1");
Text WriteLn(Repeat("EsteEsUnTextoNormalQueVoyARepetirMuchasVeces", 1000));
Text WriteLn("Texto corto 2");

// Tuesday, 2012/02/14 12:45:01.00
Text WriteLn("Texto corto 1");
Text WriteLn(Repeat("EsteEsUnTextoNormalQueVoyARepetirMuchasVeces", 1000));
Text WriteLn("Texto corto 2");

// Tuesday, 2012/02/14 12:29:09.00
    Set set1 = SetOfSet( SetOfText("a","b") );

    Text tabla01 = TclTabulateSet(set1, SetOfSet(

        TclArgSt("-title","Tabulando un Set")

    ));


// Tuesday, 2012/02/14 08:57:35.00
Real n = 15;
Matrix data0 = BinGroup("|", For(1, n, Matrix(Real i) { Col(1,2,3,4,5)|Col(i,i,i,i,i) } ) );

Set data1 = MatSet(data0);

Text TclChartSet( data1, [[ 
    @TclArgSt("-title", Tcl_Eval("mc {Density Functions}")[1]),
    @TclArgSt("-names", TxtListTcl(For(1, n, Text(Real i) { "v"<<i   }))),
      @TclArgSt("-type" , "3")
    ]]);


// Tuesday, 2012/02/14 08:56:02.00
Real n = 6;
Matrix data0 = BinGroup("|", For(1, n, Matrix(Real i) { Col(1,2,3,4,5)|Col(i,i,i,i,i) } ) );

Set data1 = MatSet(data0);

Text TclChartSet( data1, [[ 
    @TclArgSt("-title", Tcl_Eval("mc {Density Functions}")[1]),
    @TclArgSt("-names", TxtListTcl(For(1, n, Text(Real i) { "v"<<i   }))),
      @TclArgSt("-type" , "3")
    ]]);


// Tuesday, 2012/02/14 08:55:00.00
Text TclChartSet( data1, [[ 
    @TclArgSt("-title", Tcl_Eval("mc {Density Functions}")[1]),
    @TclArgSt("-names", TxtListTcl(For(1, n, Text(Real i) { "v"<<i   }))),
      @TclArgSt("-type" , "3")
    ]]);


// Tuesday, 2012/02/14 08:53:21.00
Real n = 5;
Matrix data0 = BinGroup("|", For(1, n, Matrix(Real i) { Col(1,2,3,4,5)|Col(i,i,i,i,i) } ) );

Set data1 = MatSet(data0);


// Monday, 2012/02/13 19:53:46.00
MatSet(BinGroup("|", 
  For(1, 6, Matrix(Real i) { Col(1,2,3,4,5)|Col(i,i,i,i,i) })
  ))

// Monday, 2012/02/13 18:54:30.00
Text TclChartSet(MatSet(BinGroup("|", 
  For(1, 6, Matrix(Real i) { Col(1,2,3,4,5)|Col(i,i,i,i,i) })
  )), [[ 
    @TclArgSt("-title", Tcl_Eval("mc {Density Functions}")[1]),
    @TclArgSt("-names", TxtListTcl(For(1, 6, Text(Real i) { "v"<<i   }))),
      @TclArgSt("-type" , "3")
    ]]);



// Monday, 2012/02/13 14:44:43.00
Text Eval( "Text \"Hola que tal \\\"\"");

// Monday, 2012/02/13 14:44:22.00
Text ParseError( "Text \"Hola que tal \\\"\"");

// Monday, 2012/02/13 14:42:32.00
Text "Hola que tal \""


// Monday, 2012/02/13 12:23:07.00
Real 1 = 2;


// Sunday, 2012/02/12 15:22:08.00
Text I2( "hello", "hola" );


// Friday, 2012/02/10 10:39:09.00
Real TolConfigManager::Config::Upgrading::TolPackage::LocalOnly


// Friday, 2012/02/10 10:24:37.00
 Real TolPackage::Client::RemoteUpdatePackSyncInfo(False);

// Friday, 2012/02/10 10:24:25.00
Real  TolConfigManager::Config::Upgrading::TolPackage::LocalOnly := 1;
Real TolConfigManager::Config::Upgrading::TolVersion::CheckAllowed := 0;


// Thursday, 2012/02/09 17:56:29.00
Real TolConfigManager::Config::Various::Verbose::ShowStackAtWarning := 1;

Real f(Real a)
{
  If( a, WriteLn( "ok" ), WriteLn( "oops" ) )
};

Real f(?);



// Thursday, 2012/02/09 17:56:22.00
Real TolConfigManager::Config::Various::Verbose::ShowStackAtWarning := 1;

Real f(Real a)
{
  If( a, WriteLn( "ok" ), WriteLn( "oops" ) )
};

Real f(?);



// Thursday, 2012/02/09 17:54:53.00
Real f(Real a)
{
  If( a, WriteLn( "ok" ), WriteLn( "oops" ) )
};

Real f(?);

// Thursday, 2012/02/09 17:47:29.00
Real TolPackage::Client::RemoteInstall( "http://packages.tol-project.org/OfficialTolArchiveNetwork/repository.php", "QltvRespModel.4.1", 1 );

// Thursday, 2012/02/09 17:47:10.00
Real TolPackage::Client::RemoteInstall( "http://packages.tol-project.org/OfficialTolArchiveNetwork/repository.php", "QltvR

// Thursday, 2012/02/09 17:47:06.00
Real TolPackage::Client::trace_max_level := 100000;

// Thursday, 2012/02/09 17:43:28.00
Real TolPackage::Client::RemoteInstall( "http://packages.tol-project.org/OfficialTolArchiveNetwork/repository.php", "QltvRespModel.4.1", 1 );


// Thursday, 2012/02/09 17:43:05.00
Real TolConfigManager::Config::Various::Verbose::ShowStackAtWarning := 1


// Thursday, 2012/02/09 17:40:16.00
Real TolPackage::Client::RemoteInstall( "http://packages.tol-project.org/OfficialTolArchiveNetwork/repository.php", "QltvRespModel.4.1", 1 );


// Thursday, 2012/02/09 17:32:53.00
Real TolConfigManager::Config::Various::Verbose::ShowStackAtWarning := 1


// Thursday, 2012/02/09 17:31:54.00
Real TolConfigManager::Config::Various::Verbose::ShowStackAtWarning := 1


// Monday, 2012/02/06 19:54:14.00
#Require GuiTools;

// Monday, 2012/02/06 19:53:49.00
For(1, 10, Set(Real k){ [[k]] } )

// Monday, 2012/02/06 19:53:33.00
Set X = [[ For(1, 10, Set(Real k){ [[k]] } ) ]];
Text tad = GetAddressFromObject( X[1] );
Set obj = GetObjectFromAddress( tad );



// Sunday, 2012/02/05 19:31:30.00
Set obj = GetObjectFromAddress( tad );

// Sunday, 2012/02/05 19:31:26.00
Text tad = GetAddressFromObject( X[1] );

// Sunday, 2012/02/05 19:31:22.00
Set X = [[ For(1, 10, Set(Real k){ [[k]] } ) ]];

// Sunday, 2012/02/05 19:31:10.00
Set X = [[ For(1, 10, Set(Real k){ [[k]] } ) } ]];

// Sunday, 2012/02/05 19:30:27.00
Set X = SetOfAnything( { Set _x = For(1, 10, Set(Real k){ [[k]] } ) } );

// Sunday, 2012/02/05 19:29:59.00
Set X = [[ { Set _x = For(1, 10, Set(Real k){ [[k]] } ) }
 ]];

// Sunday, 2012/02/05 19:29:17.00
Set X = [[ Set For(1, 10, Set(Real k){ [[k]] } ) ]];

Text tad = GetAddressFromObject( X[1] );

Set obj = GetObjectFromAddress( tad );

// Sunday, 2012/02/05 19:28:56.00
Set X = [[ { Set xx = For(1, 10, Set(Real k){ [[k]] } ) } ]];

// Sunday, 2012/02/05 19:28:36.00
Set obj = GetObjectFromAddress( tad );

// Sunday, 2012/02/05 19:28:18.00
Text tad = GetAddressFromObject( X[1] );

// Sunday, 2012/02/05 19:28:13.00
Set X = [[ Set xx = For(1, 10, Set(Real k){ [[k]] } ) ]];

// Sunday, 2012/02/05 19:27:30.00
Set X = [[ Set xx = For(1, 10, Set(Real k){ [[k]] } 
]];

// Sunday, 2012/02/05 19:27:16.00
Set X = [[ Set xx = For(1, 10, Set(Real k){ [[k]] } ]];

// Sunday, 2012/02/05 19:26:59.00
Set X = { [[ Set xx = For(1, 10, Set(Real k){ [[k]] } ]] };

// Sunday, 2012/02/05 19:26:14.00
Set X = [[ { Set xx = For(1, 10, Set(Real k){
  [[k]]
}) } ]];


// Sunday, 2012/02/05 19:25:09.00
Set obj = GetObjectFromAddress( tad );

// Sunday, 2012/02/05 19:25:05.00
Text tad = GetAddressFromObject( X[1] );

// Sunday, 2012/02/05 19:24:53.00
Set X = [[ For(1, 10, Set(Real k){
  [[k]]
}) ]];

// Sunday, 2012/02/05 19:18:58.00
Set obj = GetObjectFromAddress( "937BFC8:0:88A7920:0:859EF48:0:2:4:6166" );

// Sunday, 2012/02/05 19:18:28.00
Anything obj = GetObjectFromAddress( "937BFC8:0:88A7920:0:859EF48:0:2:4:6166" );

// Sunday, 2012/02/05 19:04:43.00
#Require GuiTools;

Set For(1, 10, Set(Real k){
  [[k]]
})


// Sunday, 2012/02/05 18:58:51.00
Set For(1, 10, Set(Real k){
  [[k]]
});

// Sunday, 2012/02/05 18:58:36.00
#Require GuiTools;

// Saturday, 2012/02/04 10:02:12.00
Text Qry =
"
select a, b
from tabla;
";


// Saturday, 2012/02/04 10:02:10.00
Text Qry =
"
select a, b
from tabla;
";


// Saturday, 2012/02/04 10:01:51.00
Text Qry =
"
select a, b
from tabla
";


// Saturday, 2012/02/04 10:01:10.00
Text Qry =
"
select a, b
from tabla
";


// Saturday, 2012/02/04 09:46:56.00
Text sample =
"
linea 1
linea 2
";



// Saturday, 2012/02/04 09:43:22.00
 Text Qry =
 "
 select a, b
 from tabla
 ";


// Saturday, 2012/02/04 09:35:45.00
Set For(1, 10, Set(Real k){
  [[k]]
 });


// Thursday, 2012/02/02 17:52:43.00
0.2 + 0.2 + 0.2

// Thursday, 2012/02/02 17:51:35.00
Real LE(3*0.2, 0.6);

// Thursday, 2012/02/02 17:50:06.00
Real 3*0.2


// Thursday, 2012/02/02 17:50:02.00
Real 3*0.1


// Thursday, 2012/02/02 17:47:48.00
Real 0.4 + 0.02


// Thursday, 2012/02/02 17:44:55.00
Set Range(0, 0.05, 0.005)  <<
Range(0.06, 0.09, 0.01) <<
Range(0.1, 0.3, 0.01)


// Tuesday, 2012/01/24 19:58:34.00
#Require MMS;


// Friday, 2012/01/20 23:28:42.00
MMS

// Friday, 2012/01/20 23:28:39.00
#Require MMS;


// Thursday, 2012/01/19 21:35:13.00
Real DateDif( Diario, nac, y2002m12d31 );

// Thursday, 2012/01/19 21:34:45.00
Real DateDif( Diario, nac, y2002m6d30 );

// Thursday, 2012/01/19 21:33:33.00
Date nac = y2002m6d13;
Date hoy = Today;
Real DateDif( Diario, nac, hoy );

// Thursday, 2012/01/19 17:03:23.00
MMS

// Thursday, 2012/01/19 17:03:21.00
#Require MMS


// Thursday, 2012/01/19 15:43:32.00
MMS

// Thursday, 2012/01/19 15:43:06.00
#Require MMS


// Thursday, 2012/01/19 15:38:03.00
 MMS

// Thursday, 2012/01/19 15:36:05.00
#Require BysMcmc


// Thursday, 2012/01/19 15:30:52.00
MMS

// Thursday, 2012/01/19 15:30:31.00
#Require MMS;


// Thursday, 2012/01/19 15:28:13.00
MMS

// Thursday, 2012/01/19 15:28:06.00
#Require MMS;


// Thursday, 2012/01/19 15:19:24.00
MMS

// Thursday, 2012/01/19 15:19:06.00
#Require MMS


// Thursday, 2012/01/19 15:14:45.00
MMS

// Thursday, 2012/01/19 15:14:43.00
#Require MMS


// Thursday, 2012/01/19 15:09:18.00
MMS

// Thursday, 2012/01/19 15:09:07.00
#Require MMS;


// Thursday, 2012/01/19 15:00:48.00
MMS

// Thursday, 2012/01/19 15:00:44.00
#Require MMS;


// Thursday, 2012/01/19 14:58:37.00
#Require MMS;


// Thursday, 2012/01/19 11:40:00.00
#Require MMS;

Real MMS::@RepositoryFolder::Create([[
  Text _.path = "/media/nas/bmr/BBVASP/PrCoCo.CensoredProbit"
]]);



// Thursday, 2012/01/19 11:17:38.00
MMS

// Thursday, 2012/01/19 11:17:35.00
#Require MMS


// Thursday, 2012/01/19 11:17:16.00
MMS


// Thursday, 2012/01/19 00:52:51.00
MMS

// Thursday, 2012/01/19 00:52:37.00
#Require MMS


// Wednesday, 2012/01/18 18:30:37.00
MMS

// Wednesday, 2012/01/18 18:30:14.00
#Require MMS;


// Wednesday, 2012/01/18 18:11:20.00
Text "&lt; <"


// Wednesday, 2012/01/18 18:03:55.00
Text "&lt;"


// Wednesday, 2012/01/18 18:03:42.00
Text "&"


// Wednesday, 2012/01/18 17:50:26.00
Text "''aaaaa ''";
Text "a '''a''' ''a''";



// Wednesday, 2012/01/18 17:50:04.00
Text "''aaaaa ''";


// Wednesday, 2012/01/18 17:49:58.00
Text a = "''aaaaa ''";


// Wednesday, 2012/01/18 17:49:46.00
Text a = "'";


// Wednesday, 2012/01/18 17:49:40.00
Real a = "'";


// Wednesday, 2012/01/18 16:53:22.00
Text a = "a '''a''' ''a''";



// Tuesday, 2012/01/17 16:55:27.00
NameBlock subm = est::GetModel(?)::GetSubmodel(1);

// Tuesday, 2012/01/17 16:55:03.00
#Require MMS;

NameBlock est = MMS::Container::GetEstimation(1);



// Tuesday, 2012/01/17 16:53:44.00
#Require MMS;



// Saturday, 2012/01/14 22:07:25.00
Real MatMin( IndexRutas );

// Saturday, 2012/01/14 22:00:34.00
Set EvalSet( DistPorRutas, Set ( Set rinfo ) {
  WriteLn( "Procesando ruta " << rinfo[1] );
  Real n = Rows( rinfo[2] );
  If( n < 3, {
    Set [[ Real ruta = rinfo[1], Matrix Col(1) ]]
  }, {
    Set [[ Real ruta = rinfo[1],
           Matrix Rhclust::Run( rinfo[2], "ward", If(n<6,2,6) ) ]]
  } )
} );

// Saturday, 2012/01/14 21:56:22.00
Set EvalSet( DistPorRutas, Set ( Set rinfo ) {
  WriteLn( "Procesando ruta " << rinfo[1] );
  If( Rows( rinfo[2] ) < 3, {
    Set [[ Real ruta = rinfo[1], Matrix Col(1) ]]
  }, {
    Set [[ Real ruta = rinfo[1],
           Matrix Rhclust::Run( rinfo[2], "ward", 6 ) ]]
  } )
} );

// Saturday, 2012/01/14 21:54:41.00
Set EvalSet( DistPorRutas, Set ( Set rinfo ) {
  If( Rows( rinfo[2] ) < 3, {
    Set [[ Real ruta = rinfo[1], Matrix Col(1) ]]
  }, {
    Set [[ Real ruta = rinfo[1],
           Matrix Rhclust::Run( rinfo[2], "ward", 6 ) ]]
  } )
} );

// Saturday, 2012/01/14 21:41:30.00
Set Rhclust::Run( DistPorRutas[1][2], "ward", 6 );


// Saturday, 2012/01/14 21:40:59.00
Set Rhclust::Run( DistPorRutas[1][2], "ward", 6 );


// Saturday, 2012/01/14 21:40:03.00
Set Rhclust::Run( DistPorRutas[1][2], "ward", 6 );


// Saturday, 2012/01/14 21:39:30.00
Set Rhclust::Run( DistPorRutas[1][2], "ward", 6 );


// Saturday, 2012/01/14 21:36:25.00
Set Rhclust::Run( DistPorRutas[1][2], "ward", 6 );


// Saturday, 2012/01/14 21:35:45.00
Set Rhclust::Run( DistPorRutas[1][2], "ward", 6 );


// Saturday, 2012/01/14 21:33:58.00
Set Rhclust::Run( DistPorRutas[1][2], "ward", 6 );


// Saturday, 2012/01/14 21:30:30.00
Set Rhclust::Run( DistPorRutas[1][2], "ward", 6 );


// Saturday, 2012/01/14 21:29:45.00
Set Rhclust::Run( DistPorRutas[1][2], "ward", 6 );

// Saturday, 2012/01/14 21:29:06.00
Set Rhclust::Run( DistPorRutas[1][2], "ward", 6 );

// Saturday, 2012/01/14 21:28:57.00
Set Rhclust( DistPorRutas[1][2], "ward", 6 );


// Saturday, 2012/01/14 20:39:12.00
Matrix r_dist = SubCol( DistGraph, IndexSSCC );

// Saturday, 2012/01/14 20:38:49.00
Matrix r_graph = SubRow( DistGraph, [[ r ]] );

// Saturday, 2012/01/14 20:38:40.00
 Real r = IndexSSCC[ k ];

// Saturday, 2012/01/14 20:38:34.00
Real k = 1;

// Saturday, 2012/01/14 20:38:05.00
      k = 1;
      Real r = IndexSSCC[ k ];


// Saturday, 2012/01/14 20:23:57.00
#Require MatQuery;

Set distRuteros = { Include( "Mat_Ruta_ExpMed.oza" ) };


// Saturday, 2012/01/14 20:20:22.00
Matrix u = SubRow(Empleado_Matrix, MatSet( Tra( Sort( Empleado_Matrix, [[ 1 ]], True ) ) )[ 1 ] );

// Saturday, 2012/01/14 20:20:01.00
#Require MatQuery;

Matrix u = SubRow(Empleado_Matrix, MatSet( Tra( Sort( Empleado_Matrix, [[ 1 ]], True ) ) )[ 1 ] );
Set For( 1, Rows( u ), Real( Real k ) {
  Real uk = MatDat( u, k, 1 );
  Set sel = MatQuery::SelectRowsWithValue( Mat2VMat( Empleado_Matrix ), uk );
  Matrix submatDist = SubCol( SubRow( MatDist, sel ), sel );
  Set [[ Real rutero = uk, Matrix submatDist ]]
} );


// Saturday, 2012/01/14 20:19:38.00
Set For( 1, Rows( u ), Real( Real k ) {
  Real uk = MatDat( u, k, 1 );
  Set sel = MatQuery::SelectRowsWithValue( Mat2VMat( Empleado_Matrix ), uk );
  Matrix submatDist = SubCol( SubRow( MatDist, sel ), sel );
  Set [[ Real rutero = uk, Matrix submatDist ]]
} );

// Saturday, 2012/01/14 20:13:18.00
Matrix u = SubRow(Empleado_Matrix, MatSet( Tra( Sort( Empleado_Matrix, [[ 1 ]], True ) ) )[ 1 ] );


// Saturday, 2012/01/14 20:03:35.00
Set Include( "/tmp/Mat_Ruta_ExpMed.oza" );


// Friday, 2012/01/13 18:01:44.00
Matrix SubCol( dist0, [[12,13,14,15,16]] );


// Friday, 2012/01/13 17:59:51.00
Matrix SubCol( dist0, [[3,4,5,6]] );


// Friday, 2012/01/13 17:55:02.00
Matrix SubCol( dist1, [[3,4,5,6]] );


// Friday, 2012/01/13 17:53:56.00
Matrix SubCol( dist1, [[1,2,3]] );


// Friday, 2012/01/13 17:19:07.00
Set MatSet( Tra(index+1) )[1]

// Friday, 2012/01/13 17:17:51.00
Set MatSet( Tra(index) );

// Friday, 2012/01/13 17:17:27.00

Set MatSet( index );

// Friday, 2012/01/13 17:17:11.00
Matrix index = SSCC_RutaSSCC;

// Friday, 2012/01/13 17:15:07.00
Matrix SubRow( MatDist, [[1]])

// Friday, 2012/01/13 16:46:18.00
Set Include( "/tmp/Matrices_SSCC_Rutas.oza" );


// Friday, 2012/01/13 12:57:16.00
Matrix SubCol( a, [[1,1,1,2,2,3,4,4,4,4,5,5,5]] );

// Friday, 2012/01/13 12:56:46.00
Matrix SubCol( a, [[1,1]] );

// Friday, 2012/01/13 12:56:35.00
Matrix a = Row(1,2,3,4,5);

// Friday, 2012/01/13 12:43:13.00
#Require MMS;


// Friday, 2012/01/13 10:32:24.00
TkPieChart

// Friday, 2012/01/13 10:15:43.00
#Require TkPieChart;

// Friday, 2012/01/13 10:14:21.00
#Require TkPieChart;

// Friday, 2012/01/13 10:11:34.00
#Require TkPieChart;

// Friday, 2012/01/13 10:07:43.00
TkPieChart

// Friday, 2012/01/13 10:07:40.00
#Require TkPieChart;

// Friday, 2012/01/13 10:07:37.00
#Require TkPieChart;

// Thursday, 2012/01/12 15:06:42.00

Set est::GetParameters(?)

// Thursday, 2012/01/12 09:48:25.00
IntRand( 1, 1000000 );

// Thursday, 2012/01/12 09:48:25.00
IntRand( 1, 1000000 );

// Thursday, 2012/01/12 09:48:24.00
IntRand( 1, 1000000 );

// Thursday, 2012/01/12 09:48:23.00
IntRand( 1, 1000000 );

// Thursday, 2012/01/12 09:48:23.00
IntRand( 1, 1000000 );

// Thursday, 2012/01/12 09:48:20.00
IntRand( 1, 1000000 );

// Thursday, 2012/01/12 09:35:56.00
Real str::GetSetting( "mcmc.sampleLength");

// Thursday, 2012/01/12 09:35:11.00
Real str::GetSetting( "mcmc.length");

// Thursday, 2012/01/12 09:34:16.00
Real str::GetSetting( "mcmc.length");

// Thursday, 2012/01/12 09:28:52.00
NameBlock str::GetResults(?)::GetNativeResults(?);

// Thursday, 2012/01/12 09:27:08.00
NameBlock est::GetModel.Results(?)

// Thursday, 2012/01/12 09:26:42.00
NameBlock est::GetResults(?)

// Thursday, 2012/01/12 09:24:37.00

NameBlock str::GetResults(?)::GetNativeResults(?);

// Thursday, 2012/01/12 09:24:03.00

NameBlock str::GetResults(?);

// Thursday, 2012/01/12 09:22:13.00
Real str::SetSetting( "do.report", 1 );

// Thursday, 2012/01/12 09:22:02.00
Real str::GetSetting( "do.report" );

// Thursday, 2012/01/12 09:21:56.00

NameBlock str = MMS::Container::GetEstimation(1)::GetStrategy(?) 

// Thursday, 2012/01/12 09:21:33.00
NameBlock est = MMS::Container::GetEstimation(1)

// Thursday, 2012/01/12 09:21:07.00
Real MMS::Container::GetEstimation(1)::GetSetting( "do.report" );

// Thursday, 2012/01/12 09:19:02.00
MMS::Container::GetEstimation(1)::GetStrategy(?)

// Thursday, 2012/01/12 09:18:00.00
MMS

// Thursday, 2012/01/12 09:04:07.00
#Require MMS;


// Thursday, 2012/01/12 08:58:41.00
MMS::Container::GetEstimation(1)::GetStrategy(?)
    ::GetResults(?)::GetNativeResults(?)

// Thursday, 2012/01/12 08:49:25.00
#Require MMS;


// Friday, 2012/01/06 13:22:57.00
Anything TclChartSerie([[ SubSer(Rand(0, 1, C), y2001, y2002) ]], Empty);



// Friday, 2012/01/06 13:18:36.00
Anything TclChartSerie([[ SubSer(Rand(0, 1, C), y2001, y2002) ]], Empty);



// Thursday, 2012/01/05 17:24:27.00
Anything TclChartSerie([[ SubSer(Rand(0, 1, C), y2001, y2002) ]], Empty);



// Thursday, 2012/01/05 15:03:29.00
Serie ser = SubSer(Rand(0, 1, C), y2001, y2002);
Anything TclChartSerie([[ ser ]], Empty);



// Thursday, 2012/01/05 15:03:23.00
Serue ser = SubSer(Rand(0, 1, C), y2001, y2002);
Anything TclChartSerie([[ ser ]], Empty);



// Thursday, 2012/01/05 14:56:29.00
Serie SubSer(Rand(0, 1, C), y2001, y2002);

// Thursday, 2012/01/05 14:48:21.00
Anything TclChartSerie([[ SubSer(Rand(0, 1, C), y2001, y2002) ]], Empty);



// Wednesday, 2012/01/04 14:28:21.00
Real LoadMatrixAll("hclustcomplete", "Shipping");

// Wednesday, 2012/01/04 13:12:02.00
Real DBOpen(
  SeUrTr.PEXHEN_DBODBC,
  SeUrTr.PEXHEN_DBUser,
  SeUrTr.PEXHEN_DBPassword
);


// Wednesday, 2012/01/04 11:56:18.00

Text PathProject = GetAbsolutePath("../../../");
Text SeUrTr.PEXHEN_DBODBC="SeUrTrPEXHEN.Piloto";
Text SeUrTr.PEXHEN_DBUser="seurtrpexhen";
Text SeUrTr.PEXHEN_DBPassword ="seu!115.";
Real DBOpen(
  SeUrTr.PEXHEN_DBODBC,
  SeUrTr.PEXHEN_DBUser,
  SeUrTr.PEXHEN_DBPassword
);

// Wednesday, 2012/01/04 11:55:56.00
Text PathProject = GetAbsolutePath("../../../");

// Wednesday, 2012/01/04 11:55:31.00
Text PathProject=GetAbsolutePath("../../../") + "/";

// Wednesday, 2012/01/04 11:52:06.00
Real DBClose(SeUrTr.PEXHEN_DBODBC);

// Wednesday, 2012/01/04 11:51:56.00
Text SeUrTr.PEXHEN_DBODBC="SeUrTrPEXHEN.Piloto";
Text SeUrTr.PEXHEN_DBUser="seurtrpexhen";
Text SeUrTr.PEXHEN_DBPassword ="seu!115.";
Real DBOpen(
  SeUrTr.PEXHEN_DBODBC,
  SeUrTr.PEXHEN_DBUser,
  SeUrTr.PEXHEN_DBPassword
);


// Wednesday, 2012/01/04 10:34:02.00
Matrix SubRow( mm1, [[ 3 ]] );

// Wednesday, 2012/01/04 10:33:30.00
Matrix mm = MatReadFile( "/tmp/route_constraint.bbm" );
Matrix mm1 = IfMat( mm, 0, 1000 );
Matrix MatWriteFile( "/tmp/route_constraint.bbm", mm1 );


// Wednesday, 2012/01/04 10:31:33.00
Matrix mm = MatReadFile( "/tmp/route_constraint.bbm" );
Matrix IfMat( mm, 0, 1000 );
Matrix MatWriteFile( "/tmp/route_constraint.bbm", mm );


// Wednesday, 2012/01/04 09:48:49.00
Matrix IfMat( Rand( 10, 1, 0, 0 ) | Rand( 10, 1, 1, 1 ), -1, 1 )


// Wednesday, 2012/01/04 09:42:37.00
Matrix MatWriteFile( "/tmp/rout_constrint.bbm", route_constraint );

// Wednesday, 2012/01/04 09:40:28.00
Matrix route_constraint = IfMat( SSCC1_SSCC2_Rutas, Rand( 655, 655, 2, 2 ), Rand( 655, 655, 0, 0 ) );

// Wednesday, 2012/01/04 09:39:57.00
Matrix route_constraint = IfMat( SSCC1_SSCC2_Rutas, Rand( 2, 2, 655, 655 ), Rand( 0, 0, 655, 655 ) );


// Tuesday, 2012/01/03 20:41:00.00
MMS

// Tuesday, 2012/01/03 20:40:32.00
#Require MMS;



// Tuesday, 2012/01/03 18:48:29.00
Anything TclChartSerie([[ SubSer(Rand(0, 1, C), y2001, y2002) ]], Empty);



// Tuesday, 2012/01/03 13:56:22.00
WriteLn( "hola" );


// Tuesday, 2012/01/03 13:56:01.00
assas


// Tuesday, 2012/01/03 11:19:02.00
TolIpopt.3.1

// Tuesday, 2012/01/03 11:17:13.00
Real TolPackage::Client::RemoteUpdateVersSyncInfo(True);


// Tuesday, 2012/01/03 10:59:52.00
Set {Include("/home/jsperez/.tol/TolPackage/1.1/Client/MmsReports.1.6/info.oza")}

// Tuesday, 2012/01/03 10:57:58.00
Set {Include("/home/jsperez/.tol/TolPackage/1.1/Client/BysPrior.2.1/info.oza")}

// Tuesday, 2012/01/03 10:50:37.00
TolPackage::Client

// Tuesday, 2012/01/03 10:47:34.00
    Real TolPackage::Client::RemoteUpdateVersSyncInfo(True);



// Monday, 2012/01/02 21:50:07.00
MMS

// Monday, 2012/01/02 21:50:01.00
#Require MMS


// Monday, 2012/01/02 11:25:07.00
MMS

// Monday, 2012/01/02 11:24:31.00
#Require MMS;


// Saturday, 2011/12/31 01:40:25.00
DateDif(Diario,y2011m11d17h11i03s00.000,y2011m06d16h16i56s00.000);

// Saturday, 2011/12/31 01:40:13.00
DateDif(D(0),y2011m11d17h11i03s00.000,y2011m06d16h16i56s00.000);

// Saturday, 2011/12/31 01:39:06.00
DateDif(S(0),y2011m11d17h11i03s00.000,y2011m06d16h16i56s00.000);

// Saturday, 2011/12/31 01:38:16.00
S(0);

// Saturday, 2011/12/31 01:25:07.00
Real TolPackage::Client::RemoteUpdateVersSyncInfo(?);

// Saturday, 2011/12/31 01:15:16.00
Set TolPackage::Client::LocalInfo("BysPrior.2.1");

// Friday, 2011/12/30 23:42:42.00
TolConfigManager

// Friday, 2011/12/30 23:40:30.00
Set Tcl_Eval( "TolConfigGUI::Show" );

// Friday, 2011/12/30 23:12:09.00
Real TolPackage::Client::DownloadCompatibleDeepDependencies( "/tmp/kk/", 1, TolVersionId, [["MMS"]] );

// Friday, 2011/12/30 22:54:59.00
TolPackage

// Friday, 2011/12/30 21:51:25.00
Set Tcl_Eval( "TolConfigGUI::Show" );


// Friday, 2011/12/30 21:40:12.00
Set Tcl_Eval( "TolConfigGUI::Show" );


// Friday, 2011/12/30 21:37:56.00
Set Tcl_Eval( "TolConfigGUI::Show" );


// Friday, 2011/12/30 20:19:18.00
TolPackage

// Thursday, 2011/12/29 23:16:23.00
Select( kk, Real( Anything a ) { "NameBlock" == Grammar( a ) } )

// Thursday, 2011/12/29 23:16:00.00
Select( kk, Real( Anything a ) { EQ( Text "NameBlock", Grammar( a ) ) } )

// Thursday, 2011/12/29 23:15:48.00
Select( kk, Real( Anything a ) { EQ( "NameBlock", Grammar( a ) ) } )

// Thursday, 2011/12/29 23:15:45.00
Set kk = NameBlockToSet( TolConfigManager::Config );

// Thursday, 2011/12/29 23:06:43.00
NameBlockToSet( TolConfigManager::Config )


// Thursday, 2011/12/29 23:05:02.00
TolConfigManager::Config


// Thursday, 2011/12/29 23:04:52.00
TolConfigManager


// Tuesday, 2011/12/27 19:57:30.00
TolPackage::Client::LocalExportPackage("DecoTools.1.8", "/tmp/");


// Tuesday, 2011/12/27 19:57:25.00
Real TolPackage::Client::LocalExportPackage("DecoTools.1.8", "/tmp/");


// Tuesday, 2011/12/27 19:57:03.00
Real TolPackage::Client::LocalExportPackage("DecoTools.1.8", "/tmp");


// Tuesday, 2011/12/27 19:55:27.00
TolPackage::Client


// Tuesday, 2011/12/27 12:38:28.00
#Require BysPrior;

// Tuesday, 2011/12/27 12:38:01.00
Real TolPackage::Client::LocalInstallPackage( "/tmp/BysPrior.2.1.zip" );

// Tuesday, 2011/12/27 12:37:48.00
Real LocalInstallPackage( "/tmp/BysPrior.2.1.zip" );

// Tuesday, 2011/12/27 12:36:09.00
TolPackage::Client

// Tuesday, 2011/12/27 12:32:36.00
Text pkg.ver = "BysPrior.2.1";
Text dir.dest = "/tmp/";

Text dir.loc = ReplaceSlash(TolPackage::Client::_.localRoot);
Text pkg.loc = dir.loc+pkg.ver;
Text zip.loc = pkg.loc+".zip";
Text zip.dest = dir.dest+pkg.ver+".zip";

//Ensures that local.oza is locally created
Real TolPackage::Client::LocalInfo(pkg.ver);

//Compacts the package as a ZIP file
Real PackArchive::PackFull("ZipArchive", pkg.loc, False);

//Moves the ZIP file to destination directory
Real OSFilMove(zip.loc, zip.dest);


// Monday, 2011/12/26 20:30:14.00
PackArchive;

// Monday, 2011/12/26 13:24:09.00
TolPackage;

// Monday, 2011/12/26 13:12:39.00


    Set { 
      [[ 
        Real checkTOL = TolConfigManager::Config::Upgrading::TolVersion::CheckAllowed;
        Real localPKG = TolConfigManager::Config::Upgrading::TolPackage::LocalOnly
       ]]
    }



// Monday, 2011/12/26 13:06:17.00
TolConfigManager


// Thursday, 2011/12/22 23:06:19.00
Set TolPackage::Client::GetDeepDependencies.all( [[ "MMS.0.6044", "ExtLib.1.2",
"ExtLib.1.6",
"ExtLib.1.7"
 ]] );


// Thursday, 2011/12/22 22:56:09.00
Set TolPackage::Client::GetDeepDependencies.all( [[ "MMS.0.6044" ]] );


// Wednesday, 2011/12/21 21:51:23.00
  #Require GuiTools;
  
  Text GuiTools::WaterfallChart
  (
    SetOfReal( 40, 10, 5, 1, 0.5, -1, -3, -7 ),
    SetOfText( "Baaaaassse1", "Iiiiiiii1", "Iadafdsfdsfsd2", "I3", "I4", "Dasadasdasdasd1", "D2", "D3", "Baaaaaaaaaaaa2" ),
    [[ "-title", "Waterfall Sample: from B1 to B2" ]]
  );



// Wednesday, 2011/12/21 21:51:12.00
  #Require GuiTools;
  
  Text GuiTools::WaterfallChart
  (
    SetOfReal( 40, 10, 5, 1, 0.5, -1, -3, -7 ),
    SetOfText( "Baaaaassse1", "Iiiiiiii1", "I2", "I3", "I4", "Dasadasdasdasd1", "D2", "D3", "Baaaaaaaaaaaa2" ),
    [[ "-title", "Waterfall Sample: from B1 to B2" ]]
  );



// Wednesday, 2011/12/21 21:50:59.00
  #Require GuiTools;
  
  Text GuiTools::WaterfallChart
  (
    SetOfReal( 40, 10, 5, 1, 0.5, -1, -3, -7 ),
    SetOfText( "Baaaaassse1", "Iiiiiiii1", "I2", "I3", "I4", "D1", "D2", "D3", "Baaaaaaaaaaaa2" ),
    [[ "-title", "Waterfall Sample: from B1 to B2" ]]
  );



// Wednesday, 2011/12/21 21:50:32.00
  #Require GuiTools;
  
  Text GuiTools::WaterfallChart
  (
    SetOfReal( 40, 10, 5, 1, 0.5, -1, -3, -7 ),
    SetOfText( "Baaaaassse1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2" ),
    [[ "-title", "Waterfall Sample: from B1 to B2" ]]
  );



// Wednesday, 2011/12/21 21:43:45.00
  #Require GuiTools;
  
  Text GuiTools::WaterfallChart
  (
    SetOfReal( 40, 10, 5, 1, 0.5, -1, -3, -7 ),
    SetOfText( "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2" ),
    [[ "-title", "Waterfall Sample: from B1 to B2" ]]
  );



// Wednesday, 2011/12/21 21:40:12.00
  Text GuiTools::WaterfallChart
  (
    SetOfReal( 40, 10, 5, 1, 0.5, -1, -3, -7 ),
    SetOfText( "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2" )
  );


// Wednesday, 2011/12/21 21:39:10.00
  Text GuiTools::WaterfallChart
  (
    SetOfReal( 40, 10, 5, 1, 0.5, -1, -3, -7 ),
    SetOfText( "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2" )
  );


// Wednesday, 2011/12/21 21:39:06.00
#Require GuiTools;

// Wednesday, 2011/12/21 21:38:19.00
  Text GuiTools::WaterfallChart
  (
    SetOfReal( 40, 10, 5, 1, 0.5, -1, -3, -7 ),
    SetOfText( "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2" )
  );



// Wednesday, 2011/12/21 18:38:15.00
Anything obj = GetObjectFromAddress( "A22A718:0:8E72568:0:8A90DA8:0:8:4:4" );

// Wednesday, 2011/12/21 18:37:58.00

Anything obj = GetObjectFromAddress( "A22A718:0:8E72568:0:8A90DA8:0:8:4:4" );

// Wednesday, 2011/12/21 18:33:22.00
#Require MMS;
MMS


// Wednesday, 2011/12/21 18:33:16.00
#Require MMS;



// Tuesday, 2011/12/20 16:40:39.00
Text StructName( BoxCox00 )

// Tuesday, 2011/12/20 16:39:46.00
Text StructName( DiagnosticsBounds[1] )

// Tuesday, 2011/12/20 16:39:08.00
Text StructName( DiagnosticsBounds )


// Saturday, 2011/12/17 01:42:18.00
Real If( !0, 1, 0 )


// Friday, 2011/12/16 17:44:19.00
NameBlock ToltclLinux32_2_0_2 = [[
Text _.autodoc.name = "ToltclLinux32_2_0_2"
]];

// Friday, 2011/12/16 17:44:09.00
NameBlock ToltclLinux32_2_0_2 [[
Text _.autodoc.name = "ToltclLinux32_2_0_2"
]];



// Friday, 2011/12/16 17:02:13.00
ReplaceTable( "2.0.2", [[ [[ ".","_" ]] ]]  );

// Friday, 2011/12/16 17:01:10.00
Code (Text Replace)


// Friday, 2011/12/16 17:00:59.00
Code Replace


// Friday, 2011/12/16 16:48:23.00
Code Case


// Wednesday, 2011/12/14 13:27:58.00
Set Ois.Load( TolPackage::_.localRoot + "Client/PackSyncInfo.oza" )[1];

// Wednesday, 2011/12/14 13:01:52.00
Set Ois.Load( TolPackage::_.localRoot + "Client/VersSyncInfo.oza" );

// Wednesday, 2011/12/14 13:01:37.00
Set Ois.Load( TolPackage::_.localRoot + "Client/VerSyncInfo.oza" );

// Wednesday, 2011/12/14 13:01:21.00
Set Ois.Load( TolPackage::_.localRoot + "Client/PackSyncInfo.oza" );


// Monday, 2011/12/12 18:03:02.00
#Require MMS;

// Monday, 2011/12/12 17:42:00.00
Serie _SetSer(datos, fechas[1], fechado);

// Monday, 2011/12/12 17:41:41.00
Serie _SetSer(datos, fechas[1], fechado);

// Monday, 2011/12/12 17:41:38.00
Serie _SetSer (Set datos, Date ini, TimeSet fechado)
{
   Matrix coef  = GetNumeric(datos);
   Serie MatSerSet(coef,fechado,ini)[1]
};


// Monday, 2011/12/12 17:36:35.00
Serie s[1]

// Monday, 2011/12/12 17:36:31.00
Set s = MatSerSet(coef,fechado,ini);

// Monday, 2011/12/12 17:30:27.00
Serie pol:SubSer( Pulse(ini,fechado), ini, LastDay );

// Monday, 2011/12/12 17:29:36.00
Serie SubSer( Pulse(ini,fechado), ini, LastDay );

// Monday, 2011/12/12 17:28:59.00
Date LastDay = Succ(ini,fechado,Card(datos)-1);

// Monday, 2011/12/12 17:28:10.00
Pulse(ini,fechado);

// Monday, 2011/12/12 17:27:48.00
  Serie result = pol:Pulse(ini,fechado);

// Monday, 2011/12/12 17:26:39.00
Date ini = fechas[1];

// Monday, 2011/12/12 17:26:17.00
//Text WriteLn("Tiempo 3 "+Time); 
  Matrix coef  = GetNumeric(datos);
//Text WriteLn("Tiempo 4. GetNumeric SetSer "+Time); 
  Polyn pol    = MatPol(coef);
//Text WriteLn("Tiempo 5. MatPol SetSer "+Time); 
  Serie result = pol:Pulse(ini,fechado);
//Text WriteLn("Tiempo 6. pol: "+Time); 
  Date LastDay = Succ(ini,fechado,Card(datos)-1);
//Text WriteLn("Tiempo 7 "+Time); 
  SubSer(result,ini,LastDay)


// Monday, 2011/12/12 17:24:19.00
Code SetSer

// Monday, 2011/12/12 17:23:56.00
Set datos= [[1, 2, 3, 4, 5, 6, 7, 8 ,9, 10, 11, 12]];
Serie ser= SetSer(datos, fechas[1], fechado);

// Monday, 2011/12/12 17:22:39.00
Set fechas= [[y2010m01d01, y2010m04d01, y2010m07d01, y2010m10d01, y2011m01d01, y2011m04d01, y2011m07d01, y2011m10d01, y2012m01d01, y2012m04d01, y2012m07d01, y2012m10d01]];
TimeSet fechado= DatesOfSet(fechas);


// Monday, 2011/12/12 13:44:44.00
MMS;

// Monday, 2011/12/12 13:44:34.00
#Require MMS


// Saturday, 2011/12/10 11:15:09.00
Text oza = TolPackage::_.localRoot + "Client/" + "DecoTools.1.8/DecoTools.1.8.oza";

Set Ois.Load( oza );


// Saturday, 2011/12/10 01:43:50.00
Set Include( "/home/jsperez/.tol/TolPackage/1.1/Client/VersSyncInfo.oza" );


// Saturday, 2011/12/10 01:41:53.00
Set Include( "/home/jsperez/.tol/TolPackage/1.1/Client/VersSyncInfo.oza");

// Saturday, 2011/12/10 00:42:23.00
Set { Include( "/home/jsperez/.tol/TolPackage/1.1/Client/DecoTools.1.6/DecoTools.1.6.oza" ) }



// Saturday, 2011/12/10 00:38:48.00
Set { Include( "/home/jsperez/.tol/TolPackage/1.1/Client/DecoTools.1.6/DecoTools.1.6.oza" ) }



// Saturday, 2011/12/10 00:38:41.00
Set { Include( "/home/jsperez/.tol/TolPackage/1.1/Client/DecoTools.1.6/DecoTools.1.6.oza" ); }



// Friday, 2011/12/09 23:19:42.00
   If( Grammar( oza[1] ) == "NameBlock", {
      NameBlock pkg = oza[ 1 ];
      Set If( And( ObjectExist( "Text", "pkg::_.autodoc.name" ),
                   ObjectExist( "Text", "pkg::_.autodoc.brief" ),
                   ObjectExist( "Text", "pkg::_.autodoc.description" ),
                   ObjectExist( "Text", "pkg::_.autodoc.url" ),
                   ObjectExist( "Real", "pkg::_.autodoc.version.high" ),
                   ObjectExist( "Real", "pkg::_.autodoc.version.low"),
                   ObjectExist( "Set",  "pkg::_.autodoc.authors" ),
                   ObjectExist( "Text", "pkg::_.autodoc.versionControl" ),
                   ObjectExist( "Text", "pkg::_.autodoc.minTolVersion" ) ),
              Set [[ Text name           = pkg::_.autodoc.name,
                     Text brief          = pkg::_.autodoc.brief,
                     Text description    = pkg::_.autodoc.description,
                     Text url            = pkg::_.autodoc.url,
                     Real version.high   = pkg::_.autodoc.version.high,
                     Real version.low    = pkg::_.autodoc.version.low,
                     Set authors         = pkg::_.autodoc.authors,
                     Text versionControl = pkg::_.autodoc.versionControl,
                     Text minTolVersion  = pkg::_.autodoc.minTolVersion,
                     Text maxTolVersion  = If( ObjectExist( "Text", "pkg::_.autodoc.maxTolVersion" ),
                                               pkg::_.autodoc.axTolVersion, "" ) ]],
              Copy( Empty ) ) }, Copy( Empty ) )


// Friday, 2011/12/09 23:19:24.00
      NameBlock pkg = oza[ 1 ];

// Friday, 2011/12/09 22:51:09.00
    Set oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" );



// Friday, 2011/12/09 20:33:30.00

    Set {
      Set _oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" );
      If( Or( 1, Grammar( _oza[1] ) == "NameBlock",
               ObjectExist( "Text", "(_oza[1])::_.autodoc.name" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.brief" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.description" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.url" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.high" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.low"),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.authors" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.versionControl" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.minTolVersion" ) ),
{
      NameBlock oza = _oza[1];
      Set [[ Text name           = oza::_.autodoc.name,
             Text brief          = oza::_.autodoc.brief,
             Text description    = oza::_.autodoc.description,
             Text url            = oza::_.autodoc.url,
             Real version.high   = oza::_.autodoc.version.high,
             Real version.low    = oza::_.autodoc.version.low,
//             Text authors        = oza::_.autodoc.author,
             Text versionControl = oza::_.autodoc.versionControl/*,
             Text minTolVersion  = oza::_.autodoc.minTolVersion,
             Text maxTolVersion  = If( ObjectExist( "Text", "oza::_.autodoc.minTolVersion" ),
                                       _.autodoc.minTolVersion,
                                       "" )*/ ]]}, Copy( Empty ) )
    }



// Friday, 2011/12/09 20:33:05.00

    Set {
      Set _oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" );
      If( Or( 1, Grammar( _oza[1] ) == "NameBlock",
               ObjectExist( "Text", "(_oza[1])::_.autodoc.name" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.brief" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.description" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.url" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.high" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.low"),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.authors" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.versionControl" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.minTolVersion" ) ),
{
      NameBlock oza = _oza[1];
      Set [[ Text name           = oza::_.autodoc.name,
             Text brief          = oza::_.autodoc.brief,
             Text description    = oza::_.autodoc.description,
             Text url            = oza::_.autodoc.url,
             Real version.high   = oza::_.autodoc.version.high,
             Real version.low    = oza::_.autodoc.version.low,
//             Text authors        = oza::_.autodoc.author,
             Text versionControl = oza::_.autodoc.versionControl,
             Text minTolVersion  = oza::_.autodoc.minTolVersion,
             Text maxTolVersion  = If( ObjectExist( "Text", "oza::_.autodoc.minTolVersion" ),
                                       _.autodoc.minTolVersion,
                                       "" ) ]]}, Copy( Empty ) )
    }



// Friday, 2011/12/09 20:32:29.00

    Set {
      Set _oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" );
      If( Or( 1, Grammar( _oza[1] ) == "NameBlock",
               ObjectExist( "Text", "(_oza[1])::_.autodoc.name" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.brief" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.description" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.url" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.high" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.low"),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.authors" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.versionControl" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.minTolVersion" ) ),
{
      NameBlock oza = _oza[1];
      Set [[ Text name           = oza::_.autodoc.name,
             Text brief          = oza::_.autodoc.brief,
             Text description    = oza::_.autodoc.description,
             Text url            = oza::_.autodoc.url,
             Real version.high   = oza::_.autodoc.version.high,
             Real version.low    = oza::_.autodoc.version.low,
//             Text authors        = oza::_.autodoc.author,
             Text versionControl = oza::_.autodoc.versionControl,
             Real minTolVersion  = oza::_.autodoc.minTolVersion,
             Real maxTolVersion  = If( ObjectExist( "Text", "oza::_.autodoc.minTolVersion" ),
                                       _.autodoc.minTolVersion,
                                       "" ) ]]}, Copy( Empty ) )
    }



// Friday, 2011/12/09 20:32:10.00

    Set {
      Set _oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" );
      If( Or( 1, Grammar( _oza[1] ) == "NameBlock",
               ObjectExist( "Text", "(_oza[1])::_.autodoc.name" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.brief" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.description" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.url" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.high" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.low"),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.authors" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.versionControl" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.minTolVersion" ) ),
{
      NameBlock oza = _oza[1];
      Set [[ Text name           = oza::_.autodoc.name,
             Text brief          = oza::_.autodoc.brief,
             Text description    = oza::_.autodoc.description,
             Text url            = oza::_.autodoc.url,
             Real version.high   = oza::_.autodoc.version.high,
             Real version.low    = oza::_.autodoc.version.low,
//             Text authors        = oza::_.autodoc.author,
             Text versionControl = oza::_.autodoc.versionControl,
             Text minTolVersion  = oza::_.autodoc.minTolVersion,
             Text maxTolVersion  = If( ObjectExist( "Text", "oza::_.autodoc.minTolVersion" ),
                                       _.autodoc.minTolVersion,
                                       "" ) ]]}, Copy( Empty ) )
    }



// Friday, 2011/12/09 20:31:55.00

    Set {
      Set _oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" );
      If( Or( 1, Grammar( _oza[1] ) == "NameBlock",
               ObjectExist( "Text", "(_oza[1])::_.autodoc.name" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.brief" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.description" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.url" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.high" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.low"),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.authors" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.versionControl" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.minTolVersion" ) ),
{
      NameBlock oza = _oza[1];
      Set [[ Text name           = oza::_.autodoc.name,
             Text brief          = oza::_.autodoc.brief,
             Text description    = oza::_.autodoc.description,
             Text url            = oza::_.autodoc.url,
             Real version.high   = oza::_.autodoc.version.high,
             Real version.low    = oza::_.autodoc.version.low,
//             Text authors        = oza::_.autodoc.author,
             Text versionControl = oza::_.autdoc.versionControl,
             Text minTolVersion  = oza::_.autodoc.minTolVersion,
             Text maxTolVersion  = If( ObjectExist( "Text", "oza::_.autodoc.minTolVersion" ),
                                       _.autodoc.minTolVersion,
                                       "" ) ]]}, Copy( Empty ) )
    }



// Friday, 2011/12/09 20:31:35.00

    Set {
      Set _oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" );
      If( Or( 1, Grammar( _oza[1] ) == "NameBlock",
               ObjectExist( "Text", "(_oza[1])::_.autodoc.name" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.brief" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.description" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.url" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.high" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.low"),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.authors" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.versionControl" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.minTolVersion" ) ),
{
      NameBlock oza = _oza[1];
      Set [[ Text name           = oza::_.autodoc.name,
             Text brief          = oza::_.autodoc.brief,
             Text description    = oza::_.autodoc.description,
             Text url            = oza::_.autodoc.url,
             Real version.high   = oza::_.autodoc.version.high,
             Real version.low    = oza::_.autodoc.version.low,
             Text authors        = oza::_.autodoc.author,
             Text versionControl = oza::_.autdoc.versionControl,
             Text minTolVersion  = oza::_.autodoc.minTolVersion,
             Text maxTolVersion  = If( ObjectExist( "Text", "oza::_.autodoc.minTolVersion" ),
                                       _.autodoc.minTolVersion,
                                       "" ) ]]}, Copy( Empty ) )
    }



// Friday, 2011/12/09 20:31:16.00

    Set {
      Set _oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" );
      If( Or( 1, Grammar( _oza[1] ) == "NameBlock",
               ObjectExist( "Text", "(_oza[1])::_.autodoc.name" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.brief" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.description" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.url" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.high" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.low"),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.authors" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.versionControl" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.minTolVersion" ) ),
{
      NameBlock oza = _oza[1];
      Set [[ Text name           = oza::_.autodoc.name,
             Text brief          = oza::_.autodoc.brief,
             Text description    = oza::_.autodoc.description,
             Text url            = oza::_.autodoc.url,
             Real version.high   = oza::_.autodoc.version.high,
             Real version.low    = oza::_.autodoc.version.low,
             Text authors        = oza::_.autodoc.authors,
             Text versionControl = oza::_.autdoc.versionControl,
             Text minTolVersion  = oza::_.autodoc.minTolVersion,
             Text maxTolVersion  = If( ObjectExist( "Text", "oza::_.autodoc.minTolVersion" ),
                                       _.autodoc.minTolVersion,
                                       "" ) ]]}, Copy( Empty ) )
    }



// Friday, 2011/12/09 20:31:02.00

    Set {
      Set _oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" );
      If( And( 1, Grammar( _oza[1] ) == "NameBlock",
               ObjectExist( "Text", "(_oza[1])::_.autodoc.name" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.brief" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.description" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.url" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.high" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.low"),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.authors" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.versionControl" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.minTolVersion" ) ),
{
      NameBlock oza = _oza[1];
      Set [[ Text name           = oza::_.autodoc.name,
             Text brief          = oza::_.autodoc.brief,
             Text description    = oza::_.autodoc.description,
             Text url            = oza::_.autodoc.url,
             Real version.high   = oza::_.autodoc.version.high,
             Real version.low    = oza::_.autodoc.version.low,
             Text authors        = oza::_.autodoc.authors,
             Text versionControl = oza::_.autdoc.versionControl,
             Text minTolVersion  = oza::_.autodoc.minTolVersion,
             Text maxTolVersion  = If( ObjectExist( "Text", "oza::_.autodoc.minTolVersion" ),
                                       _.autodoc.minTolVersion,
                                       "" ) ]]}, Copy( Empty ) )
    }



// Friday, 2011/12/09 20:30:36.00

    Set {
      Set _oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" );
      If( And( Grammar( _oza[1] ) == "NameBlock",
               ObjectExist( "Text", "(_oza[1])::_.autodoc.name" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.brief" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.description" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.url" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.high" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.low"),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.authors" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.versionControl" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.minTolVersion" ) ),
{
      NameBlock oza = _oza[1];
      Set [[ Text name           = oza::_.autodoc.name,
             Text brief          = oza::_.autodoc.brief,
             Text description    = oza::_.autodoc.description,
             Text url            = oza::_.autodoc.url,
             Real version.high   = oza::_.autodoc.version.high,
             Real version.low    = oza::_.autodoc.version.low,
             Text authors        = oza::_.autodoc.authors,
             Text versionControl = oza::_.autdoc.versionControl,
             Text minTolVersion  = oza::_.autodoc.minTolVersion,
             Text maxTolVersion  = If( ObjectExist( "Text", "oza::_.autodoc.minTolVersion" ),
                                       _.autodoc.minTolVersion,
                                       "" ) ]]}, Copy( Empty ) )
    }



// Friday, 2011/12/09 20:30:21.00

    Set {
      Set _oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" );
      If( And( Grammar( _oza[1] ) == "NameBlock",
               ObjectExist( "Text", "(_oza[1])::_.autodoc.name" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.brief" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.description" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.url" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.high" ),
               ObjectExist( "Real", "(_oza[1])::_.autodoc.version.low"),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.authors" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.versionControl" ),
               ObjectExist( "Text", "(_oza[1])::_.autodoc.minTolVersion" ) ),
{
      NameBlock oza = _oza[1];
      Set [[ Text name           = oza::_.autodoc.name,
             Text brief          = oza::_.autodoc.brief,
             Text description    = oza::_.autodoc.description,
             Text url            = oza::_.autodoc.url,
             Real version.high   = oza::_.autodoc.version.high,
             Real version.low    = oza::_.autodoc.version.low,
             Text authors        = oza::_.autodoc.authors,
             Text versionControl = oza::_.autdoc.versionControl,
             Text minTolVersion  = oza::_.autodoc.minTolVersion,
             Text maxTolVersion  = If( ObjectExist( "Text", "oza::_.autodoc.minTolVersion" ),
                                       _.autodoc.minTolVersion,
                                       "" ) ]]}, Copy( Empty ) )
    }



// Friday, 2011/12/09 20:28:27.00

    Set {
      Set _oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" );
      If( And( Grammar( _oza[1] ) == "NameBlock",
               ObjectExist( "Text", (_oza[1])::_.autodoc.name ),
               ObjectExist( "Text", (_oza[1])::_.autodoc.brief ),
               ObjectExist( "Text", (_oza[1])::_.autodoc.description ),
               ObjectExist( "Text", (_oza[1])::_.autodoc.url ),
               ObjectExist( "Real", (_oza[1])::_.autodoc.version.high ),
               ObjectExist( "Real", (_oza[1])::_.autodoc.version.low),
               ObjectExist( "Text", (_oza[1])::_.autodoc.authors ),
               ObjectExist( "Text", (_oza[1])::_.autodoc.versionControl ),
               ObjectExist( "Text", (_oza[1])::_.autodoc.minTolVersion ) ),
{
      NameBlock oza = _oza[1];
      Set [[ Text name           = oza::_.autodoc.name,
             Text brief          = oza::_.autodoc.brief,
             Text description    = oza::_.autodoc.description,
             Text url            = oza::_.autodoc.url,
             Real version.high   = oza::_.autodoc.version.high,
             Real version.low    = oza::_.autodoc.version.low,
             Text authors        = oza::_.autodoc.authors,
             Text versionControl = oza::_.autdoc.versionControl,
             Text minTolVersion  = oza::_.autodoc.minTolVersion,
             Text maxTolVersion  = If( ObjectExist( "Text", oza::_.autodoc.minTolVersion ),
                                       _.autodoc.minTolVersion,
                                       "" ) ]]}, Copy( Empty ) )
    }



// Friday, 2011/12/09 20:27:45.00

    Set {
      Set _oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" );
      If( And( Grammar( _oza[1] ) == "NameBlock",
               ObjectExist( "Text", (_oza[1])::_.autodoc.name ),
               ObjectExist( "Text", (_oza[1])::_.autodoc.brief ),
               ObjectExist( "Text", (_oza[1])::_.autodoc.description ),
               ObjectExist( "Text", (_oza[1])::_.autodoc.url ),
               ObjectExist( "Real", (_oza[1])::_.autodoc.version.high ),
               ObjectExist( "Real", (_oza[1])::_.autodoc.version.low),
               ObjectExist( "Text", (_oza[1])::_.autodoc.authors ),
               ObjectExist( "Text", (_oza[1])::_.autodoc.versionControl ),
               ObjectExist( "Text", (_oza[1])::_.autodoc.minTolVersion ) ),
{
      NameBlock oza = _oza[1];
      Set [[ Text name           = oza::_.autodoc.name,
             Text brief          = oza::_.autodoc.brief,
             Text description    = oza::_.autodoc.description,
             Text url            = oza::_.autodoc.url,
             Real version.high   = oza::_.autodoc.version.high,
             Real version.low    = oza::_.autodoc.version.low,
             Text authors        = oza::_.autodoc.authors,
             Text versionControl = oza::_.autdoc.versionControl,
             Text minTolVersion  = oza::_.autodoc.minTolVersion,
             Text maxTolVersion  = If( ObjectExist( "Text", oza::_.autodoc.minTolVersion ),
                                       _.autodoc.minTolVersion,
                                       "" ) ]]}, Copy( Empty ) )
    }



// Friday, 2011/12/09 20:26:18.00

    Set {
      Set _oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" );
      If( And( Grammar( _oza[1] ) == "NameBlock",
               ObjectExists( "Text", (_oza[1])::_.autodoc.name ),
               ObjectExists( "Text", (_oza[1])::_.autodoc.brief ),
               ObjectExists( "Text", (_oza[1])::_.autodoc.description ),
               ObjectExists( "Text", (_oza[1])::_.autodoc.url ),
               ObjectExists( "Real", (_oza[1])::_.autodoc.version.high ),
               ObjectExists( "Real", (_oza[1])::_.autodoc.version.low),
               ObjectExists( "Text", (_oza[1])::_.autodoc.authors ),
               ObjectExists( "Text", (_oza[1])::_.autodoc.versionControl ),
               ObjectExists( "Text", (_oza[1])::_.autodoc.minTolVersion ) ),
{
      NameBlock oza = _oza[1];
      Set [[ Text name           = oza::_.autodoc.name,
             Text brief          = oza::_.autodoc.brief,
             Text description    = oza::_.autodoc.description,
             Text url            = oza::_.autodoc.url,
             Real version.high   = oza::_.autodoc.version.high,
             Real version.low    = oza::_.autodoc.version.low,
             Text authors        = oza::_.autodoc.authors,
             Text versionControl = oza::_.autdoc.versionControl,
             Text minTolVersion  = oza::_.autodoc.minTolVersion,
             Text maxTolVersion  = If( ObjectExists( "Text", oza::_.autodoc.minTolVersion ),
                                       _.autodoc.minTolVersion,
                                       "" ) ]]}, Copy( Empty ) )
    }



// Friday, 2011/12/09 20:25:57.00

    Set {
      Set _oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" );
      If( And( Grammar( _oza[1] ) == "NameBlock",
               ObjectExists( "Text", (_oza[1])::_.autodoc.name ),
               ObjectExists( "Text", (_oza[1])::_.autodoc.brief ),
               ObjectExists( "Text", (_oza[1])::_.autodoc.description ),
               ObjectExists( "Text", (_oza[1])::_.autodoc.url ),
               ObjectExists( "Real", (_oza[1])::_.autodoc.version.high ),
               ObjectExists( "Real", (_oza[1])::_.autodoc.version.low),
               ObjectExists( "Text", (_oza[1])::_.autodoc.authors ),
               ObjectExists( "Text", (_oza[1])::_.autodoc.versionControl ),
               ObjectExists( "Text", (_oza[1])::_.autodoc.minTolVersion ) ),
{
      NameBlock oza = _oza[1];
      Set [[ Text name           = oza::_.autodoc.name,
             Text brief          = oza::_.autodoc.brief,
             Text description    = oza::_.autodoc.description,
             Text url            = oza::_.autodoc.url,
             Real version.high   = oza::_.autodoc.version.high,
             Real version.low    = oza::_.autodoc.version.low,
             Text authors        = oza::_.autodoc.authors,
             Text versionControl = oza::_.autdoc.versionControl,
             Text minTolVersion  = oza::_.autodoc.minTolVersion,
             Text maxTolVersion  = If( ObjectExists( Text, oza::_.autodoc.minTolVersion ),
                                       _.autodoc.minTolVersion,
                                       "" ) ]]}, Copy( Empty ) )
    }



// Friday, 2011/12/09 20:25:24.00

    Set {
      Set _oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" );
      If( And( Grammar( oza[1] ) == "NameBlock",
               ObjectExists( "Text", (_oza[1])::_.autodoc.name ),
               ObjectExists( "Text", (_oza[1])::_.autodoc.brief ),
               ObjectExists( "Text", (_oza[1])::_.autodoc.description ),
               ObjectExists( "Text", (_oza[1])::_.autodoc.url ),
               ObjectExists( "Real", (_oza[1])::_.autodoc.version.high ),
               ObjectExists( "Real", (_oza[1])::_.autodoc.version.low),
               ObjectExists( "Text", (_oza[1])::_.autodoc.authors ),
               ObjectExists( "Text", (_oza[1])::_.autodoc.versionControl ),
               ObjectExists( "Text", (_oza[1])::_.autodoc.minTolVersion ) ),
{
      NameBlock oza = _oza[1];
      Set [[ Text name           = oza::_.autodoc.name,
             Text brief          = oza::_.autodoc.brief,
             Text description    = oza::_.autodoc.description,
             Text url            = oza::_.autodoc.url,
             Real version.high   = oza::_.autodoc.version.high,
             Real version.low    = oza::_.autodoc.version.low,
             Text authors        = oza::_.autodoc.authors,
             Text versionControl = oza::_.autdoc.versionControl,
             Text minTolVersion  = oza::_.autodoc.minTolVersion,
             Text maxTolVersion  = If( ObjectExists( oza::_.autodoc.minTolVersion ),
                                       _.autodoc.minTolVersion,
                                       "" ) ]]}, Copy( Empty ) )
    }



// Friday, 2011/12/09 20:16:18.00

    Set {
      Set oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" )/*;
      Set [[ Text name           = oza::_.autodoc.name,
             Text brief          = oza::_.autodoc.brief,
             Text description    = oza::_.autodoc.url,
             Text url            = oza::_.autodoc.url,
             Real version.high   = oza::_.autodoc.version.high,
             Real version.low    = oza::_.autodoc.version.low,
             Text authors        = oza::_.autodoc.authors,
             Text versionControl = oza::_.autdoc.versionControl,
             Text minTolVersion  = oza::_.autodoc.minTolVersion,
             Text maxTolVersion  = If( ObjectExists( oza::_.autodoc.minTolVersion ),
                                       _.autodoc.minTolVersion,
                                       "" ) ]]*/
    }



// Friday, 2011/12/09 20:15:40.00

    Set {
      Set oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" );
      Set [[ Text name           = oza::_.autodoc.name,
             Text brief          = oza::_.autodoc.brief,
             Text description    = oza::_.autodoc.url,
             Text url            = oza::_.autodoc.url,
             Real version.high   = oza::_.autodoc.version.high,
             Real version.low    = oza::_.autodoc.version.low,
             Text authors        = oza::_.autodoc.authors,
             Text versionControl = oza::_.autdoc.versionControl,
             Text minTolVersion  = oza::_.autodoc.minTolVersion,
             Text maxTolVersion  = If( ObjectExists( oza::_.autodoc.minTolVersion ),
                                       _.autodoc.minTolVersion,
                                       "" ) ]]
    }



// Friday, 2011/12/09 20:15:28.00
Set kk = {
  Set Include( "/home/jsperez/.tol/TolPackage/1.1/Client/BysSampler.3.3/BysSampler.3.3.oza" )
}

    Set {
      Set oza = Include( "/home/jsperez/.tol/TolPackage/1.1/Client/TolExcel.2.1/TolExcel.2.1.oza" );
      Set [[ Text name           = oza::_.autodoc.name,
             Text brief          = oza::_.autodoc.brief,
             Text description    = oza::_.autodoc.url,
             Text url            = oza::_.autodoc.url,
             Real version.high   = oza::_.autodoc.version.high,
             Real version.low    = oza::_.autodoc.version.low,
             Text authors        = oza::_.autodoc.authors,
             Text versionControl = oza::_.autdoc.versionControl,
             Text minTolVersion  = oza::_.autodoc.minTolVersion,
             Text maxTolVersion  = If( ObjectExists( oza::_.autodoc.minTolVersion ),
                                       _.autodoc.minTolVersion,
                                       "" ) ]]
    }



// Friday, 2011/12/09 19:53:50.00
Set kk = {
  Set Include( "/home/jsperez/.tol/TolPackage/1.1/Client/BysSampler.3.3/BysSampler.3.3.oza" )
}


// Friday, 2011/12/09 18:03:59.00

Set TolPackage::Client::_.packSyncInfo

// Friday, 2011/12/09 10:50:50.00
#Require MMS;


// Monday, 2011/12/05 19:43:13.00
Real a = 1;
PutName( nodes_sscc[2][1], a );

// Monday, 2011/12/05 18:32:46.00
Matrix MatReadFile( "/tmp/groupsWard.bbm" );


// Monday, 2011/12/05 17:56:39.00
Matrix MatReadFile( "/tmp/groupsSingle.bbm" );


// Monday, 2011/12/05 10:16:07.00



// Monday, 2011/12/05 10:15:41.00



// Sunday, 2011/12/04 01:17:29.00
#Require MMS;


// Sunday, 2011/12/04 01:10:34.00

PutDescription( "#!NB;
<s>chiquito</s> normal <m>mono</m>", x );

// Sunday, 2011/12/04 01:09:39.00
#Require MMS;

Real x = 0;

PutDescription( "#!NB;<s>chiquito</s> normal <m>mono</m>", x );


// Sunday, 2011/12/04 01:09:27.00
#Require MMS;

Real x = 0;

PutDescription( "<s>chiquito</s> normal <m>mono</m>", x );


// Saturday, 2011/12/03 23:52:47.00
#Require MMS;


// Saturday, 2011/12/03 23:51:06.00
#Require MMS;


// Saturday, 2011/12/03 23:19:38.00
#Require MMS;


// Saturday, 2011/12/03 23:16:34.00
#Require MMS;


// Saturday, 2011/12/03 23:08:19.00
#Require MMS;



// Saturday, 2011/12/03 22:36:08.00
#Require MMS;

// Saturday, 2011/12/03 22:35:26.00
Real x = 0;

PutDescription( "#!NB
<s>chiquito</s> normal <m>mono</m>", x );


// Saturday, 2011/12/03 22:32:26.00
Real x = 0;

PutDescription( "#!NB
<s>chiquito</s> normal <m>mono</m>", x );


// Saturday, 2011/12/03 22:30:12.00
Real x = 0;

PutDescription( "#!NB
<s>chiquito</s> normal <m>mono</m>", x );


// Saturday, 2011/12/03 22:26:12.00

PutDescription( "#!NB
<s>chiquito</s> normal <m>mono</m>", x );

// Saturday, 2011/12/03 22:25:47.00
PutDescription( "#!NB
n<s>chiquito</s> normal <m>mono</m>", x );

// Saturday, 2011/12/03 22:25:28.00
PutDescription( "#!NB\n<s>chiquito</s> normal <m>mono</m>", x );

// Saturday, 2011/12/03 22:25:06.00
Real x = 0;

PutDescription( "<s>chiquito</s> normal <m>mono</m>", x );


// Saturday, 2011/12/03 22:24:11.00
Real x = 0;

PutDescription( "<s>chiquito</s> normal <m>mono</m>", x );


// Saturday, 2011/12/03 21:19:50.00
#Require MMS;

MMS;


// Saturday, 2011/12/03 21:13:18.00
#Require MMS;


// Saturday, 2011/12/03 19:40:49.00
PutDescription( "<s>chiquito</s> normal <m>mono</m>", x );

// Saturday, 2011/12/03 19:37:54.00
Real x = 0;

PutDescription( "<s>chiquito</s> normal", x );


// Monday, 2011/11/28 18:51:58.00
#Require MMS


// Monday, 2011/11/28 18:15:02.00
#Require MMS;


// Monday, 2011/11/28 17:21:37.00
#Require MMS;


// Friday, 2011/11/25 22:38:45.00
Set SetToIndexedSet([[ _sscc_vecinas_P18[1] ]]);

// Friday, 2011/11/25 22:36:06.00
Set SetToIndexedSet(_sscc_vecinas_P18);

// Friday, 2011/11/25 20:21:34.00
#Require SSCC_P18_Maps


// Friday, 2011/11/18 17:25:47.00
#Require MMS;



// Friday, 2011/11/18 17:07:04.00
Real TolPackage::Client::RemoteUpgradeAll(?);



// Friday, 2011/11/18 16:49:57.00
#Require MMS;


// Thursday, 2011/11/17 16:46:53.00
#Require MapViewer;



// Thursday, 2011/11/17 16:46:39.00
#Require SpainMaps;



// Wednesday, 2011/11/16 15:25:05.00
#Require BysMcmc;


// Monday, 2011/11/14 20:21:08.00
CalInd(C, W)


// Monday, 2011/11/14 11:09:43.00
#Require PtswClient;


// Monday, 2011/11/14 11:07:27.00
#Require PtswClient


// Thursday, 2011/11/10 09:18:13.00
#Require MapViewer;
#Require SpainMaps;


// Thursday, 2011/11/10 09:18:00.00
#Require MapViewer;


// Thursday, 2011/11/10 09:17:16.00
  GuiTools::ImageManager::setIconForClass
    ( "MapViewer::@GeoVariable", "map_app_16" );

// Thursday, 2011/11/10 09:16:22.00
#Require MapViewer;
#Require SpainMaps;



// Thursday, 2011/11/10 09:12:11.00
  GuiTools::ImageManager::setIconForClass
    ( "MapViewer::@GeoVariable", "location_generic_16" );

// Thursday, 2011/11/10 09:11:13.00
#Require MapViewer;
#Require SpainMaps;


// Thursday, 2011/11/10 00:28:39.00
#Require MapViewer;
#Require SpainMaps;


// Thursday, 2011/11/10 00:28:28.00
#Require MapViewer;


// Thursday, 2011/11/10 00:10:42.00
#Require MapViewer;
#Require SpainMaps;



// Thursday, 2011/11/10 00:08:52.00
#Require MapViewer;

// Wednesday, 2011/11/09 22:28:35.00
#Require MapViewer;
#Require SpainMaps;


// Wednesday, 2011/11/09 22:26:26.00
#Require MapViewer;

// Wednesday, 2011/11/09 22:25:19.00
#Require MapViewer;

// Wednesday, 2011/11/09 22:22:57.00
#Require MapViewer;

// Wednesday, 2011/11/09 21:21:29.00
Set Tcl_Eval( "info commands *Map*" )

// Wednesday, 2011/11/09 21:21:02.00
Set Tcl_Eval( "source /home/jsperez/TOL/projects/bsd/entity/PrjTfnEspRaDe3g/source/process/GIS/tcl/MapViewer.tcl" );

// Wednesday, 2011/11/09 21:20:26.00
Set Tcl_Eval( "source tcl/MapViewer.tcl" );

// Wednesday, 2011/11/09 21:19:47.00
Set Tcl_Eval( "info commands *Map*" );

// Wednesday, 2011/11/09 21:19:37.00
Set Tcl_Eval( "info commands *Map* );

// Wednesday, 2011/11/09 21:15:57.00
#Require MapViewer;
#Require SpainMaps;



// Wednesday, 2011/11/09 21:15:17.00
#Require MapViewer;
#Require SpainMaps;



// Wednesday, 2011/11/09 21:12:40.00
#Require MapViewer;
#Require SpainMaps;



// Wednesday, 2011/11/09 21:12:00.00
#Require MapViewer;
#Require SpainMaps;



// Wednesday, 2011/11/09 21:11:38.00
#Require MapViewer;
#Require SpainMaps;



// Wednesday, 2011/11/09 21:10:49.00
#Require MapViewer;
#Require SpainMaps;



// Miercoles, 2011/11/09 10:42:12.00
//////////////////////////////////////////////////////////////////////////////
Set SetToIndexedSet(Set setNor)
//////////////////////////////////////////////////////////////////////////////
{
  Set setIdx = Copy(Empty);
  Set EvalSet(setNor, Real (Set reg)
  {
     Real valor = reg[2];
     Anything PutName(IntText(reg[1]), valor); 
     Set Append(setIdx, [[ valor ]]);
     Real 1
  });
  Real SetIndexByName(setIdx);
  setIdx
};



// Martes, 2011/11/08 11:15:54.00
#Require MMS;


// Monday, 2011/11/07 15:35:30.00
#Require MapViewer;
MapViewer::@GeoVariable varCobADSL1 = MapViewer::@GeoVariable::New(
[[
  Text _.name        = "Penetracion ADSL Movistar Fijo en 2010-12 (prueba)";
  Text _.regionLevel = "Municipios";
  Set _.values       =  { [[ Real barcelona = 1, Real madrid = 2 ]] };
  Set _.rangeDef     = { [[ Text type = "Uniform", Real size = 4 ]] };
  Set _.colorDef     = { [[ Text type = "Table",   Set colors = [[ "brown", "red", "orange", "yellow" ]] ]] }
]]);



// Monday, 2011/11/07 15:35:05.00
#Require MapViewer;



// Monday, 2011/11/07 15:19:18.00
#Require MapViewer;

MapViewer::@GeoVariable varCobADSL1 = MapViewer::@GeoVariable::New(
[[
  Text _.name        = "Penetracion ADSL Movistar Fijo en 2010-12 (prueba)";
  Text _.regionLevel = "Municipios";
  Set _.values       =  { [[ Real barcelona = 1, Real madrid = 2 ]] };
  Set _.rangeDef     = { [[ Text type = "Uniform", Real size = 4 ]] };
  Set _.colorDef     = { [[ Text type = "Table",   Set colors = [[ "brown", "red", "orange", "yellow" ]] ]] }
]]);



// Monday, 2011/11/07 15:19:09.00
#Require MapViewer


// Monday, 2011/11/07 15:17:32.00
#Require MapViewer


// Monday, 2011/11/07 15:16:15.00
#Require MapViewer;


// Monday, 2011/11/07 15:15:06.00
#Require MapViewer;

// Monday, 2011/11/07 15:14:36.00
#Require MapViewer;

// Monday, 2011/11/07 15:13:46.00
#Require MapViewer;

// Monday, 2011/11/07 15:11:28.00
#Require MapViewer;

// Monday, 2011/11/07 15:06:48.00
#Require MapViewer;

MapViewer::@GeoVariable varCobADSL1 = MapViewer::@GeoVariable::New(
[[
  Text _.name        = "Penetracion ADSL Movistar Fijo en 2010-12 (prueba)";
  Text _.regionLevel = "Municipios";
  Set _.values       =  { [[ Real barcelona = 1, Real madrid = 2 ]] };
  Set _.rangeDef     = { [[ Text type = "Uniform", Real size = 4 ]] };
  Set _.colorDef     = { [[ Text type = "Table",   Set colors = [[ "brown", "red", "orange", "yellow" ]] ]] }
]]);



// Monday, 2011/11/07 15:02:38.00
MapViewer::@GeoVariable varCobADSL1 = MapViewer::@GeoVariable::New(
[[
  Text _.name        = "Penetracion ADSL Movistar Fijo en 2010-12 (prueba)";
  Text _.regionLevel = "Municipios";
  Set _.values       =  { [[ Real barcelona = 1, Real madrid = 2 ]] };
  Set _.rangeDef     = { [[ Text type = "Uniform", Real size = 4 ]] };
  Set _.colorDef     = { [[ Text type = "Table",   Set colors = [[ "brown", "red", "orange", "yellow" ]] ]] }
]]);


// Monday, 2011/11/07 15:02:19.00
MapViewer::@GeoVariable varCobADSL1 = @GeoVariable::New(
[[
  Text _.name        = "Penetracion ADSL Movistar Fijo en 2010-12 (prueba)";
  Text _.regionLevel = "Municipios";
  Set _.values       =  { [[ Real barcelona = 1, Real madrid = 2 ]] };
  Set _.rangeDef     = { [[ Text type = "Uniform", Real size = 4 ]] };
  Set _.colorDef     = { [[ Text type = "Table",   Set colors = [[ "brown", "red", "orange", "yellow" ]] ]] }
]]);


// Monday, 2011/11/07 15:00:30.00
MapViewer

// Monday, 2011/11/07 15:00:17.00
#Require MapViewer



// Monday, 2011/11/07 14:59:38.00
#Require MapViewer;


// Monday, 2011/11/07 14:36:23.00
#Require MapViewer;


// Monday, 2011/11/07 14:34:35.00
#Require MapViewer


// Monday, 2011/11/07 14:34:02.00
#Require MapViewer


// Monday, 2011/11/07 14:32:57.00
Set Tcl_Eval( "set ::auto_path" );

// Monday, 2011/11/07 14:32:46.00
Set Tcl_Eval( "set auto_path" );

// Monday, 2011/11/07 14:32:36.00
#Require MapViewer

Set Tcl_Eval( "set auto_path" );


// Monday, 2011/11/07 14:32:09.00
#Require MapViewer



// Monday, 2011/11/07 14:30:52.00
#Require MapViewer



// Monday, 2011/11/07 14:28:09.00
#Require MapViewer;


// Domingo, 2011/11/06 18:15:11.00
#Require TclCore;


// Domingo, 2011/11/06 18:08:52.00
Set kk = Ois.Load( "/home/jsperez/.tol/TolPackage/1.1/Client/TolIpopt.2.1/TolIpopt.2.1.oza" );


// Sunday, 2011/11/06 17:44:21.00
#Require TclCore;

// Sunday, 2011/11/06 17:44:09.00
NameBlock TclCore = kk[1][1];

// Sunday, 2011/11/06 17:42:53.00
Set kk = Ois.Load( "/home/jsperez/.tol/TolPackage/1.1/Client/TclCore.8.4/TclCore.8.4.oza" );


// Domingo, 2011/11/06 10:27:28.00
WriteLn( "Hola" );


// Viernes, 2011/11/04 10:08:01.00
Set lista = For(1, 25, Set (Real i) { [[i, i^2]] });
Set listas = BinGroup("|",For(1, 11, Set (Real j) { lista }));
Text TclChartSet(listas, [[ 
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
]]);


// Friday, 2011/11/04 10:07:55.00
Set lista = For(1, 25, Set (Real i) { [[i, i^2]] });
Set listas = BinGroup("|",For(1, 11, Set (Real j) { lista }));
Text TclChartSet(listas, [[ 
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
]]);


// Friday, 2011/11/04 09:57:56.00
Text TclChartSet(MatSet(BinGroup("|", 
  For(1, 6, Matrix(Real i) { Col(1,2,3,4,5)|Col(i,i,i,i,i) })
  )), [[ 
    @TclArgSt("-title", Tcl_Eval("mc {Density Functions}")[1]),
    @TclArgSt("-names", TxtListTcl(For(1, 6, Text(Real i) { "v"<<i   }))),
      @TclArgSt("-type" , "3")
    ]]);


// Viernes, 2011/11/04 09:57:39.00
Text TclChartSet(MatSet(BinGroup("|", 
  For(1, 6, Matrix(Real i) { Col(1,2,3,4,5)|Col(i,i,i,i,i) })
  )), [[ 
    @TclArgSt("-title", Tcl_Eval("mc {Density Functions}")[1]),
    @TclArgSt("-names", TxtListTcl(For(1, 6, Text(Real i) { "v"<<i   }))),
      @TclArgSt("-type" , "3")
    ]]);


// Thursday, 2011/10/27 12:45:16.00
Real TolComm::ServerPing( "localhost", 4000012 );

// Thursday, 2011/10/27 12:45:14.00
Real TolComm::ServerPing( "localhost", 4000012 );

// Thursday, 2011/10/27 12:45:09.00
Real TolComm::ServerPing( "localhost", 4000012 );

// Thursday, 2011/10/27 12:44:51.00
Real TolComm::ServerPing( "localhost", 4000012 );

// Thursday, 2011/10/27 12:15:45.00
#Require TolComm;

TolComm 


// Thursday, 2011/10/27 12:15:40.00
#Require TolComm

TolComm 


// Thursday, 2011/10/27 11:48:00.00
#Require TolComm


// Thursday, 2011/10/27 11:47:42.00
#Require TolComm


// Thursday, 2011/10/27 11:47:06.00
#Require TolComm


// Thursday, 2011/10/27 11:38:21.00
#Require TolComm;


// Thursday, 2011/10/27 11:33:14.00
#Require TolComm;


// Thursday, 2011/10/27 11:32:06.00
#Require TolComm;


// Miercoles, 2011/10/26 19:14:57.00
#Require TolServer;


// Miercoles, 2011/10/26 19:13:35.00
Code TolServerPing


// Tuesday, 2011/10/25 15:09:15.00
Real RmtPsClient::Ping( "cox1", 6668 );

// Martes, 2011/10/25 14:49:54.00
Set Ois.Load( "/tmp/kk.oza" )[1];

// Martes, 2011/10/25 14:49:26.00
Set Ois.Load( "/tmp/kk.oza" );

// Martes, 2011/10/25 14:49:10.00
Real Ois.Store( [[ s * 3]], "/tmp/kk.oza" );

// Martes, 2011/10/25 14:40:41.00

Text FormatReal( s, "%.0f" );

// Martes, 2011/10/25 14:40:29.00

Real s := 100000/3;;

// Martes, 2011/10/25 14:40:19.00

Text FormatReal( s, "%f" );

// Martes, 2011/10/25 14:39:53.00
#Require RmtPsClient;

Real s = 100000/4;;


// Tuesday, 2011/10/25 14:32:49.00
#Require RmtPsClient;
Text GetPID(?);


// Tuesday, 2011/10/25 14:32:28.00
#Require RmtPsClient;

Real GetPID(?);


// Tuesday, 2011/10/25 14:32:22.00
#Require RmtPsClient;

Real GetPid(?);


// Tuesday, 2011/10/25 14:32:17.00
#Require RmtpsClient;

Real GetPid(?);


// Martes, 2011/10/25 14:13:01.00
#Require RmtPsClient;


// Tuesday, 2011/10/25 14:12:46.00
#Require RmtpsClient;



// Martes, 2011/10/25 14:11:56.00
#Require RmtpsClient;


// Martes, 2011/10/25 14:11:31.00
#Require RmtpsClient;


// Martes, 2011/10/25 14:11:09.00
#Require MMS;


// Saturday, 2011/10/22 10:57:30.00
#Require MMS;


// Friday, 2011/10/21 15:15:54.00
#Require MMS;

NameBlock est = MMS::Container::LoadFile( "/tmp/BSR__PrecioHor.03.Log.y2011m10d13.SoloGen.oza" );
Real est::Execute(?);



// Friday, 2011/10/21 12:50:17.00
Real est::GetStrategy(?)::SaveIsolationFile( "/tmp/BSR__PrecioHor.03.Log.y2011m10d13.SoloGen.bsr.zip" );

// Friday, 2011/10/21 12:49:31.00
Real est::GetStrategy::SaveIsolationFile( "/tmp/BSR__PrecioHor.03.Log.y2011m10d13.SoloGen.bsr.zip" );

// Friday, 2011/10/21 12:48:17.00
Real est::SaveIsolationFile( "/tmp/BSR__PrecioHor.03.Log.y2011m10d13.SoloGen.bsr.zip" );

// Friday, 2011/10/21 12:47:23.00
Real est::SaveIsolationFile( "/tmp/iso_kk.zip" );

// Friday, 2011/10/21 12:42:52.00
#Require MMS;

NameBlock est = MMS::Container::LoadFile( "/tmp/BSR__PrecioHor.03.Log.y2011m10d13.SoloGen.oza" );
Real est::Execute(?);



// Friday, 2011/10/21 12:42:51.00
#Require MMS;

NameBlock est = MMS::Container::LoadFile( "/tmp/BSR__PrecioHor.03.Log.y2011m10d13.SoloGen.oza" );


// Friday, 2011/10/21 12:42:38.00
#Require MMS;



// Friday, 2011/10/21 12:34:17.00
#Require MMS;



// Thursday, 2011/10/20 13:25:59.00
#Require MMS


// Jueves, 2011/10/20 13:20:07.00
#Require MMS


// Jueves, 2011/10/20 13:19:22.00
#Require MMS;


// Jueves, 2011/10/20 13:18:22.00
#Require MMS


// Thursday, 2011/10/20 13:17:33.00
#Require MMS;


// Thursday, 2011/10/20 13:14:32.00
#Require MMS;


// Thursday, 2011/10/20 13:12:38.00
#Require MMS;


// Tuesday, 2011/10/18 09:23:28.00
TolPackage::Client

// Tuesday, 2011/10/18 09:23:14.00
 Real TolPackage::Client::RemoteUpdatePackSyncInfo(False);


// Monday, 2011/10/17 14:10:13.00
Real TolPackage::Client::RemoteUpdatePackSyncInfo(False);

// Monday, 2011/10/17 14:08:53.00
TolPackage::Client::_.versSyncInfo

// Monday, 2011/10/17 14:08:48.00
Real TolPackage::Client::RemoteUpdateVersSyncInfo(False);

// Monday, 2011/10/17 13:12:36.00
TolPackage::Client

// Monday, 2011/10/17 13:12:18.00
Set TolConfigManager::Config::Upgrading::TolPackage::Repositories;

// Monday, 2011/10/17 13:11:57.00
Real TolPackage::Client::RemoteUpdateVersSyncInfo(False);


// Monday, 2011/10/17 13:11:19.00
Real TolPackage::Client::RemoteUpdateVersSyncInfo(False);

// Monday, 2011/10/17 11:44:33.00
TolPackage::Client::_.versSyncInfo

// Monday, 2011/10/17 11:44:30.00
Real TolPackage::Client::RemoteUpdateVersSyncInfo(False);

// Monday, 2011/10/17 11:44:12.00

TolPackage::Client::_.versSyncInfo

// Monday, 2011/10/17 11:42:09.00
Set TolPackage::Client::GetRepositoryInfo(
    "http://packages.tol-project.org/OfficialTolArchiveNetwork/repository.php?action=general_information");


// Friday, 2011/10/14 09:29:20.00
Real TolPackage::Client::CheckRepositoryPing( "http://packages.tol-project.org/OfficialTolArchiveNetwork/repository.php" );


// Friday, 2011/10/14 09:23:57.00
Set TolPackage::Client::GetRepositoryInfo( "http://packages.tol-project.org/OfficialTolArchiveNetwork" );

// Friday, 2011/10/14 09:23:18.00
Set TolPackage::Client::GetRepositoryInfo( "http://packages.tol-project.org/OfficialTolArchiveNetwork/repository.php" );

// Friday, 2011/10/14 09:07:34.00
TolPackage

// Friday, 2011/10/14 08:58:32.00
Set TolPackage::Client::_.packInstalled;

// Friday, 2011/10/14 08:57:27.00
TolPackage::Client::_.versSyncInfo

// Friday, 2011/10/14 08:57:09.00
Set Select(TolPackage::Client::_.versSyncInfo, Real(Set pkg)
{
  pkg->co_name=="NonLinGloOpt"
})

// Friday, 2011/10/14 08:56:59.00
Real TolPackage::Client::RemoteUpdatePackSyncInfo(False);
Real TolPackage::Client::RemoteUpdateVersSyncInfo(False);

Set Select(TolPackage::Client::_.packSyncInfo, Real(Set pkg)
{
  pkg->te_url=="http://packages.tol-project.org/OfficialTolArchiveNetwork/repository.php"
})

Set TolConfigManager::Config::Upgrading::TolPackage::Repositories;

Set Select(TolPackage::Client::_.versSyncInfo, Real(Set pkg)
{
  pkg->co_name=="NonLinGloOpt"
})


// Friday, 2011/10/14 08:55:36.00
TolPackage::Client::_.packSyncInfo

// Friday, 2011/10/14 08:53:49.00
Set TolConfigManager::Config::Upgrading::TolPackage::Repositories;

// Friday, 2011/10/14 08:51:50.00
Set Select(TolPackage::Client::_.packSyncInfo, Real(Set pkg)
{
  pkg->te_url=="http://packages.tol-project.org/OfficialTolArchiveNetwork/repository.php"
})

// Friday, 2011/10/14 08:51:42.00
Real TolPackage::Client::RemoteUpdatePackSyncInfo(False);
Real TolPackage::Client::RemoteUpdateVersSyncInfo(False);

// Friday, 2011/10/14 08:50:56.00
Set Select(TolPackage::Client::_.packSyncInfo, Real(Set pkg)
{
  pkg->te_url=="http://packages.tol-project.org/OfficialTolArchiveNetwork/repository.php"
})


// Thursday, 2011/10/13 21:42:06.00
Set TolConfigManager::Config::Upgrading::TolPackage::Repositories;



// Thursday, 2011/10/13 16:32:43.00
TolPackage


// Thursday, 2011/10/13 16:13:01.00
Matrix PolMat( p, 10, 1 );

// Thursday, 2011/10/13 16:11:33.00
Matrix PolMat( p, 3, 3 );

// Thursday, 2011/10/13 16:11:18.00
Matrix PolMat( p, 2, 3 );

// Thursday, 2011/10/13 16:10:57.00
Polyn p = 1 + 0.1*B;
Matrix PolMat( p, 2, 1 );


// Thursday, 2011/10/13 16:10:39.00
Polyn p = 1 + 0.1*B;
Matrix PolMat( p );


// Wednesday, 2011/10/05 17:50:20.00
(GetProjectRepository("BBVASP/PRCoCo/"))::GetEstimationsPath(?)

// Wednesday, 2011/10/05 17:49:30.00
(GetProjectRepository("BBVASP/PRCoCo/"))

// Wednesday, 2011/10/05 17:49:14.00
(GetProjectRepository("BBVASP/PRCoCo/"))::GetEstimationsPath(?)

// Wednesday, 2011/10/05 17:49:00.00
#Require MMS;

// Wednesday, 2011/10/05 17:48:34.00
(GetProjectRepository("BBVASP/PRCoCo/"))

// Wednesday, 2011/10/05 17:48:22.00
GetProjectRepository("BBVASP/PRCoCo/"))

// Wednesday, 2011/10/05 17:48:04.00
Text PutDumpFile((GetProjectRepository("BBVASP/PRCoCo/"))::GetEstimationsPath(?) +"log/20111005_1726.log");

// Wednesday, 2011/10/05 17:47:42.00
Text PutDumpFile(GetProjectRepository("BBVASP/PRCoCo/")::GetEstimationsPath(?) +"log/20111005_1726.log");

// Wednesday, 2011/10/05 17:47:21.00
Text __REPO_ROOT__ = "/media/nas/bmr/";

NameBlock GetProjectRepository( Text pathBMR )
{
  Text absPathBMR = __REPO_ROOT__ + pathBMR ;
  Set MMS::Network::GetConnections(?);
  Text connName = ReplaceTable( pathBMR,
                                [[ [[ "/", "_._" ]], [[ "\\", "_._" ]] ]] );
  NameBlock repo = If( MMS::Network::FindRepository( connName ),
                       MMS::Network::GetRepository( connName ),
                       If( MMS::Network::FindConnection( connName ),
                           MMS::Network::OpenRepository( connName ), {
                             MMS::Network::DefineConnection( connName, "Folder", 
                                                             absPathBMR,
                                                             "Repositorio de " + pathBMR );
                             MMS::Network::OpenRepository( connName ) } ) )
};




// Wednesday, 2011/10/05 09:22:06.00
Real RunMmsEstimation_AtRepository( "BBVASP/PRCoCo/", "PRCoCo.Est.99964274__20111003" );

// Wednesday, 2011/10/05 09:18:30.00
#Require MMS;

// assume there is a global variable __REPO_ROOT__
// 
// for tests:
//            Text __REPO_ROOT__ = "/media/nas/bmr/";

NameBlock GetProjectRepository( Text pathBMR )
{
  Text absPathBMR = __REPO_ROOT__ + pathBMR ;
  Set MMS::Network::GetConnections(?);
  Text connName = ReplaceTable( pathBMR,
                                [[ [[ "/", "_._" ]], [[ "\\", "_._" ]] ]] );
  NameBlock repo = If( MMS::Network::FindRepository( connName ),
                       MMS::Network::GetRepository( connName ),
                       If( MMS::Network::FindConnection( connName ),
                           MMS::Network::OpenRepository( connName ), {
                             MMS::Network::DefineConnection( connName, "Folder", 
                                                             absPathBMR,
                                                             "Repositorio de " + pathBMR );
                             MMS::Network::OpenRepository( connName ) } ) )
};

//NameBlock repo = GetProjectRepository( "BBVASP/PRCoCo/" );
// NameBlock repo::LoadEstimation( "PRCoCo.Est.99964274__20111003" );

Real RunMmsEstimation_AtRepository( Text pathBMR, Text EstimationName )
{
  NameBlock repo = GetProjectRepository( pathBMR );
  WriteLn( "OK" );
  Text dirLog  = repo::GetEstimationsPath(?) + "/log/";
  Text dirLock  = repo::GetEstimationsPath(?) + "/lock/";
  // create log folder
  Real OSDirMake( dirLog );
  // create lock folder
  Real OSDirMake( dirLock );
  Text oldDump = GetDumpFile( ? );
  //Text PutDumpFile( PathLog + "/" + name + ".log" );
  Text PutDumpFile( dirLog + EstimationName + ".log" );
  WriteLn( "Loading estimation " + EstimationName );
  NameBlock est = repo::LoadEstimation( EstimationName );

  // TODO: create the lock file or refuse estimation if another lock
  // is set on this estimation

  WriteLn( "Starting estimation " + EstimationName );
  Real est::Execute(?);
  WriteLn("Estimation finished " + name);

  // TODO: update attributes (executed)
  Real est::SetAttribute( "_.executed", est::HasResults(?) );
  
  Real est::Save( "Heavy" );

  // TODO: release the lock file

  // Restore dump file
  Text PutDumpFile( oldDump, 0 );
  Real 1
};

//Real RunMmsEstimation_AtRepository( "BBVASP/PRCoCo/", "PRCoCo.Est.99964274__20111003" );




// Wednesday, 2011/10/05 09:16:57.00
NameBlock repo::LoadEstimation( "PRCoCo.Est.99964274__20111003" );

// Wednesday, 2011/10/05 09:14:40.00
NameBlock repo = GetProjectRepository( "BBVASP/PRCoCo/" );

// Wednesday, 2011/10/05 09:14:07.00
#Require MMS;

Text __REPO_ROOT__ = "/media/nas/bmr/";

NameBlock GetProjectRepository( Text pathBMR )
{
  Text absPathBMR = __REPO_ROOT__ + pathBMR ;
  Set MMS::Network::GetConnections(?);
  Text connName = ReplaceTable( pathBMR,
                                [[ [[ "/", "_._" ]], [[ "\\", "_._" ]] ]] );
  NameBlock repo = If( MMS::Network::FindRepository( connName ),
                       MMS::Network::GetRepository( connName ),
                       If( MMS::Network::FindConnection( connName ),
                           MMS::Network::OpenRepository( connName ), {
                             MMS::Network::DefineConnection( connName, "Folder", 
                                                             absPathBMR,
                                                             "Repositorio de " + pathBMR );
                             MMS::Network::OpenRepository( connName ) } ) )
};

//NameBlock repo = GetProjectRepository( "BBVASP/PRCoCo/" );

Real RunMmsEstimation_AtRepository( Text pathBMR, Text EstimationName )
{
  NameBlock repo = GetProjectRepository( pathBMR );
  WriteLn( "OK" );
  Text dirLog  = repo::GetEstimationsPath(?) + "/log/";
  Text dirLock  = repo::GetEstimationsPath(?) + "/lock/";
  // create log folder
  Real OSDirMake( dirLog );
  // create lock folder
  Real OSDirMake( dirLock );
  Text oldDump = GetDumpFile( ? );
  //Text PutDumpFile( PathLog + "/" + name + ".log" );
  Text PutDumpFile( dirLog + EstimationName + ".log" );
  WriteLn( "Loading estimation " + EstimationName );
  NameBlock est = repo::LoadEstimation( EstimationName );

  // TODO: create the lock file or refuse estimation if another lock
  // is set on this estimation

  WriteLn( "Starting estimation " + EstimationName );
  Real est::Execute(?);
  WriteLn("Estimation finished " + name);

  // TODO: update attributes (executed)
  Real est::SetAttribute( "_.executed", est::HasResults(?) );
  
  Real est::Save( "Heavy" );

  // TODO: release the lock file

  // Restore dump file
  Text PutDumpFile( oldDump, 0 );
  Real 1
};

Real RunMmsEstimation_AtRepository( "BBVASP/PRCoCo/", "PRCoCo.Est.98452337__20111003" );



// Wednesday, 2011/10/05 09:12:46.00
NameBlock repo = GetProjectRepository( "BBVASP/PRCoCo/" );

// Wednesday, 2011/10/05 09:11:11.00
#Require MMS;

Text __REPO_ROOT__ = "/media/nas/bmr/";

NameBlock GetProjectRepository( Text pathBMR )
{
  Text absPathBMR = __REPO_ROOT__ + pathBMR ;
  Set MMS::Network::GetConnections(?);
  Text connName = ReplaceTable( pathBMR,
                                [[ [[ "/", "_._" ]], [[ "\\", "_._" ]] ]] );
  NameBlock repo = If( MMS::Network::FindRepository( connName ),
                       MMS::Network::GetRepository( connName ),
                       If( MMS::Network::FindConnection( connName ),
                           MMS::Network::OpenRepository( connName ), {
                             MMS::Network::DefineConnection( connName, "Folder", 
                                                             absPathBMR,
                                                             "Repositorio de " + pathBMR );
                             MMS::Network::OpenRepository( connName ) } ) )
};

Real RunMmsEstimation_AtRepository( Text pathBMR, Text EstimationName )
{
  NameBlock repo = GetProjectRepository( pathBMR );
  Text dirLog  = repo::GetEstimationsPath(?) + "/log/";
  Text dirLock  = repo::GetEstimationsPath(?) + "/lock/";
  // create log folder
  Real OSDirMake( dirLog );
  // create lock folder
  Real OSDirMake( dirLock );
  Text oldDump = GetDumpFile( ? );
  //Text PutDumpFile( PathLog + "/" + name + ".log" );
  Text PutDumpFile( dirLog + EstimationName + ".log" );
  WriteLn( "Loading estimation " + EstimationName );
  NameBlock est = repo::LoadEstimation( EstimationName );

  // TODO: create the lock file or refuse estimation if another lock
  // is set on this estimation

  WriteLn( "Starting estimation " + EstimationName );
  Real est::Execute(?);
  WriteLn("Estimation finished " + name);

  // TODO: update attributes (executed)
  Real est::SetAttribute( "_.executed", est::HasResults(?) );
  
  Real est::Save( "Heavy" );

  // TODO: release the lock file

  // Restore dump file
  Text PutDumpFile( oldDump, 0 );
  Real 1
};

Real RunMmsEstimation_AtRepository( "BBVASP/PRCoCo/", "PRCoCo.Est.98452337__20111003" );



// Wednesday, 2011/10/05 09:10:00.00
Real RunMmsEstimation_AtRepository( "BBVASP/PRCoCo/", "PRCoCo.Est.98452337__20111003" );

// Wednesday, 2011/10/05 09:09:39.00
#Require MMS;

// Wednesday, 2011/10/05 09:09:07.00
Real RunMmsEstimation_AtRepository( "BBVASP/PRCoCo/", "PRCoCo.Est.98452337__20111003" );

// Wednesday, 2011/10/05 09:05:41.00
Text __REPO_ROOT__ = "/media/nas/bmr/";

NameBlock GetProjectRepository( Text pathBMR )
{
  Text absPathBMR = __REPO_ROOT__ + pathBMR ;
  Set MMS::Network::GetConnections(?);
  Text connName = ReplaceTable( pathBMR,
                                [[ [[ "/", "_._" ]], [[ "\\", "_._" ]] ]] );
  NameBlock repo = If( MMS::Network::FindRepository( connName ),
                       MMS::Network::GetRepository( connName ),
                       If( MMS::Network::FindConnection( connName ),
                           MMS::Network::OpenRepository( connName ), {
                             DefineConnection( connName, "Folder", 
                                               absPathBMR,
                                               "Repositorio de " + pathBMR );
                             MMS::Network::OpenRepository( connName ) } ) )
};

Real RunMmsEstimation_AtRepository( Text pathBMR, Text EstimationName )
{
  NameBlock repo = GetProjectRepository( pathBMR );
  Text dirLog  = repo::GetEstimationsPath(?) + "/log/";
  Text dirLock  = repo::GetEstimationsPath(?) + "/lock/";
  // create log folder
  Real OSDirMake( dirLog );
  // create lock folder
  Real OSDirMake( dirLock );
  Text oldDump = GetDumpFile( ? );
  //Text PutDumpFile( PathLog + "/" + name + ".log" );
  Text PutDumpFile( dirLog + EstimationName + ".log" );
  WriteLn( "Loading estimation " + EstimationName );
  NameBlock est = repo::LoadEstimation( EstimationName );

  // TODO: create the lock file or refuse estimation if another lock
  // is set on this estimation

  WriteLn( "Starting estimation " + EstimationName );
  Real est::Execute(?);
  WriteLn("Estimation finished " + name);

  // TODO: update attributes (executed)
  Real est::SetAttribute( "_.executed", est::HasResults(?) );
  
  Real est::Save( "Heavy" );

  // TODO: release the lock file

  // Restore dump file
  Text PutDumpFile( oldDump, 0 );
  Real 1
};



// Wednesday, 2011/10/05 08:52:35.00
NameBlock repo::LoadEstimation( "PRCoCo.Est.16161214__20111003" );

// Wednesday, 2011/10/05 08:50:39.00
Set repo::GetEstimationsList(?);

// Wednesday, 2011/10/05 08:44:28.00
Text repo::GetPath(?);

// Wednesday, 2011/10/05 08:42:25.00
MMS::Network

// Wednesday, 2011/10/05 08:41:35.00
NameBlock repo = If( MMS::Network::FindRepository( connName ),
                     MMS::Network::GetRepository( connName ),
                     If( MMS::Network::FindConnection( connName ),
                         MMS::Network::OpenRepository( connName ), {
                           DefineConnection( connName, "Folder", 
                                             absPathBMR,
                                             "Repositorio de " + pathBMR );
                           MMS::Network::OpenRepository( connName ) } ) );

// Wednesday, 2011/10/05 08:40:55.00
MMS::Network::FindConnection( connName )

// Wednesday, 2011/10/05 08:40:20.00
MMS::Network::FindRepository( connName )

// Wednesday, 2011/10/05 08:40:01.00
#Require MMS;


Text __REPO_ROOT__ = "/media/nas/bmr/";
Text  pathBMR = "BBVASP/PRCoCo";
Text absPathBMR = __REPO_ROOT__ + pathBMR ;
Set MMS::Network::GetConnections(?);
Text connName = ReplaceTable( pathBMR, [[ [[ "/", "_._" ]] ]] );

// Wednesday, 2011/10/05 08:33:07.00
If( MMS::Network::FindConnection( connName ),
                        MMS::Network::OpenConnection( connName ),
                        {
                          DefineConnection( connName, "Folder", 
                                                          absPathBMR, "Repositorio de " + pathBMR );
                          MMS::Network::OpenConnection( connName ) } );

// Wednesday, 2011/10/05 08:32:58.00
If( MMS::Network::FindConnection( connName ),
                        MMS::Network::OpenConnection( connName ),
                        {
                          DefineConnection( connName, "Folder", 
                                                          absPathBMR, "Repositorio de " + pathBMR );
                          MMS::Network::OpenConnection( connName ) } );

// Wednesday, 2011/10/05 08:30:45.00
MMS::Network

// Wednesday, 2011/10/05 08:30:39.00
MMS::Network::

// Wednesday, 2011/10/05 08:30:26.00
If( MMS::Network::FindConnection( connName ),
                  MMS::Network::GetConnection( connName ),
                  MMS::Network::DefineConnection( connName, "Folder", 
                                                  absPathBMR, "Repositorio de " + pathBMR ) );

// Wednesday, 2011/10/05 08:29:33.00
MMS::Network::GetConnection( connName )

// Wednesday, 2011/10/05 08:29:19.00
MMS::Network::FindConnection( connName )

// Wednesday, 2011/10/05 08:28:52.00
NameBlock conn = If( MMS::Network::FindConnection( connName ),
                     MMS::Network::GetConnection( connName ),
                     MMS::Network::DefineConnection( connName, "Folder", 
                                                     absPathBMR, "Repositorio de " + pathBMR ) );

// Wednesday, 2011/10/05 08:28:39.00
Text __REPO_ROOT__ = "/media/nas/bmr/";
Text  pathBMR := "BBVASP/PRCoCo";
Text absPathBMR = __REPO_ROOT__ + pathBMR ;
Set MMS::Network::GetConnections(?);
Text connName := ReplaceTable( pathBMR, [[ [[ "/", "_._" ]] ]] );

// Wednesday, 2011/10/05 08:28:20.00
Text __REPO_ROOT__ = "/media/nas/bmr/";
Text  pathBMR := "BBVASP/PRCoCo";
Text absPathBMR = __REPO_ROOT__ + pathBMR ;
Set MMS::Network::GetConnections(?);
Text connName = ReplaceTable( pathBMR, [[ [[ "/", "_._" ]] ]] );

// Wednesday, 2011/10/05 08:27:36.00
Text __REPO_ROOT__ = "/media/nas/bmr/";
Text  pathBMR = "BBVASP/PRCoCo";
Text absPathBMR = __REPO_ROOT__ + pathBMR ;
Set MMS::Network::GetConnections(?);
Text connName = ReplaceTable( pathBMR, [[ [[ "/", "_._" ]] ]] );
NameBlock conn = If( MMS::Network::FindConnection( connName ),
                     MMS::Network::GetConnection( connName ),
                     MMS::Network::DefineConnection( connName, "Folder", 
                                                     absPathBMR, "Repositorio de " + pathBMR ) );

// Wednesday, 2011/10/05 08:27:10.00
Text __REPO_ROOT__ = "/media/nas/bmr/";
Text  pathBMR = "BBVASP/PRCoCo";
Text absPathBMR = __REPO_ROOT__ + pathBMR ;
Set MMS::Network::GetConnections(?);
Text connName = ReplaceTable( pathBMR, [[ [[ "/", "_._" ]] ]] );
NameBlock conn = If( FindConnection( connName ),
                     MMS::Network::GetConnection( connName ),
                     MMS::Network::DefineConnection( connName, "Folder", 
                                                     absPathBMR, "Repositorio de " + pathBMR ) );

// Wednesday, 2011/10/05 08:26:04.00
#Require MMS;

Text __REPO_ROOT__ = "/media/nas/bmr/";
Text  pathBMR = "BBVASP/PRCoCo";
Text absPathBMR = __REPO_ROOT__ + pathBMR ;
Set MMS::Network::GetConnections(?);
Text connName = Replace( pathBMR, "_._" );
NameBlock conn = If( FindConnection( connName ),
                     MMS::Network::GetConnection( connName ),
                     MMS::Network::DefineConnection( connName, "Folder", 
                                                     absPathBMR, "Repositorio de " + pathBMR ) );

// Wednesday, 2011/10/05 08:25:32.00
Text __REPO_ROOT__ = "/media/nas/bmr/";
Text  pathBMR = "BBVASP/PRCoCo";
Text absPathBMR = __REPO_ROOT__ + pathBMR ;
Set MMS::Network::GetConnections(?);
Text connName = Replace( pathBMR, "_._" );
NameBlock conn = If( FindConnection( connName ),
                     MMS::Network::GetConnection( connName ),
                     MMS::Network::DefineConnection( connName, "Folder", 
                                                     absPathBMR, "Repositorio de " + pathBMR ),

// Wednesday, 2011/10/05 08:16:56.00
Set MMS::Network::GetConnections(?);

// Wednesday, 2011/10/05 08:13:20.00
MMS::Network

// Wednesday, 2011/10/05 08:12:34.00
#Require MMS;

MMS



// Wednesday, 2011/10/05 08:12:28.00
#Require MMS;



// Tuesday, 2011/10/04 15:56:45.00
#Require MMS;

MMS;


// Tuesday, 2011/10/04 15:56:04.00
#Require MMS;


// Monday, 2011/09/26 09:46:52.00
Real (First(s)!=TheBegin)

// Monday, 2011/09/26 09:46:50.00
Serie s = Gaussian( 0, 1);

// Monday, 2011/09/26 09:41:15.00
Real (Date Today > TheBegin)


// Lunes, 2011/09/26 00:05:56.00
Set Vale_ComputeDeco.WithForecast( forecast );

// Domingo, 2011/09/25 23:59:58.00
Set Vale_ComputeDeco.WithForecast( forecast );

// Domingo, 2011/09/25 23:58:32.00
     Set [[
                              Serie sm3::GetOutput.WithForecast.Mean(?);
                              Serie sm3::GetNoise.WithForecast.Mean(?)
                              ]] << sm3::GetEffects.WithForecast.Mean(?)

// Domingo, 2011/09/25 23:58:28.00
NameBlock sm3 = m3::GetSubmodel(1);

// Domingo, 2011/09/25 23:58:25.00
NameBlock m3 = forecast::GetModel.Forecast(1);

// Domingo, 2011/09/25 23:58:01.00
     Set [[
                              Serie sm3::GetOutput.WithForecast.Mean(?);
                              Serie sm3::GetNoise.WithForecast.Mean(?)
                              ]] << sm3::GetEffects.WithForecast.Mean(?)



// Domingo, 2011/09/25 23:50:15.00
     Set [[
                              Serie sm3::GetOutput(?);
                              Serie sm3::GetNoise(?)
                              ]] << sm3::GetEffects(?)

// Domingo, 2011/09/25 23:49:40.00
NameBlock sm3 = m3::GetSubmodel(1);

// Domingo, 2011/09/25 23:49:24.00
NameBlock m3 = forecast::GetModel(1);
NameBlock sm3 = m2::GetSubmodel(1);

// Domingo, 2011/09/25 23:47:45.00
Set Vale_ComputeDecoForecast( forecast );

// Domingo, 2011/09/25 23:46:45.00
Set Vale_ComputeDecoForecast( forecast );

// Domingo, 2011/09/25 23:45:58.00
Set Vale_ComputeDecoForecast( forecast );

// Domingo, 2011/09/25 23:45:46.00
Set Vale_ComputeDeco( forecast );

// Domingo, 2011/09/25 22:06:58.00
Set Vale_ComputeDeco( forecast );

// Domingo, 2011/09/25 22:06:27.00
Set Vale_ComputeDeco( NameBlock forecast )
{
  NameBlock res = forecast::GetModel.Forecast( ? );
  
Set results = EvalSet(res::GetSubmodels(?), Set(NameBlock subM)
      {
     
     Set decoInitial = [[
                              Serie subM::GetOutput.Forecast.Mean(?);
                              Serie subM::GetNoise.Forecast.Mean(?)
                              ]] << subM::GetEffects.Forecast.Mean(?)
  });
  
  // esta otra función saca los due-tos
 /* 
  Set decosDt = EvalSet (results, Set (Set resini){
    Set decoIni = resini;
      
    Set decoInitial = EvalSet(decoIni,Serie (Serie ser)
    {
      Set sName1 = Tokenizer(Name(ser),"_");
      Text name = If(
        sName1[Card(sName1)]=="Forecast.Mean",
        TxtListItem(sName1-[[ sName1[Card(sName1)] ]],"_"),
        {
          Set sName2 = Tokenizer(Name(ser),".");
          Text If(
            And(sName2[Card(sName2)-1]=="Forecast",sName2[Card(sName2)]=="Mean"),
            TxtListItem(sName2-[[ sName2[Card(sName2)-1] ]] -[[ sName2[Card(sName2)] ]],"."),
            Name(ser)
          )
        }
      );
      Serie Eval("Serie "+name+" = ser;")
    });
      Set contribsNames = For(3,Card(resini),Text (Real i) { Name(decoInitial[i]) } );
      Text brandName = Tokenizer(contribsNames[1],"_")[1];
      Set deco00 = DecoTools::Deco.BaseDefinition(decoInitial, [[
     DecoTools::@Contribution.Def(Tokenizer(Name(resini[1]),"_")[1]+"__Base" , Copy(Empty))
  
        ]] << EvalSet(contribsNames, Anything (Text nam) {
                   DecoTools::@Contribution.Def(nam, [[
                            DecoTools::@Contribution.Ref(nam, 0) ]] ) })
       );
  
       Set deco02 = DecoTools::GeneralizedDueTo.Period(deco00, FindCode("Serie", "Exp"), 52); // semanal
       Set deco02M = DecoTools::Deco.Serie.DatCh(deco02, Mensual, SumS); // mensual
       Set deco02T = DecoTools::Deco.Serie.DatCh(deco02, Trimestral, SumS); // trimestral
       Set deco02A = DecoTools::Deco.Serie.DatCh(deco02, Yearly, SumS); // anual
  
       Set a_ = [[ deco00,deco02,deco02M,deco02T,deco02A ]];
       Eval("Set "+brandName+" = a_")
  });
 */ 
  // Esta otra función hace las decos
  
  Set decosDec = EvalSet (results, Set (Set resini){
       Set decoIni = resini;
      
    Set decoInitial = EvalSet(decoIni,Serie (Serie ser)
    {
      Set sName1 = Tokenizer(Name(ser),"_");
      Text name = If(
        sName1[Card(sName1)]=="Forecast.Mean",
        TxtListItem(sName1-[[ sName1[Card(sName1)] ]],"_"),
        {
          Set sName2 = Tokenizer(Name(ser),".");
          Text If(
            And(sName2[Card(sName2)-1]=="Forecast",sName2[Card(sName2)]=="Mean"),
            TxtListItem(sName2-[[ sName2[Card(sName2)-1] ]] -[[ sName2[Card(sName2)] ]],"."),
            Name(ser)
          )
        }
      );
      Serie Eval("Serie "+name+" = ser;")
    });
      Set contribsNames = For(3,Card(resini),Text (Real i) { Name(decoInitial[i]) } );
      Text brandName = Tokenizer(contribsNames[1],"_")[1];
      Set contribsNamesDeco = contribsNames;

      Set deco00 = DecoTools::Deco.BaseDefinition(decoInitial, [[
     DecoTools::@Contribution.Def(Tokenizer(Name(resini[1]),"_")[1]+"__Base" , Copy(Empty))
  
        ]] << EvalSet(contribsNamesDeco, Anything (Text nam) {
                   DecoTools::@Contribution.Def(nam, [[
                            DecoTools::@Contribution.Ref(nam, 0) ]] ) })
       );
  
  
  // deco substractiva
              Set deco03 = DecoTools::Deco.SynergyFree(DecoTools::Deco.BaseFirstIn(deco00, FindCode("Real", "Exp"))); // resultado en semanal
              Set deco03M = DecoTools::Deco.Serie.DatCh(deco03, Mensual, SumS); // en mensual
              Set deco03A = DecoTools::Deco.Serie.DatCh(deco03, Yearly, SumS); // en anual
  
  
       Set a_ = [[ deco00,deco03,deco03M,deco03A]];
       Eval("Set "+brandName+" = a_")
  })
};


// Domingo, 2011/09/25 21:53:52.00
Set results = EvalSet(m2::GetSubmodels(?), Set(NameBlock subM)
      {
     
     Set decoInitial = [[
                              Serie subM::GetOutput.Forecast.Mean(?);
                              Serie subM::GetNoise.Forecast.Mean(?)
                              ]] << subM::GetEffects.Forecast.Mean(?)
  });
  
  // esta otra función saca los due-tos
  
  Set decosDt = EvalSet (results, Set (Set resini){
    Set decoIni = resini;
      
    Set decoInitial = EvalSet(decoIni,Serie (Serie ser)
    {
      Set sName1 = Tokenizer(Name(ser),"_");
      Text name = If(
        sName1[Card(sName1)]=="Forecast.Mean",
        TxtListItem(sName1-[[ sName1[Card(sName1)] ]],"_"),
        {
          Set sName2 = Tokenizer(Name(ser),".");
          Text If(
            And(sName2[Card(sName2)-1]=="Forecast",sName2[Card(sName2)]=="Mean"),
            TxtListItem(sName2-[[ sName2[Card(sName2)-1] ]] -[[ sName2[Card(sName2)]
]],"."),
            Name(ser)
          )
        }
      );
      Serie Eval("Serie "+name+" = ser;")
    });
      Set contribsNames = For(3,Card(resini),Text (Real i) { Name(decoInitial[i]) } );
      Text brandName = Tokenizer(contribsNames[1],"_")[1];
      Set deco00 = DecoTools::Deco.BaseDefinition(decoInitial, [[
     DecoTools::@Contribution.Def(Tokenizer(Name(resini[1]),"_")[1]+"__Base" ,
Copy(Empty))
  
        ]] << EvalSet(contribsNames, Anything (Text nam) {
                   DecoTools::@Contribution.Def(nam, [[
                            DecoTools::@Contribution.Ref(nam, 0) ]] ) })
       );
  
       Set deco02 = DecoTools::GeneralizedDueTo.Period(deco00, FindCode("Serie",
"Exp"), 52); // semanal
       Set deco02M = DecoTools::Deco.Serie.DatCh(deco02, Mensual, SumS); // mensual
       Set deco02T = DecoTools::Deco.Serie.DatCh(deco02, Trimestral, SumS); //
trimestral
       Set deco02A = DecoTools::Deco.Serie.DatCh(deco02, Yearly, SumS); // anual
  
       Set a_ = [[ deco00,deco02,deco02M,deco02T,deco02A ]];
       Eval("Set "+brandName+" = a_")
  });
  
  // Esta otra función hace las decos
  
  Set decosDec = EvalSet (results, Set (Set resini){
       Set decoIni = resini;
      
    Set decoInitial = EvalSet(decoIni,Serie (Serie ser)
    {
      Set sName1 = Tokenizer(Name(ser),"_");
      Text name = If(
        sName1[Card(sName1)]=="Forecast.Mean",
        TxtListItem(sName1-[[ sName1[Card(sName1)] ]],"_"),
        {
          Set sName2 = Tokenizer(Name(ser),".");
          Text If(
            And(sName2[Card(sName2)-1]=="Forecast",sName2[Card(sName2)]=="Mean"),
            TxtListItem(sName2-[[ sName2[Card(sName2)-1] ]] -[[ sName2[Card(sName2)]
]],"."),
            Name(ser)
          )
        }
      );
      Serie Eval("Serie "+name+" = ser;")
    });
      Set contribsNames = For(3,Card(resini),Text (Real i) { Name(decoInitial[i]) } );
      Text brandName = Tokenizer(contribsNames[1],"_")[1];
      Set contribsNamesDeco = contribsNames;

      Set deco00 = DecoTools::Deco.BaseDefinition(decoInitial, [[
     DecoTools::@Contribution.Def(Tokenizer(Name(resini[1]),"_")[1]+"__Base" ,
Copy(Empty))
  
        ]] << EvalSet(contribsNamesDeco, Anything (Text nam) {
                   DecoTools::@Contribution.Def(nam, [[
                            DecoTools::@Contribution.Ref(nam, 0) ]] ) })
       );
  
  
  // deco substractiva
              Set deco03 =
DecoTools::Deco.SynergyFree(DecoTools::Deco.BaseFirstIn(deco00,
FindCode("Real", "Exp"))); // resultado en semanal
              Set deco03M = DecoTools::Deco.Serie.DatCh(deco03, Mensual, SumS); //
en mensual
              Set deco03A = DecoTools::Deco.Serie.DatCh(deco03, Yearly, SumS); // en
anual
  
  
       Set a_ = [[ deco00,deco03,deco03M,deco03A]];
       Eval("Set "+brandName+" = a_")
  });


// Domingo, 2011/09/25 21:12:33.00
Set sm2::GetObservations.WithForecast.Mean.SequentialDueTo(Empty);

// Domingo, 2011/09/25 21:05:11.00
Set sm2::GetObservations.WithForecast.Mean.Decomposition(Empty);

// Domingo, 2011/09/25 21:01:45.00
Set sm2::GetObservations.Forecast.Mean.Decomposition(Empty);

// Domingo, 2011/09/25 21:00:45.00
NameBlock sm2 = m2::GetSubmodel(1);

// Domingo, 2011/09/25 21:00:19.00
NameBlock m2 = forecast::GetModel.Forecast(1);

// Domingo, 2011/09/25 20:58:29.00
NameBlock sm1 = m1::GetSubmodel(1);

// Domingo, 2011/09/25 20:58:02.00
NameBlock sm1 = m1::GetSubModel(1);

// Domingo, 2011/09/25 20:57:45.00
NameBlock m1 = forecast::GetModel(1);


// Domingo, 2011/09/25 20:49:56.00
Set sOutputsResults = simF::GetInfoOutputResults(?);

// Domingo, 2011/09/25 20:45:20.00
MMS::@Forecast forecast = MMS::Container::LoadFile(path<<"For.Preco.63.Mensual_19092011__1.0.oza");

// Domingo, 2011/09/25 20:44:58.00
MMS::@Forecast forecast = MMS::Container::Loadfile(path<<"For.Preco.63.Mensual_19092011__1.0.oza");

NameBlock MMS::Container


// Domingo, 2011/09/25 20:44:17.00
MMS::@Forecast forecast = MMS::Container::Loadfile(path<<"For.Preco.63.Mensual_19092011__1.0.oza");


// Domingo, 2011/09/25 20:43:36.00
Text path = GetAbsolutePath("./");
MMS::@Forecast forecast = MMS::Container::Loadfile(path
  <<"For.Preco.63.Mensual_19092011__1.0.oza");

// Domingo, 2011/09/25 20:43:27.00
Text path = GetAbsolutePath("./");
MMS::@Forecast forecast = MMS::Container::Loadfile(path

// Domingo, 2011/09/25 20:43:16.00
#Require MmsInBws;

// Sunday, 2011/09/25 20:35:53.00
#Require MMS;



// Monday, 2011/09/19 15:00:43.00
Real OSDirMake( "/tmp/kk" );


// Monday, 2011/09/19 15:00:43.00
Real OSDirMake( "/tmp/kk" );


// Monday, 2011/09/19 15:00:42.00
Real OSDirMake( "/tmp/kk" );


// Monday, 2011/09/19 15:00:40.00
Real OSDirMake( "/tmp/kk" );


// Monday, 2011/09/19 14:41:15.00
#Require MMS


// Friday, 2011/09/16 11:38:01.00
NameBlock nb = [[
  Class @InputDef {
     Real a = 1
  }
]];

nb::@InputDef ll = [[ Real a = 1 ]];

// Friday, 2011/09/16 11:36:57.00
nb::@InputDef ll = [[ Real a = 1 ]];

// Friday, 2011/09/16 11:36:53.00
NameBlock nb = [[
  Class @InputDef {
     Real a = 1
  }
]];

// Friday, 2011/09/16 11:36:42.00
NameBlock nb = [[
  Class @InputDef {
     Real a = 1;
  }
]];

// Thursday, 2011/09/15 14:13:32.00
Code Show


// Tuesday, 2011/09/13 16:36:42.00
#Require TolExcel;



// Tuesday, 2011/09/13 15:47:19.00
Real KModels = 10;
Real MModels = 20;
Real HFor    = 15;

Matrix a = Rand(1,1,0,0);
Matrix A = SetRow(NCopy(MModels, 1));


TimeSet Tms  = C-WD(7);
Date IniDate = y2000m01d01;
Real NumData = 312*3;
Date EndDate = Succ(IniDate, Tms, NumData);

Date iniFor     = Succ(EndDate, Tms, 1); 
Date endFor     = Succ(EndDate, Tms, HFor);


// Constructions of m zj ARIMA models

Set RandSeed = For(1, MModels, Real(Real h)
{
  Rand(0,0.15)
});

Set SetMA  = For(1, MModels, Polyn(Real h)
{
  RandStationary(1, 6)
});

Set SetARI = For(1, MModels, Polyn(Real h)
{
  (1-B^6)*RandStationary(1, 1)*RandStationary(1, 312)
});

Set SetRes = For(1, MModels, Serie(Real h)
{
  SubSer(Gaussian(0, RandSeed[h] , Tms), IniDate, EndDate)
});

Set SetNoise =  For(1, MModels, Serie(Real h)
{
  Serie residuals = SetRes[h];
  Polyn ma        = SetMA[h];
  Polyn ari       = SetARI[h];
  Real level      = Rand(0,1);

  Date ini0       = Succ(IniDate, Tms, -Degree(ari));
  Date end0       = Succ(IniDate, Tms, -1);  
  Serie iniRes    = SubSer(Gaussian(0, 0.5 , Tms)+level, ini0, end0);
  Serie noise     = ma:DifEq(1/ari, residuals, iniRes);
  noise
});

Set SetFor = For(1, MModels, Serie(Real h)
{
  Serie residuals = SetRes[h];
  Polyn ma        = SetMA[h];
  Polyn ari       = SetARI[h];
  Real level      = Rand(1,3);
  Serie noise     = SetNoise[h];

  Date iniFor     = Succ(EndDate, Tms, 1); 
  Date endFor     = Succ(EndDate, Tms, HFor);
 
  Serie zero      = SubSer(CalInd(W, Tms), iniFor, endFor); 
  Serie inoise    = SubSer(noise, 
   Succ(EndDate, Tms, -Degree(ari)-1), EndDate);
  Serie prevNoise = ma:DifEq(1/ari, zero, inoise);
  SubSer(Exp(prevNoise), iniFor, endFor)
});

// Constructions k probit models
// To simulate these models we use the fact that w = X*beta + e with e~N(0,1)
// and y = 1 if w>0 else 0

Set SetPSimRes = For(1, KModels, Serie(Real h)
{
  SubSer(Gaussian(0, 1 , Tms), IniDate, EndDate)
});

Set SetPSimW = For(1, KModels, Set(Real h)
{
  Serie residuals = SetPSimRes[h];
  Set effectSet   = For(1, 5, Serie(Real k)
  {
    (1/k)*SubSer(Gaussian(0, 0.2, Tms), IniDate,  endFor)
  });
  Serie filter = SetSum(effectSet);
  Serie w = residuals+filter;
  SetOfSerie(filter, w)
});

Set SetPSimYFor = For(1, KModels, Set(Real h)
{
  Set reg = SetPSimW[h];
  Serie filter = reg[1];
  Serie w      = reg[2];
  
  Serie y      = GT(w,CalInd(W, Tms));
  Serie pRes   = y-F01(filter); 
  Serie pFor   = SubSer(F01(filter), iniFor, endFor);
  SetOfSerie(pFor, y, pRes)
});

Set SetPRes = Traspose(SetPSimYFor)[3];
Set SetPFor = Traspose(SetPSimYFor)[1];

// Constructions k regression models
// To simulate these models we use the fact that w = X*beta + e with e~N(0,1)
// and y = 1 if w>0 else 0

Set SetRegAux = For(1, KModels, Set(Real h)
{
  Real level = Rand(10, 100);
  Real sigma = Rand(0, 0.3);
  Real ini   = Floor(Rand(1,100));
  Real end   = Floor(Rand(1,100)); 
  Serie levelSer = level*SubSer(CalInd(C, Tms), iniFor, endFor);


  Date iniNull = Succ(IniDate, Tms, ini);
  Date endNull = Succ(EndDate, Tms, -end);

  Serie indNull   = SetPSimYFor[h][2];

  Serie residuals = 
   SubSer(Gaussian(0, sigma , Tms), Succ(IniDate, Tms, ini) , 
                                       Succ(EndDate, Tms, -end));
  Serie y = Exp(residuals*indNull+Log(level*CalInd(C, Tms)));
  TimeSet TmsNull = SerTms(indNull);
  Serie resNull   = DatCh(residuals, TmsNull, FirstS);

  SetOfAnything(levelSer, resNull, y)
});

Set SetRegRes = Traspose(SetRegAux)[2];
Set SetRegFor = Traspose(SetRegAux)[1];

// Add model

Serie AddSerie = SetSumC(EvalSet(SetNoise,Serie(Serie noise){Exp(noise)})
<<(Traspose(SetRegAux)[3]));

Set defModelAdd = @ModelDef
(
  AddSerie,
  0,0,
  0,0,
  1-(B^6),
  SetOfPolyn(1-0.1*B,1, 1-0.1*B^312),
  SetOfPolyn(1,1-0.1*B^6, 1),
  Empty,
  AllLinear
);
Set estModelAdd = Estimate(defModelAdd, IniDate, EndDate);
Set forModelAdd = CalcForecasting(estModelAdd, EndDate, EndDate, 15, 0.05);  

Serie AddRes = estModelAdd["Series"]["Residuals"];
Serie AddFor = forModelAdd["Prevision"];
Polyn AddMA  = SetProd(estModelAdd["Definition"]["MA"]);
Polyn AddARI = (estModelAdd["Definition"]["Dif"])*
        SetProd(estModelAdd["Definition"]["AR"]);

// Definition for combination

Set MAFull  = SetMA<<NCopy(2*KModels, Polyn 1)<<SetOfPolyn(AddMA);
Set ARIFull = SetARI<<NCopy(2*KModels, Polyn 1)<<SetOfPolyn(AddARI);
Set ResFull = SetRes<<SetPRes<<SetRegRes<<SetOfSerie(AddRes);
Set ForFull = SetFor<<SetPFor<<SetRegFor<<SetOfSerie(AddFor);


Matrix MixTra(Matrix z1) 
// Order in z1 is ARIMA models | Probit Models | Regresion models
{
  Log(SubRow(z1, Range(1, MModels, 1)))<<
  InvF01(SubRow(z1, Range(MModels+1, KModels+MModels, 1)))<<
  Log(SubRow(z1, Range(MModels+KModels+1, 2*KModels+MModels, 1)))
};

Matrix MixTraInv(Matrix z1)
// Order in z1 is ARIMA models | Probit Models | Regresion models
{
  Exp(SubRow(z1, Range(1, MModels, 1)))<<
  F01(SubRow(z1, Range(MModels+1, KModels+MModels, 1)))<<
  Exp(SubRow(z1, Range(MModels+KModels+1, 2*KModels+MModels, 1)))
};


Set SetTra    = MLHTransf(MixTra, MatLog);
Set SetInvTra = MLHTransf(MixTraInv, MatExp);
  
Matrix covMatFull = MLH_Cov(ResFull, Tms);


Set InfoNLC = MLHInfo
(
  ResFull,
  ForFull,
  MAFull,
  ARIFull,
  SetTra,
  SetInvTra
);

Matrix MixRel(Matrix z1, Set paramSet)
{
  Real m = paramSet[1];
  Real k = paramSet[2];
  
  Matrix onem = Rand(1, m, 1, 1); 
  Matrix z = SubRow(z1, Range(1, m, 1));
  Matrix p = SubRow(z1, Range(m+1, m+k, 1));
  Matrix w = SubRow(z1, Range(m+k+1, 2*k+m, 1)); 

//Real Msg("onem", ""<<onem);  
//Real Msg("z", ""<<z);  
//Real Msg("P", ""<<p);  
//Real Msg("W", ""<<w);  

  Matrix z2 = onem*z+Tra(p)*w;
//Real Msg("z2", ""<<z2);  
  z2
};

Real dim1       = 2*KModels+MModels; 
Real dim2       = 1;
Set SetRel      = MLHRelation(MixRel, SetOfReal(MModels, KModels), dim1, dim2);
Set SetRelTrans = NCopy(HFor, SetRel);
Text Msg_Trace = "Off";
Set ComResult = MLH_ForComb_Rel
(
  InfoNLC, 
  SetRelTrans,
  "Tms",
  0
);

Serie sumForCom = SetSum(ExtractByIndex(ComResult, Range(1, MModels,1)))+
SetSum(EvalSet(Range(MModels+1, MModels+KModels, 1), Serie(Real k)
{
  ComResult[k]*ComResult[k+KModels]
}));
Serie sumCom    = ComResult[dim1+dim2];
Serie difer     = sumForCom-sumCom;


// Tuesday, 2011/09/13 15:45:54.00
Real KModels = 10;
Real HFor    = 15;

Matrix a = Rand(1,1,0,0);
Matrix A = SetRow(NCopy(KModels-1, 1));


TimeSet Tms  = C-WD(7);
Date IniDate = y2000m01d01;
Real NumData = 312*3;
Date EndDate = Succ(IniDate, Tms, NumData);


//P1_6_312DIF0_1_0AR1_0_312MA0_6_0

Set RandSeed = For(1, KModels-1, Real(Real h)
{
  Rand(0,0.15)
});

Set SetMA  = For(1, KModels-1, Polyn(Real h)
{
  RandStationary(1, 6)
});

Set SetARI = For(1, KModels-1, Polyn(Real h)
{
  (1-B^6)*RandStationary(1, 1)*RandStationary(1, 312)
});

Set SetRes = For(1, KModels-1, Serie(Real h)
{
  SubSer(Gaussian(0, RandSeed[h] , Tms), IniDate, EndDate)
});

Set SetNoise =  For(1, KModels-1, Serie(Real h)
{
  Serie residuals = SetRes[h];
  Polyn ma        = SetMA[h];
  Polyn ari       = SetARI[h];
  Real level      = Rand(0,1);

  Date ini0       = Succ(IniDate, Tms, -Degree(ari));
  Date end0       = Succ(IniDate, Tms, -1);  
  Serie iniRes    = SubSer(Gaussian(0, 0.5 , Tms)+level, ini0, end0);
  Serie noise     = ma:DifEq(1/ari, residuals, iniRes);
  noise
});

Set SetFor = For(1, KModels-1, Serie(Real h)
{
  Serie residuals = SetRes[h];
  Polyn ma        = SetMA[h];
  Polyn ari       = SetARI[h];
  Real level      = Rand(1,3);
  Serie noise     = SetNoise[h];

  Date iniFor     = Succ(EndDate, Tms, 1); 
  Date endFor     = Succ(EndDate, Tms, HFor);
 
  Serie zero      = SubSer(CalInd(W, Tms), iniFor, endFor); 
  Serie inoise    = SubSer(noise, 
   Succ(EndDate, Tms, -Degree(ari)-1), EndDate);
  Serie prevNoise = ma:DifEq(1/ari, zero, inoise);
  SubSer(Exp(prevNoise), iniFor, endFor)
});

Serie AddSerie = SetSum(EvalSet(SetNoise,Serie(Serie noise){Exp(noise)}));
Set defModelAdd = @ModelDef
(
  AddSerie,
  0,0,
  0,0,
  1-(B^6),
  SetOfPolyn(1-0.1*B,1, 1-0.1*B^312),
  SetOfPolyn(1,1-0.1*B^6, 1),
  Empty,
  AllLinear
);
Set estModelAdd = Estimate(defModelAdd, IniDate, EndDate);
Set forModelAdd = CalcForecasting(estModelAdd, EndDate, EndDate, 15, 0.05);  
Serie AddRes = estModelAdd["Series"]["Residuals"];
Serie AddFor = forModelAdd["Prevision"];
Polyn AddMA  = SetProd(estModelAdd["Definition"]["MA"]);
Polyn AddARI = (estModelAdd["Definition"]["Dif"])*
        SetProd(estModelAdd["Definition"]["AR"]);

Set MAFull  = SetMA<<SetOfPolyn(AddMA);
Set ARIFull = SetARI<<SetOfPolyn(AddARI);
Set ResFull = SetRes<<SetOfSerie(AddRes);
Set ForFull = SetFor<<SetOfSerie(AddFor);

Set SetTra    = MLHTransf(MatLog, MatLog);
Set SetInvTra = MLHTransf(MatExp, MatExp);
  

Set InfoNLC = MLHInfo
(
  ResFull,
  ForFull,
  MAFull,
  ARIFull,
  SetTra,
  SetInvTra
);

Set LinTrans = MLHConstrain(A, a);
Set SetLinTrans = NCopy(HFor, LinTrans);
Set ComResult = MLH_ForComb_LinRel
(
  InfoNLC, 
  SetLinTrans,
  "",
  0
);

Set ComResultFixed = MLH_ForComb_AgRelWithFixed
(
  InfoNLC, 
  LinTrans,
  SetOfReal(1,10),
  0 
);

Serie sumForCom = SetSum(ExtractByIndex(ComResult, Range(1, KModels-1,1)));
Serie sumCom    = ComResult[KModels];
Serie difer     = sumForCom-sumCom;
*/

////////////////////////////////////////////////////////////////////////////// 
// Test for ARIMA model combination with non-linear relation
// 
// Note: This is a special case in wich we have the follow relation
//       z1+...+zm+p1*w1+p2*w2+...+pk*wk = zn
//       Where pi are probit models in Tms TimeSet, wk are regression 
//       models in several TimeSet harmonic with Tms and zj are log-ARIMA models
//       in Daily Tms 
//////////////////////////////////////////////////////////////////////////////
/*
Real KModels = 10;
Real MModels = 20;
Real HFor    = 15;

Matrix a = Rand(1,1,0,0);
Matrix A = SetRow(NCopy(MModels, 1));


TimeSet Tms  = C-WD(7);
Date IniDate = y2000m01d01;
Real NumData = 312*3;
Date EndDate = Succ(IniDate, Tms, NumData);

Date iniFor     = Succ(EndDate, Tms, 1); 
Date endFor     = Succ(EndDate, Tms, HFor);


// Constructions of m zj ARIMA models

Set RandSeed = For(1, MModels, Real(Real h)
{
  Rand(0,0.15)
});

Set SetMA  = For(1, MModels, Polyn(Real h)
{
  RandStationary(1, 6)
});

Set SetARI = For(1, MModels, Polyn(Real h)
{
  (1-B^6)*RandStationary(1, 1)*RandStationary(1, 312)
});

Set SetRes = For(1, MModels, Serie(Real h)
{
  SubSer(Gaussian(0, RandSeed[h] , Tms), IniDate, EndDate)
});

Set SetNoise =  For(1, MModels, Serie(Real h)
{
  Serie residuals = SetRes[h];
  Polyn ma        = SetMA[h];
  Polyn ari       = SetARI[h];
  Real level      = Rand(0,1);

  Date ini0       = Succ(IniDate, Tms, -Degree(ari));
  Date end0       = Succ(IniDate, Tms, -1);  
  Serie iniRes    = SubSer(Gaussian(0, 0.5 , Tms)+level, ini0, end0);
  Serie noise     = ma:DifEq(1/ari, residuals, iniRes);
  noise
});

Set SetFor = For(1, MModels, Serie(Real h)
{
  Serie residuals = SetRes[h];
  Polyn ma        = SetMA[h];
  Polyn ari       = SetARI[h];
  Real level      = Rand(1,3);
  Serie noise     = SetNoise[h];

  Date iniFor     = Succ(EndDate, Tms, 1); 
  Date endFor     = Succ(EndDate, Tms, HFor);
 
  Serie zero      = SubSer(CalInd(W, Tms), iniFor, endFor); 
  Serie inoise    = SubSer(noise, 
   Succ(EndDate, Tms, -Degree(ari)-1), EndDate);
  Serie prevNoise = ma:DifEq(1/ari, zero, inoise);
  SubSer(Exp(prevNoise), iniFor, endFor)
});

// Constructions k probit models
// To simulate these models we use the fact that w = X*beta + e with e~N(0,1)
// and y = 1 if w>0 else 0

Set SetPSimRes = For(1, KModels, Serie(Real h)
{
  SubSer(Gaussian(0, 1 , Tms), IniDate, EndDate)
});

Set SetPSimW = For(1, KModels, Set(Real h)
{
  Serie residuals = SetPSimRes[h];
  Set effectSet   = For(1, 5, Serie(Real k)
  {
    (1/k)*SubSer(Gaussian(0, 0.2, Tms), IniDate,  endFor)
  });
  Serie filter = SetSum(effectSet);
  Serie w = residuals+filter;
  SetOfSerie(filter, w)
});

Set SetPSimYFor = For(1, KModels, Set(Real h)
{
  Set reg = SetPSimW[h];
  Serie filter = reg[1];
  Serie w      = reg[2];
  
  Serie y      = GT(w,CalInd(W, Tms));
  Serie pRes   = y-F01(filter); 
  Serie pFor   = SubSer(F01(filter), iniFor, endFor);
  SetOfSerie(pFor, y, pRes)
});

Set SetPRes = Traspose(SetPSimYFor)[3];
Set SetPFor = Traspose(SetPSimYFor)[1];

// Constructions k regression models
// To simulate these models we use the fact that w = X*beta + e with e~N(0,1)
// and y = 1 if w>0 else 0

Set SetRegAux = For(1, KModels, Set(Real h)
{
  Real level = Rand(10, 100);
  Real sigma = Rand(0, 0.3);
  Real ini   = Floor(Rand(1,100));
  Real end   = Floor(Rand(1,100)); 
  Serie levelSer = level*SubSer(CalInd(C, Tms), iniFor, endFor);


  Date iniNull = Succ(IniDate, Tms, ini);
  Date endNull = Succ(EndDate, Tms, -end);

  Serie indNull   = SetPSimYFor[h][2];

  Serie residuals = 
   SubSer(Gaussian(0, sigma , Tms), Succ(IniDate, Tms, ini) , 
                                       Succ(EndDate, Tms, -end));
  Serie y = Exp(residuals*indNull+Log(level*CalInd(C, Tms)));
  TimeSet TmsNull = SerTms(indNull);
  Serie resNull   = DatCh(residuals, TmsNull, FirstS);

  SetOfAnything(levelSer, resNull, y)
});

Set SetRegRes = Traspose(SetRegAux)[2];
Set SetRegFor = Traspose(SetRegAux)[1];

// Add model

Serie AddSerie = SetSumC(EvalSet(SetNoise,Serie(Serie noise){Exp(noise)})
<<(Traspose(SetRegAux)[3]));

Set defModelAdd = @ModelDef
(
  AddSerie,
  0,0,
  0,0,
  1-(B^6),
  SetOfPolyn(1-0.1*B,1, 1-0.1*B^312),
  SetOfPolyn(1,1-0.1*B^6, 1),
  Empty,
  AllLinear
);
Set estModelAdd = Estimate(defModelAdd, IniDate, EndDate);
Set forModelAdd = CalcForecasting(estModelAdd, EndDate, EndDate, 15, 0.05);  

Serie AddRes = estModelAdd["Series"]["Residuals"];
Serie AddFor = forModelAdd["Prevision"];
Polyn AddMA  = SetProd(estModelAdd["Definition"]["MA"]);
Polyn AddARI = (estModelAdd["Definition"]["Dif"])*
        SetProd(estModelAdd["Definition"]["AR"]);

// Definition for combination

Set MAFull  = SetMA<<NCopy(2*KModels, Polyn 1)<<SetOfPolyn(AddMA);
Set ARIFull = SetARI<<NCopy(2*KModels, Polyn 1)<<SetOfPolyn(AddARI);
Set ResFull = SetRes<<SetPRes<<SetRegRes<<SetOfSerie(AddRes);
Set ForFull = SetFor<<SetPFor<<SetRegFor<<SetOfSerie(AddFor);


Matrix MixTra(Matrix z1) 
// Order in z1 is ARIMA models | Probit Models | Regresion models
{
  Log(SubRow(z1, Range(1, MModels, 1)))<<
  InvF01(SubRow(z1, Range(MModels+1, KModels+MModels, 1)))<<
  Log(SubRow(z1, Range(MModels+KModels+1, 2*KModels+MModels, 1)))
};

Matrix MixTraInv(Matrix z1)
// Order in z1 is ARIMA models | Probit Models | Regresion models
{
  Exp(SubRow(z1, Range(1, MModels, 1)))<<
  F01(SubRow(z1, Range(MModels+1, KModels+MModels, 1)))<<
  Exp(SubRow(z1, Range(MModels+KModels+1, 2*KModels+MModels, 1)))
};


Set SetTra    = MLHTransf(MixTra, MatLog);
Set SetInvTra = MLHTransf(MixTraInv, MatExp);
  
Matrix covMatFull = MLH_Cov(ResFull, Tms);


Set InfoNLC = MLHInfo
(
  ResFull,
  ForFull,
  MAFull,
  ARIFull,
  SetTra,
  SetInvTra
);

Matrix MixRel(Matrix z1, Set paramSet)
{
  Real m = paramSet[1];
  Real k = paramSet[2];
  
  Matrix onem = Rand(1, m, 1, 1); 
  Matrix z = SubRow(z1, Range(1, m, 1));
  Matrix p = SubRow(z1, Range(m+1, m+k, 1));
  Matrix w = SubRow(z1, Range(m+k+1, 2*k+m, 1)); 

//Real Msg("onem", ""<<onem);  
//Real Msg("z", ""<<z);  
//Real Msg("P", ""<<p);  
//Real Msg("W", ""<<w);  

  Matrix z2 = onem*z+Tra(p)*w;
//Real Msg("z2", ""<<z2);  
  z2
};

Real dim1       = 2*KModels+MModels; 
Real dim2       = 1;
Set SetRel      = MLHRelation(MixRel, SetOfReal(MModels, KModels), dim1, dim2);
Set SetRelTrans = NCopy(HFor, SetRel);
Text Msg_Trace = "Off";
Set ComResult = MLH_ForComb_Rel
(
  InfoNLC, 
  SetRelTrans,
  "Tms",
  0
);

Serie sumForCom = SetSum(ExtractByIndex(ComResult, Range(1, MModels,1)))+
SetSum(EvalSet(Range(MModels+1, MModels+KModels, 1), Serie(Real k)
{
  ComResult[k]*ComResult[k+KModels]
}));
Serie sumCom    = ComResult[dim1+dim2];
Serie difer     = sumForCom-sumCom;


// Tuesday, 2011/09/13 15:45:28.00
//////////////////////////////////////////////////////////////////////////////
// FUNCTIONS
//////////////////////////////////////////////////////////////////////////////
Matrix MatLog(Matrix z){Log(z)};

Matrix MatExp(Matrix z){Exp(z)};

Matrix MatId(Matrix z){z};

//////////////////////////////////////////////////////////////////////////////
Real DefTrace(Text grammar, Text var, Text value)
//////////////////////////////////////////////////////////////////////////////
{
  Real exist = ObjectExist(grammar, var);
  If(exist,
  {
//    Text WriteLn("[DefCtr]:["+var+"]: Existe y su valor es "<<Eval(var)+
//                 ". Su nuevo valor es "<<Eval(grammar+" "+value+";"));
    Eval(grammar+" ("+var+":= "+value+");");
    exist
  },
  {
//    Text WriteLn("[DefCtr]:["+var+"]: No existe.");
    exist
  })
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Traza las variables parametricas de definicion.",
DefTrace);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Real NumTolerance = 4;
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Tolerancia del algoritmo de estimacion.",
Tolerance);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// PROCEDURES
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Marquardt's Control Parameters
//////////////////////////////////////////////////////////////////////////////
Set MarqVarSet = SetOfSet
(
  SetOfText("Real", "Tolerance", "5*(10^(-NumTolerance))"),
  SetOfText("Real", "RelativeTolerance","10^(-NumTolerance+1)"),
  SetOfText("Real", "DiffDist", "0.0001"),
  SetOfText("Real", "MarqFactor", "2"),
  SetOfText("Real", "MinOutlierLikelyhood", "4"),
  SetOfText("Real", "MarqLinMet", "Copy(Choleski)"),
  SetOfText("Real", "MaxIter", "30"),
  SetOfText("Real", "DoDiagnostics","1"),// Tiene que estar a 1 en Tolbase
  SetOfText("Real", "DoStatistics", "0"),
  SetOfText("Real", "NullInitResiduals", "1")
);
Set MarqVarEval = EvalSet(MarqVarSet, Real(Set reg)
{
  Text grammar = reg[1]; 
  Text var     = reg[2];
  Text value   = reg[3];
  DefTrace(grammar, var, value) 
});



// Tuesday, 2011/09/13 15:44:49.00



// Tuesday, 2011/09/13 15:44:25.00
Real KModels = 10;
Real MModels = 20;
Real HFor    = 15;

Matrix a = Rand(1,1,0,0);
Matrix A = SetRow(NCopy(MModels, 1));


TimeSet Tms  = C-WD(7);
Date IniDate = y2000m01d01;
Real NumData = 312*3;
Date EndDate = Succ(IniDate, Tms, NumData);

Date iniFor     = Succ(EndDate, Tms, 1); 
Date endFor     = Succ(EndDate, Tms, HFor);


// Constructions of m zj ARIMA models

Set RandSeed = For(1, MModels, Real(Real h)
{
  Rand(0,0.15)
});

Set SetMA  = For(1, MModels, Polyn(Real h)
{
  RandStationary(1, 6)
});

Set SetARI = For(1, MModels, Polyn(Real h)
{
  (1-B^6)*RandStationary(1, 1)*RandStationary(1, 312)
});

Set SetRes = For(1, MModels, Serie(Real h)
{
  SubSer(Gaussian(0, RandSeed[h] , Tms), IniDate, EndDate)
});

Set SetNoise =  For(1, MModels, Serie(Real h)
{
  Serie residuals = SetRes[h];
  Polyn ma        = SetMA[h];
  Polyn ari       = SetARI[h];
  Real level      = Rand(0,1);

  Date ini0       = Succ(IniDate, Tms, -Degree(ari));
  Date end0       = Succ(IniDate, Tms, -1);  
  Serie iniRes    = SubSer(Gaussian(0, 0.5 , Tms)+level, ini0, end0);
  Serie noise     = ma:DifEq(1/ari, residuals, iniRes);
  noise
});

Set SetFor = For(1, MModels, Serie(Real h)
{
  Serie residuals = SetRes[h];
  Polyn ma        = SetMA[h];
  Polyn ari       = SetARI[h];
  Real level      = Rand(1,3);
  Serie noise     = SetNoise[h];

  Date iniFor     = Succ(EndDate, Tms, 1); 
  Date endFor     = Succ(EndDate, Tms, HFor);
 
  Serie zero      = SubSer(CalInd(W, Tms), iniFor, endFor); 
  Serie inoise    = SubSer(noise, 
   Succ(EndDate, Tms, -Degree(ari)-1), EndDate);
  Serie prevNoise = ma:DifEq(1/ari, zero, inoise);
  SubSer(Exp(prevNoise), iniFor, endFor)
});

// Constructions k probit models
// To simulate these models we use the fact that w = X*beta + e with e~N(0,1)
// and y = 1 if w>0 else 0

Set SetPSimRes = For(1, KModels, Serie(Real h)
{
  SubSer(Gaussian(0, 1 , Tms), IniDate, EndDate)
});

Set SetPSimW = For(1, KModels, Set(Real h)
{
  Serie residuals = SetPSimRes[h];
  Set effectSet   = For(1, 5, Serie(Real k)
  {
    (1/k)*SubSer(Gaussian(0, 0.2, Tms), IniDate,  endFor)
  });
  Serie filter = SetSum(effectSet);
  Serie w = residuals+filter;
  SetOfSerie(filter, w)
});

Set SetPSimYFor = For(1, KModels, Set(Real h)
{
  Set reg = SetPSimW[h];
  Serie filter = reg[1];
  Serie w      = reg[2];
  
  Serie y      = GT(w,CalInd(W, Tms));
  Serie pRes   = y-F01(filter); 
  Serie pFor   = SubSer(F01(filter), iniFor, endFor);
  SetOfSerie(pFor, y, pRes)
});

Set SetPRes = Traspose(SetPSimYFor)[3];
Set SetPFor = Traspose(SetPSimYFor)[1];

// Constructions k regression models
// To simulate these models we use the fact that w = X*beta + e with e~N(0,1)
// and y = 1 if w>0 else 0

Set SetRegAux = For(1, KModels, Set(Real h)
{
  Real level = Rand(10, 100);
  Real sigma = Rand(0, 0.3);
  Real ini   = Floor(Rand(1,100));
  Real end   = Floor(Rand(1,100)); 
  Serie levelSer = level*SubSer(CalInd(C, Tms), iniFor, endFor);


  Date iniNull = Succ(IniDate, Tms, ini);
  Date endNull = Succ(EndDate, Tms, -end);

  Serie indNull   = SetPSimYFor[h][2];

  Serie residuals = 
   SubSer(Gaussian(0, sigma , Tms), Succ(IniDate, Tms, ini) , 
                                       Succ(EndDate, Tms, -end));
  Serie y = Exp(residuals*indNull+Log(level*CalInd(C, Tms)));
  TimeSet TmsNull = SerTms(indNull);
  Serie resNull   = DatCh(residuals, TmsNull, FirstS);

  SetOfAnything(levelSer, resNull, y)
});

Set SetRegRes = Traspose(SetRegAux)[2];
Set SetRegFor = Traspose(SetRegAux)[1];

// Add model

Serie AddSerie = SetSumC(EvalSet(SetNoise,Serie(Serie noise){Exp(noise)})
<<(Traspose(SetRegAux)[3]));

Set defModelAdd = @ModelDef
(
  AddSerie,
  0,0,
  0,0,
  1-(B^6),
  SetOfPolyn(1-0.1*B,1, 1-0.1*B^312),
  SetOfPolyn(1,1-0.1*B^6, 1),
  Empty,
  AllLinear
);
Set estModelAdd = Estimate(defModelAdd, IniDate, EndDate);
Set forModelAdd = CalcForecasting(estModelAdd, EndDate, EndDate, 15, 0.05);  

Serie AddRes = estModelAdd["Series"]["Residuals"];
Serie AddFor = forModelAdd["Prevision"];
Polyn AddMA  = SetProd(estModelAdd["Definition"]["MA"]);
Polyn AddARI = (estModelAdd["Definition"]["Dif"])*
        SetProd(estModelAdd["Definition"]["AR"]);

// Definition for combination

Set MAFull  = SetMA<<NCopy(2*KModels, Polyn 1)<<SetOfPolyn(AddMA);
Set ARIFull = SetARI<<NCopy(2*KModels, Polyn 1)<<SetOfPolyn(AddARI);
Set ResFull = SetRes<<SetPRes<<SetRegRes<<SetOfSerie(AddRes);
Set ForFull = SetFor<<SetPFor<<SetRegFor<<SetOfSerie(AddFor);


Matrix MixTra(Matrix z1) 
// Order in z1 is ARIMA models | Probit Models | Regresion models
{
  Log(SubRow(z1, Range(1, MModels, 1)))<<
  InvF01(SubRow(z1, Range(MModels+1, KModels+MModels, 1)))<<
  Log(SubRow(z1, Range(MModels+KModels+1, 2*KModels+MModels, 1)))
};

Matrix MixTraInv(Matrix z1)
// Order in z1 is ARIMA models | Probit Models | Regresion models
{
  Exp(SubRow(z1, Range(1, MModels, 1)))<<
  F01(SubRow(z1, Range(MModels+1, KModels+MModels, 1)))<<
  Exp(SubRow(z1, Range(MModels+KModels+1, 2*KModels+MModels, 1)))
};


Set SetTra    = MLHTransf(MixTra, MatLog);
Set SetInvTra = MLHTransf(MixTraInv, MatExp);
  
Matrix covMatFull = MLH_Cov(ResFull, Tms);


Set InfoNLC = MLHInfo
(
  ResFull,
  ForFull,
  MAFull,
  ARIFull,
  SetTra,
  SetInvTra
);

Matrix MixRel(Matrix z1, Set paramSet)
{
  Real m = paramSet[1];
  Real k = paramSet[2];
  
  Matrix onem = Rand(1, m, 1, 1); 
  Matrix z = SubRow(z1, Range(1, m, 1));
  Matrix p = SubRow(z1, Range(m+1, m+k, 1));
  Matrix w = SubRow(z1, Range(m+k+1, 2*k+m, 1)); 

//Real Msg("onem", ""<<onem);  
//Real Msg("z", ""<<z);  
//Real Msg("P", ""<<p);  
//Real Msg("W", ""<<w);  

  Matrix z2 = onem*z+Tra(p)*w;
//Real Msg("z2", ""<<z2);  
  z2
};

Real dim1       = 2*KModels+MModels; 
Real dim2       = 1;
Set SetRel      = MLHRelation(MixRel, SetOfReal(MModels, KModels), dim1, dim2);
Set SetRelTrans = NCopy(HFor, SetRel);
Text Msg_Trace = "Off";
Set ComResult = MLH_ForComb_Rel
(
  InfoNLC, 
  SetRelTrans,
  "Tms",
  0
);

Serie sumForCom = SetSum(ExtractByIndex(ComResult, Range(1, MModels,1)))+
SetSum(EvalSet(Range(MModels+1, MModels+KModels, 1), Serie(Real k)
{
  ComResult[k]*ComResult[k+KModels]
}));
Serie sumCom    = ComResult[dim1+dim2];
Serie difer     = sumForCom-sumCom;


// Tuesday, 2011/09/13 15:41:37.00
Real KModels = 10;
Real HFor    = 15;

Matrix a = Rand(1,1,0,0);
Matrix A = SetRow(NCopy(KModels-1, 1));


TimeSet Tms  = C-WD(7);
Date IniDate = y2000m01d01;
Real NumData = 312*3;
Date EndDate = Succ(IniDate, Tms, NumData);


//P1_6_312DIF0_1_0AR1_0_312MA0_6_0

Set RandSeed = For(1, KModels-1, Real(Real h)
{
  Rand(0,0.15)
});

Set SetMA  = For(1, KModels-1, Polyn(Real h)
{
  RandStationary(1, 6)
});

Set SetARI = For(1, KModels-1, Polyn(Real h)
{
  (1-B^6)*RandStationary(1, 1)*RandStationary(1, 312)
});

Set SetRes = For(1, KModels-1, Serie(Real h)
{
  SubSer(Gaussian(0, RandSeed[h] , Tms), IniDate, EndDate)
});

Set SetNoise =  For(1, KModels-1, Serie(Real h)
{
  Serie residuals = SetRes[h];
  Polyn ma        = SetMA[h];
  Polyn ari       = SetARI[h];
  Real level      = Rand(0,1);

  Date ini0       = Succ(IniDate, Tms, -Degree(ari));
  Date end0       = Succ(IniDate, Tms, -1);  
  Serie iniRes    = SubSer(Gaussian(0, 0.5 , Tms)+level, ini0, end0);
  Serie noise     = ma:DifEq(1/ari, residuals, iniRes);
  noise
});

Set SetFor = For(1, KModels-1, Serie(Real h)
{
  Serie residuals = SetRes[h];
  Polyn ma        = SetMA[h];
  Polyn ari       = SetARI[h];
  Real level      = Rand(1,3);
  Serie noise     = SetNoise[h];

  Date iniFor     = Succ(EndDate, Tms, 1); 
  Date endFor     = Succ(EndDate, Tms, HFor);
 
  Serie zero      = SubSer(CalInd(W, Tms), iniFor, endFor); 
  Serie inoise    = SubSer(noise, 
   Succ(EndDate, Tms, -Degree(ari)-1), EndDate);
  Serie prevNoise = ma:DifEq(1/ari, zero, inoise);
  SubSer(Exp(prevNoise), iniFor, endFor)
});

Serie AddSerie = SetSum(EvalSet(SetNoise,Serie(Serie noise){Exp(noise)}));
Set defModelAdd = @ModelDef
(
  AddSerie,
  0,0,
  0,0,
  1-(B^6),
  SetOfPolyn(1-0.1*B,1, 1-0.1*B^312),
  SetOfPolyn(1,1-0.1*B^6, 1),
  Empty,
  AllLinear
);
Set estModelAdd = Estimate(defModelAdd, IniDate, EndDate);
Set forModelAdd = CalcForecasting(estModelAdd, EndDate, EndDate, 15, 0.05);  
Serie AddRes = estModelAdd["Series"]["Residuals"];
Serie AddFor = forModelAdd["Prevision"];
Polyn AddMA  = SetProd(estModelAdd["Definition"]["MA"]);
Polyn AddARI = (estModelAdd["Definition"]["Dif"])*
        SetProd(estModelAdd["Definition"]["AR"]);

Set MAFull  = SetMA<<SetOfPolyn(AddMA);
Set ARIFull = SetARI<<SetOfPolyn(AddARI);
Set ResFull = SetRes<<SetOfSerie(AddRes);
Set ForFull = SetFor<<SetOfSerie(AddFor);

Set SetTra    = MLHTransf(MatLog, MatLog);
Set SetInvTra = MLHTransf(MatExp, MatExp);
  

Set InfoNLC = MLHInfo
(
  ResFull,
  ForFull,
  MAFull,
  ARIFull,
  SetTra,
  SetInvTra
);

Set LinTrans = MLHConstrain(A, a);
Set SetLinTrans = NCopy(HFor, LinTrans);
Set ComResult = MLH_ForComb_LinRel
(
  InfoNLC, 
  SetLinTrans,
  "",
  0
);

Set ComResultFixed = MLH_ForComb_AgRelWithFixed
(
  InfoNLC, 
  LinTrans,
  SetOfReal(1,10),
  0 
);

Serie sumForCom = SetSum(ExtractByIndex(ComResult, Range(1, KModels-1,1)));
Serie sumCom    = ComResult[KModels];
Serie difer     = sumForCom-sumCom;


// Tuesday, 2011/09/13 15:41:14.00
Set nonlintest01 = For(3, 90, Set(Real n)
{
  Matrix cov  = SetDiag(Range(1,n-1,1)<<SetOfReal(0.01));
  Matrix nuZ1 = SetCol(NCopy(n-1, 2));
  Matrix nuZ2 = SetCol(NCopy(1, 5));
  
  Matrix a = Rand(1,1,0,0);
  Matrix A = SetRow(NCopy(n-1, 1));
  
  Real ini_nonlintest00 = Msg("nonlintest00", "Ini");
  Matrix nonlintest00 = MLH_Trans_LinRel
  (
    MatLog,
    MatExp,
    MatLog,
    MatExp,
    nuZ1,
    nuZ2,
    cov,
    A,
    a,
    0
  );
  Real end_nonlintest00 = (Msg("nonlintest00", "End")-ini_nonlintest00)/1000;
  SetOfReal(n, end_nonlintest00)  
});


// Tuesday, 2011/09/13 15:40:33.00
Real n = 20;

Matrix cov  = SetDiag(Range(1,n-1,1)<<SetOfReal(0.01));
Matrix nuZ1 = SetCol(NCopy(n-1, 2));
Matrix nuZ2 = SetCol(NCopy(1, 5));

Matrix a = Rand(1,1,0,0);
Matrix A = SetRow(NCopy(n-1, 1));

Matrix b = Rand(1,1,0,0);
Matrix B = SetRow(NCopy(n-1, 1)<<SetOfReal(-1));

Real ini_nonlintest00 = Msg("nonlintest00", "Ini");
Matrix nonlintest00 = MLH_Trans_LinRel
(
  MatLog,
  MatExp,
  MatLog,
  MatExp,
  nuZ1,
  nuZ2,
  cov,
  A,
  a,
  0
);
Real end_nonlintest00 = (Msg("nonlintest00", "End")-ini_nonlintest00)/1000;

Matrix lintest01 = MLH_Trans_LinRel
(
  MatId,
  MatId,
  MatId,
  MatId,
  nuZ1,
  nuZ2,
  cov,
  A,
  a,
  0
);

Matrix lintest02 = MLH_IdTrans_LinRel
(
  nuZ1<<nuZ2,
  cov,
  B,
  b
);

Matrix lintest = lintest01|lintest02;


// Tuesday, 2011/09/13 15:40:11.00
Serie res1 = SubSer(Gaussian(0, 1, Diario), y2003m01d01, y2007m12d31);
Serie res2 = SubSer(Gaussian(0, 0.5, Diario), y2003m01d01, y2007m12d31);
Serie res3 = SubSer(Gaussian(0, 0.3, Diario), y2003m01d01, y2007m12d31);


Set resSet1  = SetOfSerie(res1, res2, res3);
Matrix covMat1 = MLH_Cov(resSet1, Eval("Diario"));
Matrix covMat11 = Cov(SerSetMat(resSet1, y2003m01d01, y2007m12d31));

TimeSet CtSab = WD(6);
Serie res4 = SubSer(Gaussian(0, 1, CtSab), y2005m01d01, y2007m12d31);
Serie res5 = SubSer(Gaussian(0, 0.5, Diario), y2003m01d01, y2006m12d31);
Serie res6 = SubSer(Gaussian(0, 0.3, Diario), y2007m01d01, y2007m12d31);


Set resSet2  = SetOfSerie(res4, res5, res6);
Matrix covMat2 = MLH_Cov(resSet2, Eval("Diario"));


// Tuesday, 2011/09/13 11:59:07.00
#Require MMS;


// Saturday, 2011/09/03 11:52:27.00
#Require TolExcel


// Tuesday, 2011/08/09 11:04:20.00
Real MatSum( Matrix Exp( prov27::_.trafPropioMuni_Log) ) - Exp( prov27::_.trafProv_Log + prov27::_.pobProv_Log )

// Tuesday, 2011/08/09 11:03:41.00
Set checksim27 = For( 1, 2/*Columns( mcmc27 )*/, Real( Real cc ) {
  Matrix sim = SubCol( mcmc27, [[cc]] );
  Real MatSum( Matrix Exp(sim + prov27::_.pobMuni_Log) ) - Exp( prov27::_.trafProv_Log + prov27::_.pobProv_Log )
} );

// Tuesday, 2011/08/09 10:53:39.00
Set checksim27 = For( 1, 2/*Columns( mcmc27 )*/, Real( Real cc ) {
  Matrix sim = SubCol( mcmc27, [[cc]] );
  Real MatSum( Matrix Exp(sim + prov27::_.pobMuni_Log) ) - Exp( prov27::_.trafProv_Log )
} );



// Tuesday, 2011/08/09 10:53:12.00
Set checksim27 = For( 1, 2/*Columns( mcmc27 )*/, Real( Real cc ) {
  Matrix sim = SubCol( mcmc27, [[cc]] );
  Real MatSum( Matrix Exp(sim + prov27::_.pobMuni_Log) ) - Exp( prov27::_.trafProvLog )
} );


// Tuesday, 2011/08/09 10:52:10.00
Set checksim27 = For( 1, Columns( mcmc27 ), Real( Real cc ) {
  Matrix sim = SubCol( mcmc27, [[cc]] );
  Real MatSum( Exp(sim + prov27::_.pobMuni_Log) ) - Exp( prov27::_.trafProvLog )
} );


// Tuesday, 2011/08/09 10:50:54.00
Real Columns( mcmc27 )

// Tuesday, 2011/08/09 10:50:22.00
Set checksim27 = For( 1, Columns( mcmc27 ), Real( Real cc ), {
  Matrix sim = SubCol( mcmc27, [[cc]] );
  Real MatSum( Exp(sim + prov27::_.pobMuni_Log) ) - Exp( prov27::_.trafProvLog )
} );

// Tuesday, 2011/08/09 10:49:47.00
Set checksim27 = For( 1, Columns( mcmc27 ), Real( Real c ), {
  Matrix sim = SubCol( mcmc27, [[c]] );
  Real MatSum( Exp(sim + prov27::_.pobMuni_Log) ) - Exp( prov27::_.trafProvLog )
} );

// Jueves, 2011/08/04 11:12:02.00
Matrix aa1::GetMeanSimulated( 1000 );

// Jueves, 2011/08/04 11:11:56.00
@SimulateTrafMuniInProv aa1 =
  @SimulateTrafMuniInProv::New( 1, fInfo, iInfo );

// Jueves, 2011/08/04 11:10:14.00
Matrix ( mcmc * one )

// Jueves, 2011/08/04 11:10:04.00
Matrix ( mcmc * one ) * (1/nsim);

// Jueves, 2011/08/04 11:09:52.00
Matrix ( mcmc * one ) * 1/nsim;

// Jueves, 2011/08/04 11:09:10.00
Matrix one = Constant( Rows( mcmc ), 1, 1 );

// Jueves, 2011/08/04 11:08:52.00
Matrix mcmc = aa1::Simulate( 1000 );

// Jueves, 2011/08/04 11:08:38.00
Real nsim = 1000;

// Jueves, 2011/08/04 11:08:27.00

Matrix kk = aa1::Simulate( 1000 );

// Jueves, 2011/08/04 11:07:32.00
Matrix aa1::GetMeanSimulated( 1000 );

// Jueves, 2011/08/04 11:07:27.00
@SimulateTrafMuniInProv aa1 =
  @SimulateTrafMuniInProv::New( 1, fInfo, iInfo );

// Jueves, 2011/08/04 11:06:34.00
Matrix aa1::GetSimulatedMean( 1000 );

// Jueves, 2011/08/04 11:06:29.00
@SimulateTrafMuniInProv aa1 =
  @SimulateTrafMuniInProv::New( 1, fInfo, iInfo );

// Jueves, 2011/08/04 10:57:53.00
Matrix aa1::Simulate( 1000 );

// Jueves, 2011/08/04 10:57:30.00
@SimulateTrafMuniInProv aa1 =
  @SimulateTrafMuniInProv::New( 1, fInfo, iInfo );

// Jueves, 2011/08/04 10:57:18.00
Set iInfo = LoadMuniIndexes( "data/Tabla_muni_prov.xls" );

// Jueves, 2011/08/04 10:57:10.00
Set fInfo = LoadForecastData( datadir + "Fore__1.0.oza" );

// Jueves, 2011/08/04 10:54:54.00
Matrix c1  = Col(-1, 0.5);
Matrix c2  = Col( 1, 1.5);
Matrix MCsample = RandTruncatedMultNormal(mu, L, c1, c2, 1, 100);

// Jueves, 2011/08/04 10:54:51.00
Matrix mu  = Col(0, 2);

// Jueves, 2011/08/04 10:54:42.00
Matrix L   = Diag(2,1);

// Thursday, 2011/08/04 10:48:36.00
   Matrix mu  = Col(0, 2);
    Matrix Cov = ((1, 4/5),(4/5, 1));
    Matrix L   = Choleski(Cov);
    Matrix c1  = Col(-1, 0.5);
    Matrix c2  = Col( 1, 1.5);
    Matrix MCsample = RandTruncatedMultNormal(mu, L, c1, c2, 1, 100);




// Thursday, 2011/08/04 10:44:16.00
Real aa1::findIndexMin( ? );
Set aa1::BuildConstraints( ? );


// Thursday, 2011/08/04 10:44:13.00
@SimulateTrafMuniInProv aa1 =
  @SimulateTrafMuniInProv::New( 1, fInfo, iInfo );

// Thursday, 2011/08/04 10:41:44.00
Set aa1::BuildConstraints( ? );

// Thursday, 2011/08/04 10:41:04.00
Real aa1::findIndexMin( ? );

// Thursday, 2011/08/04 10:41:00.00
@SimulateTrafMuniInProv aa1 =
  @SimulateTrafMuniInProv::New( 1, fInfo, iInfo );

// Thursday, 2011/08/04 10:39:48.00
Real aa1::findIndexMin( ? );

// Thursday, 2011/08/04 10:39:43.00
@SimulateTrafMuniInProv aa1 =
  @SimulateTrafMuniInProv::New( 1, fInfo, iInfo );

// Thursday, 2011/08/04 10:37:24.00
Real aa1::findIndexMin( ? );


// Thursday, 2011/08/04 10:37:22.00
@SimulateTrafMuniInProv aa1 =
  @SimulateTrafMuniInProv::New( 1, fInfo, iInfo );



// Thursday, 2011/08/04 10:35:04.00
Real aa1::findIndexMin( ? );

// Thursday, 2011/08/04 10:35:00.00
@SimulateTrafMuniInProv aa1 =
  @SimulateTrafMuniInProv::New( 1, fInfo, iInfo );

// Thursday, 2011/08/04 10:33:29.00
Real aa1::findIndexMin( ? );

// Thursday, 2011/08/04 10:33:22.00
@SimulateTrafMuniInProv aa1 =
  @SimulateTrafMuniInProv::New( 1, fInfo, iInfo );



// Thursday, 2011/08/04 10:33:08.00
Set iInfo = LoadMuniIndexes( "data/Tabla_muni_prov.xls" );

// Thursday, 2011/08/04 10:32:51.00
Set fInfo = LoadForecastData( 1 );

// Thursday, 2011/08/04 10:32:00.00
@SimulateTrafMuniInProv aa1 =
  @SimulateTrafMuniInProv::New( 1, fInfo, iInfo );

// Thursday, 2011/08/04 10:31:08.00
Real aa1::findIndexMin( ? );


// Thursday, 2011/08/04 10:30:41.00
@SimulateTrafMuniInProv aa1 =
  @SimulateTrafMuniInProv::New( 1, fInfo, iInfo );

// Thursday, 2011/08/04 10:30:28.00
Set iInfo = LoadMuniIndexes( "data/Tabla_muni_prov.xls" );

// Thursday, 2011/08/04 10:30:26.00
Set fInfo = LoadForecastData( datadir + "Fore__1.0.oza" );

// Thursday, 2011/08/04 10:27:14.00
@SimulateTrafMuniInProv aa1 =
  @SimulateTrafMuniInProv::New( 1, fInfo, iInfo );

// Thursday, 2011/08/04 10:26:45.00
Set iInfo = LoadMuniIndexes( "data/Tabla_muni_prov.xls" );

// Thursday, 2011/08/04 10:26:41.00
Set fInfo = LoadForecastData( datadir + "Fore__1.0.oza" );

// Wednesday, 2011/08/03 19:23:54.00
Matrix M2 = fInfo[ 6 ] $/ (fInfo[ 5 ] + fInfo[ 4]);

// Wednesday, 2011/08/03 19:16:05.00
Matrix M1 = (fInfo[ 5 ] + fInfo[ 4]) | fInfo[ 6 ];


// Wednesday, 2011/08/03 19:12:18.00
Set fInfo = LoadForecastData( datadir + "Fore__1.0.oza" );

// Wednesday, 2011/08/03 19:11:00.00
Set fInfo = LoadForecastData( GetAbsolutePath(".") + "/data/Fore__1.0.oza" );

// Wednesday, 2011/08/03 15:24:23.00
@SimulateTrafMuniInProv aa50 =
  @SimulateTrafMuniInProv::New( 50, fInfo, iInfo );

// Wednesday, 2011/08/03 15:21:00.00
@SimulateTrafMuniInProv aa50 =
  @SimulateTrafMuniInProv::New( 50, fInfo, iInfo );

// Wednesday, 2011/08/03 15:20:48.00
@SimulateTrafMuniInProv aa50 =
  @SimulateTrafMuniInProv::New( 50, fInfo, iInfo );


// Wednesday, 2011/08/03 15:18:27.00
@SimulateTrafMuniInProv aa50 =
  @SimulateTrafMuniInProv::New( 50, fInfo, iInfo );


// Wednesday, 2011/08/03 15:17:48.00
@SimulateTrafMuniInProv aa50 =
  @SimulateTrafMuniInProv::New( 50, fInfo, iInfo );

// Wednesday, 2011/08/03 15:16:59.00
@SimulateTrafMuniInProv aa =
  @SimulateTrafMuniInProv::New( 1, fInfo, iInfo );

// Wednesday, 2011/08/03 15:14:39.00
@SimulateTrafMuniInProv aa =
  @SimulateTrafMuniInProv::New( 1, fInfo, iInfo );

// Wednesday, 2011/08/03 15:14:23.00
Set fInfo = LoadForecastData( 1 );
Set iInfo = LoadMuniIndexes( "data/Tabla_muni_prov.xls" );

// Wednesday, 2011/08/03 15:12:59.00
@SimulateTrafMuniInProv aa =
  @SimulateTrafMuniInProv::New( 1, fInfo, iInfo );

// Wednesday, 2011/08/03 15:12:23.00
@SimulateTrafMuniInProv aa =
  @SimulateTrafMuniInProv::New( 1, fInfo, iInfo );

// Wednesday, 2011/08/03 15:10:42.00
Set iInfo = LoadMuniIndexes( "data/Tabla_muni_prov.xls" );

// Wednesday, 2011/08/03 15:10:39.00
Set fInfo = LoadForecastData( "data/Fore__1.0.oza" );

// Wednesday, 2011/08/03 15:09:37.00
Set fInfo = LoadForecastData( "data/Fore__1.0.oza" );


// Wednesday, 2011/08/03 15:09:02.00
Set fInfo = LoadForecastData( "data/Fore__1.0.oza" );

// Wednesday, 2011/08/03 15:05:56.00
Set fInfo = LoadForecastData( "data/Fore__1.0.oza" );

// Wednesday, 2011/08/03 14:48:10.00
Real k = SetSum( Empty );


// Wednesday, 2011/08/03 14:40:58.00
Set LoadMuniIndexes( "data/Tabla_muni_prov.xls" );

// Wednesday, 2011/08/03 14:40:54.00
Set LoadForecastData( "data/Fore__1.0.oza" );

// Tuesday, 2011/08/02 14:08:23.00
Date Succ( y2010m12d31, WD(1), 88 );

// Tuesday, 2011/08/02 14:04:01.00
Date Succ( y2010m12d31, WD(1), 35 + 8 );

// Tuesday, 2011/08/02 14:03:53.00
Date Succ( y2010m12d31, WD(1), 35 + 5 );

// Tuesday, 2011/08/02 14:03:31.00
Date Succ( y2010m12d31, WD(1), 35 + 16 );

// Tuesday, 2011/08/02 14:03:16.00
Date Succ( y2010m12d31, WD(1), 35 );

// Tuesday, 2011/08/02 13:57:46.00
#Require MMS;

// Tuesday, 2011/08/02 10:14:47.00
Date Succ( y2010m12d31, WD(1), 45 );

// Tuesday, 2011/08/02 10:14:41.00
Date Succ( y2010m12d31, WD(1), 40 );

// Tuesday, 2011/08/02 09:39:45.00
Date Succ( y2010m12d31, WD(1), 34 );

// Tuesday, 2011/08/02 09:39:38.00
Date Succ( y2010m12d31, WD(1), 35 );

// Tuesday, 2011/08/02 09:29:47.00
Date Succ( y2010m12d31, WD(1), 35 );

// Tuesday, 2011/08/02 09:29:10.00
Date Succ( y2010m12d31, WD(1), 32 );

// Tuesday, 2011/08/02 09:29:04.00
Date Succ( y2010m12d31, WD(1), 30 );

// Tuesday, 2011/08/02 09:28:45.00
Date Succ( y2010m12d31, WD(1), 35 );

// Tuesday, 2011/08/02 09:28:24.00
Date Succ( y2010m12d31, WD(1), 38 );

// Tuesday, 2011/08/02 09:28:21.00
Date Succ( y2010m12d31, WD(1), 38 );

// Tuesday, 2011/08/02 09:23:15.00
Date Succ( y2010m12d31, WD(1),51 );

// Tuesday, 2011/08/02 09:23:03.00
Date Succ( y2010m12d31, WD(1),40 );

// Tuesday, 2011/08/02 09:21:23.00
Date Succ( y2010m12d31, WD(1),38 );

// Tuesday, 2011/08/02 09:20:52.00
Date Succ( y2010m12d31, WD(1),33 );

// Tuesday, 2011/08/02 09:20:45.00
Date Succ( y2010m12d31, WD(1),36 );

// Tuesday, 2011/08/02 09:20:28.00
Date Succ( y2010m12d31, WD(1),45 );

// Tuesday, 2011/08/02 09:20:20.00
Date Succ( y2010m12d31, WD(1),40 );

// Tuesday, 2011/08/02 09:20:13.00
Date Succ( y2010m12d31, WD(1),37 );

// Tuesday, 2011/08/02 09:19:52.00
Date Succ( y2010m12d31, WD(1),31 );

// Tuesday, 2011/08/02 09:19:43.00
Date Succ( y2010m12d31, WD(1),30 );

// Tuesday, 2011/08/02 09:19:31.00
Date Succ( y2010m12d31, WD(1),23 );

// Tuesday, 2011/08/02 09:18:40.00
Date Succ( y2010m12d31, WD(1),17 );

// Tuesday, 2011/08/02 09:18:31.00
Date Succ( y2010m12d31, WD(1),16 );

// Tuesday, 2011/08/02 09:18:21.00
Date Succ( y2010m12d31, WD(1),15 );

// Tuesday, 2011/08/02 09:17:26.00
Date Succ( y2010m12d31, WD(1),36 );

// Tuesday, 2011/08/02 09:16:17.00
Date Succ( y2010m12d31, WD(1),33 );

// Tuesday, 2011/08/02 09:16:07.00
Date Succ( y2010m12d31, WD(1),34 );

// Tuesday, 2011/08/02 09:15:54.00
Date Succ( y2010m12d31, WD(1),35 );

// Tuesday, 2011/08/02 09:15:47.00
Date Succ( y2010m12d31, WD(1),29 );

// Tuesday, 2011/08/02 09:15:06.00
Date Succ( y2010m12d31, WD(1),45 );

// Tuesday, 2011/08/02 09:14:55.00
Date Succ( y2010m12d31, WD(1),40 );

// Tuesday, 2011/08/02 09:11:09.00
Date Succ( y2010m12d31, WD(1), 36 + 4 );

// Tuesday, 2011/08/02 09:10:53.00
Date Succ( y2010m12d31, WD(1),36 );

// Tuesday, 2011/08/02 09:10:44.00
Date Succ( y2010m12d31, WD(1),37 );

// Tuesday, 2011/08/02 09:08:24.00
Date Succ( y2010m12d31, WD(1), 33 + 5 );

// Tuesday, 2011/08/02 09:04:00.00
Date Succ( y2010m12d31, WD(1),33 );

// Tuesday, 2011/08/02 09:03:49.00
Date Succ( y2010m12d31, WD(1),32 );

// Tuesday, 2011/08/02 09:03:41.00
Date Succ( y2010m12d31, WD(1), 25 );

// Monday, 2011/08/01 11:36:31.00

Date Succ( y2010m12d31, WD(1), 15 + 17);


// Monday, 2011/08/01 11:36:09.00

Date Succ( y2010m12d31, WD(1), 15 );


// Monday, 2011/08/01 11:35:53.00

Date Succ( y2010m12d31, WD(1), 13 );


// Monday, 2011/08/01 11:06:09.00
Date Succ( y2010m12d31, WD(1), 32 );

// Monday, 2011/08/01 11:05:59.00
Date Succ( y2010m12d31, WD(1), 30 );

// Monday, 2011/08/01 11:05:38.00
Date Succ( y2010m12d31, WD(1), 1 );

// Monday, 2011/08/01 09:52:09.00
TimeSet weekly = WD(1);


// Monday, 2011/08/01 09:51:56.00
TimeSet weekly


// Friday, 2011/07/29 14:02:02.00
#Require TolExcel;

// Friday, 2011/07/29 13:26:25.00
Real sigma2 = SubmodeFore::GetParameterSigma2( ? )::GetValue(?);

// Friday, 2011/07/29 13:17:04.00
Matrix ProvPoblacion = modelDS::GetVariable( "qt_pob_2009" )::GetData(?);
Matrix MuniPoblacion = modelDS::GetVariable( "qt_pob_2009_mun" )::GetData(?);

// Friday, 2011/07/29 13:16:45.00
Matrix ProvPoblacion = modelDS::GetVariable( "qt_pob_2009" );
Matrix MuniPoblacion = modelDS::GetVariable( "qt_pob_2009_mun" );


// Friday, 2011/07/29 13:15:08.00
NameBlock modelDS = MuniForecast::GetModel( ? )::GetDataSet( ? );

// Friday, 2011/07/29 13:13:09.00
NameBlock Submodel = MuniForecast::GetModel( ? )::GetSubmodel( 1 );

// Friday, 2011/07/29 12:55:20.00
#Require MMS;

NameBlock MuniForecast = MMS::Container::GetForecast( 1 );

NameBlock ModelFore = MuniForecast::GetModel.Forecast(?);

NameBlock SubmodeFore = ModelFore::GetSubmodel( 1 );

Serie OutputFore = SubmodeFore::GetOutput.Forecast.Mean( ? );

Serie ProvOutput = SubmodeFore::GetOutput.Original( ? );



// Friday, 2011/07/29 12:50:35.00
Serie SubmodeFore::GetOutput.Original( ? );

// Friday, 2011/07/29 12:50:12.00
Serie ModelFore::GetOutput.Original( ? );

// Friday, 2011/07/29 12:43:31.00
Serie OutputFore = SubmodeFore::GetOutput.Forecast.Mean( ? );

// Friday, 2011/07/29 12:43:29.00
Serie MeanFore = SubmodeFore::GetFilter.Forecast.Mean( ? );

// Friday, 2011/07/29 12:05:42.00
NameBlock SubmodeFore = ModelFore::GetSubmodel( 1 );

// Friday, 2011/07/29 12:04:58.00
NameBlock ModelFore = MuniForecast::GetModel.Forecast(?);

// Friday, 2011/07/29 12:03:49.00
NameBlock MuniForecast = MMS::Container::GetForecast( 1 );

// Friday, 2011/07/29 11:55:19.00
Serie GuiLog (GetObjectFromAddress("CA97E24:0:9F6CD70:0:9AEE318:0:2:4:4") )

// Friday, 2011/07/29 11:32:41.00
#Require MMS;


// Tuesday, 2011/07/26 02:50:37.00
  #Require GuiTools;
  
  Text GuiTools::WaterfallChart
  (
    SetOfReal( 40, 10, 5, 1, 0.5, -1, -3, -7 ),
    SetOfText( "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2" )
  );



// Tuesday, 2011/07/26 02:50:29.00
  #Require GuiTools;
  
  Text GuiTools::WaterfallChart
  (
    SetOfReal( 40, 10, 5, 1, 0.5, -1, -3, -7 ),
    SetOfText( "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2" )
  );



// Tuesday, 2011/07/26 02:50:15.00
  #Require GuiTools;
  
  Text GuiTools::WaterfallChart
  (
    SetOfReal( 40, 10, 5, 1, 0.5, -1, -3, -7 ),
    SetOfText( "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2" )
  );



// Tuesday, 2011/07/26 02:46:40.00
  #Require GuiTools;
  
  Text GuiTools::WaterfallChart
  (
    SetOfReal( 40, 10, 5, 1, 0.5, -1, -3, -7 ),
    SetOfText( "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2" )
  );



// Tuesday, 2011/07/26 02:39:43.00
  #Require GuiTools;
  
  Text GuiTools::WaterfallChart
  (
    SetOfReal( 40, 10, 5, 1, 0.5, -1, -3, -7 ),
    SetOfText( "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2" )
  );



// Tuesday, 2011/07/26 02:37:50.00
  #Require GuiTools;
  
  Text GuiTools::WaterfallChart
  (
    SetOfReal( 40, 10, 5, 1, 0.5, -1, -3, -7 ),
    SetOfText( "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2" )
  );



// Tuesday, 2011/07/26 02:25:33.00
Set Tcl_Eval( "WaterfallChart {40.0 10.0 5.0 1.0 0.5 -1.0 -3.0 -7.0}" );

// Tuesday, 2011/07/26 02:25:25.00
  #Require GuiTools;
  
  Text GuiTools::WaterfallChart
  (
    SetOfReal( 40, 10, 5, 1, 0.5, -1, -3, -7 ),
    SetOfText( "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2" )
  );

Set Tcl_Eval( "WaterfallChart {40.0 10.0 5.0 1.0 0.5 -1.0 -3.0 -7.0}" ]] );


// Tuesday, 2011/07/26 02:24:19.00
Set Tcl_EvalEx( [[ "WaterfallChart" ]] );

// Tuesday, 2011/07/26 02:23:46.00
Set Tcl_EvalEx( [[ "WaterfallChart", "{40.0 10.0 5.0 1.0 0.5 -1.0 -3.0 -7.0}", "" ]] );

// Tuesday, 2011/07/26 02:22:40.00
  #Require GuiTools;
  
  Text GuiTools::WaterfallChart
  (
    SetOfReal( 40, 10, 5, 1, 0.5, -1, -3, -7 ),
    SetOfText( "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2" )
  );



// Tuesday, 2011/07/26 02:18:13.00
  #Require GuiTools;
  
  Text GuiTools::WaterfallChart
  (
    SetOfReal( 40, 10, 5, 1, 0.5, -1, -3, -7 ),
    SetOfText( "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2" )
  );


// Tuesday, 2011/07/26 02:12:20.00
#Require GuiTools;

Text GuiTools::WaterfallChart
( [[40, 10, 5, 1, 0.5, -1, -3, -7 ]],
  [[ "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2" ]]
);



// Tuesday, 2011/07/26 02:12:14.00
#Require GuiTools;


// Tuesday, 2011/07/26 02:06:39.00
#Require GuiTools;

Text GuiTools::WaterfallChart
( SetOfReal( 40, 10, 5, 1, 0.5, -1, -3, -7),
  SetOfText( "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2")
);



// Tuesday, 2011/07/26 02:06:27.00
#Require GuiTools;

Text GuiTools::WaterfallChart
( SetOfReals( 40, 10, 5, 1, 0.5, -1, -3, -7),
  SetOfTexts( "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2")
);



// Tuesday, 2011/07/26 02:05:26.00
#Require GuiTools;

Text GuiTools::WaterfallChart
( [[40, 10, 5, 1, 0.5, -1, -3, -7 ]],
  [[ "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2" ]]
);



// Tuesday, 2011/07/26 02:05:08.00
#Require GuiTools;


// Tuesday, 2011/07/26 02:03:20.00
#Require GuiTools;

Text GuiTools::WaterfallChart( [[40, 10, 5, 1, 0.5, -1, -3, -7 ]], [[ "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2" ]] );


// Tuesday, 2011/07/26 02:03:02.00
Text WaterfallChart( [[40, 10, 5, 1, 0.5, -1, -3, -7 ]], [[ "B1", "I1", "I2", "I3", "I4", "D1", "D2", "D3", "B2" ]] );


// Friday, 2011/07/22 11:51:01.00
#Require MMS;


// Wednesday, 2011/07/20 14:08:01.00
#Require MMS;


// Wednesday, 2011/07/20 00:36:29.00
Real 5676.68 * 2


// Tuesday, 2011/07/19 22:42:00.00
Matrix Tra(vars_italy::Sales_base)*vars_italy::GrossProfit - Tra(vars_italy::GRP_initial)*vars_italy::CostGRP


// Tuesday, 2011/07/19 22:41:50.00
Matrix Tra(vars_italy::Sales_Base)*vars_italy::GrossProfit - Tra(vars_italy::GRP_initial)*vars_italy::CostGRP


// Tuesday, 2011/07/19 22:26:21.00
Real fx0 = {
  Matrix x0 = (forecastOptimizer::_.pipeLine.[1])::x0;
  Matrix gx0 = Constant(0,0,?);
  forecastOptimizer::EvalTarget( x0, gx0 )
};


// Tuesday, 2011/07/19 22:23:36.00
Real fx0 = {
  Matrix x0 = (forecastOptimizer::_.pipeLine.[1])::x0;
  Matrix gx0 = Constant(0,0,?);
  forecastOptimizer::EvalTarget( x0, gx0 )
};


// Tuesday, 2011/07/19 22:20:32.00
Real fx0 = {
  Matrix x0 = (forecastOptimizer::_.pipeLine.[1])::x0;
  Matrix gx0 = Constant(0,0,?);
  forecastOptimizer::EvalTarget( x0, gx0 )
};


// Tuesday, 2011/07/19 22:10:43.00
Real fx0 = {
  Matrix x0 = (forecastOptimizer::_.pipeLine.[1])::x0;
  Matrix gx0 = Constant(0,0,?);
  forecastOptimizer::EvalTarget( x0, gx0 )
};


// Tuesday, 2011/07/19 22:05:48.00
Real target = forecastOptimizer::EvalTarget
((forecastOptimizer::_.pipeLine.[1])::x0,Constant(0,0,?));


// Tuesday, 2011/07/19 21:59:44.00
Real target = forecastOptimizer::EvalTarget
((forecastOptimizer::_.pipeLine.[1])::x0,Constant(0,0,?));

// Tuesday, 2011/07/19 21:56:11.00
Real target = forecastOptimizer::EvalTarget
((forecastOptimizer::_.pipeLine.[1])::x0,Constant(0,0,?));

// Tuesday, 2011/07/19 09:09:40.00
#Require MMS;


// Monday, 2011/07/18 21:25:13.00
Set forecastOptimizer::GetSeries.OptGRP(?);


// Monday, 2011/07/18 21:21:24.00
Set forecastOptimizer::Run(?);

// Monday, 2011/07/18 21:21:04.00
Real (forecastOptimizer::_.pipeLine.[1])::verboseEach := 1

// Monday, 2011/07/18 21:20:58.00
Real (forecastOptimizer::_.pipeLine.[1])::methods::method::stopCriteria::maxTime := 10;

// Monday, 2011/07/18 21:11:05.00
Set forecastOptimizer::Run(?);

// Monday, 2011/07/18 21:10:45.00
Real (forecastOptimizer::_.pipeLine.[1])::methods::method::stopCriteria::maxTime := 1

// Thursday, 2011/07/14 22:22:09.00
Real (forecastOptimizer::_.pipeLine.[1])::methods::met::stopCriteria::maxTime := 60;
//Real (forecastOptimizer::_.pipeLine.[1])::methods::met::stopCriteria::maxEval := 1;
Set forecastOptimizer::Run(?);


// Thursday, 2011/07/14 19:56:20.00
Real (forecastOptimizer::_.pipeLine.[1])::methods::met::stopCriteria::maxTime := 60*60*2;
//Real (forecastOptimizer::_.pipeLine.[1])::methods::met::stopCriteria::maxEval := 1;
Set forecastOptimizer::Run(?);


// Thursday, 2011/07/14 19:22:21.00
Serie Gaussian(0,1) * 3;
Serie 3 *Gaussian(0,1);

// Thursday, 2011/07/14 18:05:47.00
    Matrix x0_aux = (forecastOptimizer::_.seriesVectorConversor.[1])::ToColumn(
      For(1, Card(forecastOptimizer::_.vars), Set (Real i) { forecastOptimizer::_.GetVar.Ini(i) }));



// Thursday, 2011/07/14 18:05:39.00
    Matrix x0_aux = (forecastOptimizer::_.seriesVectorConversor.[1])::ToColumn(
      For(1, Card(forecastOptimizer::_.vars), Set (Real i) { forecastOptimizer::_.GetVar.Ini(i) })),



// Wednesday, 2011/07/13 21:08:21.00
Real (forecastOptimizer::_.pipeLine.[1])::check(True);

// Wednesday, 2011/07/13 21:01:20.00
Set forecastOptimizer::Run(?);

// Wednesday, 2011/07/13 20:40:56.00
Real (forecastOptimizer::_.pipeLine.[1])::methods::met::stopCriteria::maxTime := 20*60;

// Wednesday, 2011/07/13 20:38:52.00
Set results = forecastOptimizer::Run(?);

// Wednesday, 2011/07/13 20:28:37.00
Real (forecastOptimizer::_.pipeLine.[1])::methods::met::stopCriteria::maxTime := 10*60;

// Wednesday, 2011/07/13 20:24:28.00
Real (forecastOptimizer::_.pipeLine.[1])::check(false);

// Wednesday, 2011/07/13 20:24:02.00
Real (forecastOptimizer::_.pipeLine[1])::check(false);


// Wednesday, 2011/07/13 20:23:30.00
Real forecastOptimizer::_.pipeLine::check(false);

// Wednesday, 2011/07/13 20:23:17.00
Real forecastOptimizer::_.pipeline::check(false);


// Wednesday, 2011/07/13 14:05:42.00
Set getSerieElements( Serie ser )
{
  Set dates = Dates(Dating(ser),First(ser),Last(ser));
  EvalSet(dates,Set(Date d){[[d,SerDat(ser,d)]]})
};

Serie s = SubSer( Gaussian(0,1), y2000, y2002 );

Set getSerieElements( s );



// Wednesday, 2011/07/13 14:05:30.00
Set getSerieElements( Serie S )
{
  Set dates = Dates(Dating(ser),First(ser),Last(ser));
  EvalSet(dates,Set(Date d){[[d,SerDat(ser,d)]]})
};

Serie s = SubSer( Gaussian(0,1), y2000, y2002 );

Set getSerieElements( s );



// Monday, 2011/07/11 19:50:30.00
#Require MMS;



// Monday, 2011/07/11 16:59:54.00
#Require MMS;

#Require RmtPsClient;

Real RmtPsClient::ExecTol
( 
"cox01", 6668, 
[[
   "BMR_admin",
   [[ 
      [[ Text expr = "BMR_admin::CreateMMSRepo( \"PrjCokIndYYYYYY\" );" ]]
   ]]
]]
)



// Monday, 2011/07/11 16:56:42.00
#Require MMS;

#Require RmtPsClient;

Real RmtPsClient::ExecTol
( 
"cox01", 6668, 
[[
   "BMR_admin",
   [[ 
      [[ Text expr = "BMR_admin::CreateMMSRepo( \"PrjCokIndXXXXXX\" );" ]]
   ]]
]]
)



// Monday, 2011/07/11 16:55:32.00
#Require MMS;

#Require RmtPsClient;

Real RmtPsClient::ExecTol
( 
"cox01", 6668, 
[[
   "BMR_admin",
   [[ 
      [[ Text expr = "BMR_admin::CreateMMSRepo( \"PrjCokIndXXXXXX\" );" ]]
   ]]
]]
)



// Monday, 2011/07/11 16:53:21.00
#Require MMS;

#Require RmtPsClient;

Real RmtPsClient::ExecTol
( 
"cox01", 6668, 
[[
   "BMR_admin",
   [[ 
      [[ Text expr = "BMR_admin::CreateMMSRepo( \"PrjCokIndXXXXXX\" );" ]]
   ]]
]]
)



// Monday, 2011/07/11 16:49:45.00
#Require MMS;

#Require RmtPsClient;

Real RmtPsClient::ExecTol
( 
"cox01", 6668, 
[[
   "BMR_admin",
   [[ 
      [[ Text expr = "BMR_admin::CreateMMSRepo( \"PrjCokIndXXXXXX\" );" ]]
   ]]
]]
)



// Monday, 2011/07/11 16:48:17.00
#Require MMS;

#Require RmtPsClient;

Real RmtPsClient::ExecTol
( 
"cox01", 6668, 
[[
   "BMR_admin",
   [[ 
      [[ Text expr = "BMR_admin::CreateMMSRepo( \"PrjCokIndXXXXXX\" );" ]]
   ]]
]]
)



// Monday, 2011/07/11 16:47:24.00
#Require MMS;

#Require RmtPsClient;

Real RmtPsClient::ExecTol
( 
"cox01", 6668, 
[[
   "BMR_admin",
   [[ 
      [[ Text expr = "BMR_admin::CreateMMSRepo( \"PrjCokIndXXXXXX\" );" ]]
   ]]
]]
)



// Monday, 2011/07/11 16:45:52.00
#Require MMS;

#Require RmtPsClient;

Real RmtPsClient::ExecTol
( 
"cox01", 6668, 
[[
   "BMR_admin",
   [[ 
      [[ Text expr = "BMR_admin::CreateMMSRepo( \"PrjCokIndXXXXXX\" );" ]]
   ]]
]]
)



// Monday, 2011/07/11 16:41:53.00
#Require MMS;

#Require RmtPsClient;

Real RmtPsClient::ExecTol
( 
"cox01", 6668, 
[[
   "BMR_admin",
   [[ 
      [[ Text expr = "BMR_admin::CreateMMSRepo( \"PrjCokIndXXXXXX\" );" ]]
   ]]
]]
)



// Monday, 2011/07/11 16:38:46.00
#Require MMS;

#Require RmtPsClient;

Real RmtPsClient::ExecTol
( 
"cox01", 6668, 
[[
   "BMR_admin",
   [[ 
      [[ Text expr = "BMR_admin::CreateMMSRepo( \"PrjCokIndXXXXXX\" );" ]]
   ]]
]]
)



// Monday, 2011/07/11 16:36:10.00
#Require MMS;

#Require RmtPsClient;

Real RmtPsClient::ExecTol
( 
"cox01", 6668, 
[[
   "BMR_admin",
   [[ 
      [[ Text expr = "BMR_admin::CreateMMSRepo( \"PrjCokIndXXXXXX\" );" ]]
   ]]
]]
)



// Monday, 2011/07/11 14:55:40.00
#Require MMS;

#Require RmtPsClient;

Real RmtPsClient::ExecTol
( 
"cox01", 6668, 
[[
   "BMR_admin",
   [[ 
      [[ Text expr = "BMR_admin::CreateMMSRepo( \"PrjCokIndXXXXXX\" );" ]]
   ]]
]]
)



// Monday, 2011/07/11 14:54:04.00
#Require MMS;

#Require RmtPsClient;

Real RmtPsClient::ExecTol
( 
"cox01", 6669, 
[[
   "BMR_admin",
   [[ 
      [[ Text expr = "BMR_admin::CreateMMSRepo( \"PrjCokIndXXXXXX\" );" ]]
   ]]
]]
)

// Monday, 2011/07/11 14:51:27.00
#Require MMS;

#Require RmtPsClient;

Real RmtPsClient::ExecTol
( 
"cox01", 6669, 
[[
   "BMR_admin",
   [[ 
      {[[ Text expr = BMR_admin::CreateMMSRepo( "PrjCokIndXXXXXX" ) ]]}
   ]]
]]
)



// Monday, 2011/07/11 14:51:21.00
#Require MMS;

#Require RmtPsClient

Real RmtPsClient::ExecTol
( 
"cox01", 6669, 
[[
   "BMR_admin",
   [[ 
      {[[ Text expr = BMR_admin::CreateMMSRepo( "PrjCokIndXXXXXX" ) ]]}
   ]]
]]
)



// Monday, 2011/07/11 14:51:03.00
#Require MMS;

#Require RmtPsClient

Real RmtpsClient::ExecTol
( 
"cox01", 6669, 
[[
   "BMR_admin",
   [[ 
      {[[ Text expr = BMR_admin::CreateMMSRepo( "PrjCokIndXXXXXX" ) ]]}
   ]]
]]
)



// Monday, 2011/07/11 14:39:39.00
#Require MMS;

#Require RmtPsClient



// Monday, 2011/07/11 14:26:40.00
#Require MMS;

Real OSDirMake( "/kk" );


// Monday, 2011/07/11 14:26:29.00
#Require MMS;

Real OSDirMake( "/tmp/kk" );


// Monday, 2011/07/11 13:43:12.00
#Require MMS;



// Monday, 2011/07/11 12:03:30.00
/////////////////////////////////////////////////////////
NameBlock Space1 = [[
  TimeSet miTS = C-WD(1);
  Serie miS = SubSer(Trend(y1999, C-WD(1)), y2000, y2002);
  Real _save = Ois.Store([[miS]], "/tmp/miS.oza")
]];

NameBlock Space2 = [[
  Set ld2 = { Ois.Load("/tmp/miS.oza")[1] };
  Serie miS2 = ld2[1];
  TimeSet miTS = D(1);
  Set ld = { Ois.Load("/tmp/miS.oza")[1] };
  Serie miS3 = ld[1]
]];


// Monday, 2011/07/11 12:02:24.00
Text ""<<(C-WD(1));

// Monday, 2011/07/11 11:52:37.00
Serie Space2::miS3;

// Monday, 2011/07/11 11:52:33.00
Serie Space2::miS2;

// Monday, 2011/07/11 11:52:26.00
Serie Space1::miS;

// Monday, 2011/07/11 11:52:15.00
NameBlock Space2 = [[
  Set ld2 = { Ois.Load("/tmp/miS.oza")[1] };
  Serie miS2 = ld2[1];
  TimeSet miTS = D(1);
  Set ld = { Ois.Load("/tmp/miS.oza")[1] };
  Serie miS3 = ld[1]
]];

// Monday, 2011/07/11 11:51:48.00
/////////////////////////////////////////////////////////
NameBlock Space1 = [[
  TimeSet miTS = C-WD(1);
  Serie miS = SubSer(Trend(y1999, miTS), y2000, y2002);
  Real _save = Ois.Store([[miS]], "/tmp/miS.oza")
]];

// Domingo, 2011/07/10 14:42:40.00
#Require MMS;

Set ss = [[ Real x1 = 1/0, Real x2 = -1/0, Real x3 = 0/0, Real 3.1416 ]];

Text def = ""<<ss;

Set Eval( "ss1 = " << def ); 


// Domingo, 2011/07/10 14:31:22.00
#Require MMS;

Text FormatReal(1/0);


// Domingo, 2011/07/10 14:30:12.00
#Require MMS;


// Domingo, 2011/07/10 14:29:19.00
Text ""<<(1/0);


// Sunday, 2011/07/10 14:01:52.00
#Require MMS;


// Sunday, 2011/07/10 13:46:02.00
Real IsUnknown(1/0);

// Sunday, 2011/07/10 13:45:32.00
Real Known(1/0);

// Sunday, 2011/07/10 13:43:29.00
Text ""<<(Real -1/0);
Text ""<<(Real +1/0);

// Sunday, 2011/07/10 13:42:54.00
Text ""<<(Real 0/0);

// Sunday, 2011/07/10 13:42:16.00
Text ""<<x;

// Sunday, 2011/07/10 13:42:13.00
Real x = 1/0;

// Sunday, 2011/07/10 13:42:09.00
Text ""<<x;

// Sunday, 2011/07/10 13:41:54.00
Real x = 1/0;

// Sunday, 2011/07/10 13:13:14.00
Set kk = [[ 1,2 ]];

// Sunday, 2011/07/10 13:12:55.00
Set ::kk = [[ 1,2 ]];

// Sunday, 2011/07/10 13:12:48.00
Set ::kk = [[ 1,2 ];

// Sunday, 2011/07/10 13:05:39.00
Set Include( "/tmp/kk.oza" );

// Sunday, 2011/07/10 13:05:22.00
Real Ois.Store( [[ x ]], "/tmp/kk.oza" );

// Sunday, 2011/07/10 13:04:44.00
#Require MMS;

Real x = 1/0;


// Sunday, 2011/07/10 13:01:28.00
#Require MMS;


// Friday, 2011/07/08 21:23:04.00
Real {

  Real estimNum = MMS::Container::FindEstimation([["BSR","1"]]);
  Real If(estimNum, MMS::Container::RemoveEstimation(estimNum));

  MMS::@Estimation estimation = MMS::Container::ReplaceEstimation([[
  Text _.name = "BSR";
  MMS::@Model _.model = MMS::Container::GetModel([["ModelD","1"]]);
  MMS::@SettingsBSR _.settings = [[
    Real mcmc.sampleLength = 1000
  ]]
  ]]);  

//////////////////////////////////////////////////////////////////////////////
Real use_ExpTermD4 = False;
Real use_Hierarchy = False;

Real If(use_ExpTermD4, {

  MMS::@Model model = estimation::GetModel(?);

  MMS::@Submodel submodel = (model::GetSubmodels(?))[1];

/*
  Real model::CreateBaseExpTermOmega([[
    Text _.name = "ExpTermD4";
    Text _.variableName = "VariableD14";
    Polyn _.transferFunction = 0.1
  ]]);
*/

  MMS::@ExpTerm et4 = submodel::CreateExpTerm_TransferFunction([[
    Text _.name  = "ExpTermD4";
    NameBlock _.input = [[
      Text _.name = "VariableD14";
      Text _.variable = "VariableD14"
    ]];
    Polyn _.transferFunction = 0.1
  ]]);


Real If(use_Hierarchy, {


  MMS::@Hierarchy hierarchy1 = model::CreateHierarchy([[
    Text _.name = "Homogeneity";
    Set  _.mElements = [[
      [["OutputD", "ExpTermD1", [["Linear", 0]] ]],
      [["OutputD", "ExpTermD4", [["Linear", 0]] ]]
    ]];    
    NameBlock _.noise = [[
      Text _.type = "Normal";
      Set _.relativeSigmas = SetOfReal(1, 1);
      Real _.sigma = 0.15;
      Real _.sigmaFixed = 0.5
    ]]
  ]]);
  Anything hierarchy1::CreateHierarchyTerm([[
    Text _.name = "Promedio"
    // Set _.coefficients = SetOfReal(1, 1, 1, 1, 1, 1)
  ]]);

0});

0});
//////////////////////////////////////////////////////////////////////////////

  Real Stop;
  Real estimation::Execute(?);

1};


// Friday, 2011/07/08 21:22:24.00
Real {

  Real estimNum = MMS::Container::FindEstimation([["BSR","1"]]);
  Real If(estimNum, MMS::Container::RemoveEstimation(estimNum));

  MMS::@Estimation estimation = MMS::Container::ReplaceEstimation([[
  Text _.name = "BSR";
  MMS::@Model _.model = MMS::Container::GetModel([["ModelD","1"]]);
  MMS::@SettingsBSR _.settings = [[
    Real mcmc.sampleLength = 1000
  ]]
  ]]);  

//////////////////////////////////////////////////////////////////////////////
Real use_ExpTermD4 = False;
Real use_Hierarchy = False;

Real If(use_ExpTermD4, {

  MMS::@Model model = estimation::GetModel(?);

  MMS::@Submodel submodel = (model::GetSubmodels(?))[1];

/*
  Real model::CreateBaseExpTermOmega([[
    Text _.name = "ExpTermD4";
    Text _.variableName = "VariableD14";
    Polyn _.transferFunction = 0.1
  ]]);
*/

  MMS::@ExpTerm et4 = submodel::CreateExpTerm_TransferFunction([[
    Text _.name  = "ExpTermD4";
    NameBlock _.input = [[
      Text _.name = "VariableD14";
      Text _.variable = "VariableD14"
    ]];
    Polyn _.transferFunction = 0.1
  ]]);


Real If(use_Hierarchy, {


  MMS::@Hierarchy hierarchy1 = model::CreateHierarchy([[
    Text _.name = "Homogeneity";
    Set  _.mElements = [[
      [["OutputD", "ExpTermD1", [["Linear", 0]] ]],
      [["OutputD", "ExpTermD4", [["Linear", 0]] ]]
    ]];    
    NameBlock _.noise = [[
      Text _.type = "Normal";
      Set _.relativeSigmas = SetOfReal(1, 1);
      Real _.sigma = 0.15;
      Real _.sigmaFixed = 0.5
    ]]
  ]]);
  Anything hierarchy1::CreateHierarchyTerm([[
    Text _.name = "Promedio"
    // Set _.coefficients = SetOfReal(1, 1, 1, 1, 1, 1)
  ]]);

0});

0});
//////////////////////////////////////////////////////////////////////////////

  Real Stop;
  Real estimation::Execute(?);

1};


// Friday, 2011/07/08 21:16:08.00
Real inf

// Friday, 2011/07/08 21:16:01.00
Real inf = 1;

// Friday, 2011/07/08 21:14:58.00
#Require MMS;

Real inf


// Friday, 2011/07/08 21:05:20.00
#Require MMS;


// Thursday, 2011/07/07 10:56:03.00
#Require MMS;

// Thursday, 2011/07/07 09:31:27.00
#Require TolExcel;

NameBlock test = TolExcel::@WorkBook::New( "/tmp/test04.xls" );

Real test::ActivateWS(1);

Real test::WriteRange( 2, 2, [[ [[ "Hola", "que tal?" ]],
                                [[ 1,      y2011 ]] ]] );

Real test::Save(?);
Real test::Close(?);


// Thursday, 2011/07/07 09:08:40.00
#Require TolExcel;

NameBlock test = TolExcel::@WorkBook::Open( "" );

Real test::ActivateWS(1);

Real test::WriteRange( 2, 2, [[ [[ "Hola", "que tal?" ]],
                                [[ 1,      y2011 ]] ]] );

Real test::SaveAs("/tmp/test02.xls");
Real test::Close(?);






// Thursday, 2011/07/07 09:03:20.00
Real test::Close(?);

// Thursday, 2011/07/07 09:02:28.00
Real test::Save(?);

// Thursday, 2011/07/07 09:01:56.00
Real test::WriteRange( 2, 2, [[ [[ "Hola", "que tal?" ]],
                                [[ 1,      y2011 ]] ]] );

// Thursday, 2011/07/07 09:01:44.00
Real test::WriteRange( 2, 2, [[ [[ "Hola", "que tal?" ]],
                                [[ 1,      y2011 ]] ]] );

// Thursday, 2011/07/07 08:59:44.00
Real test::ActivateWS(1);

// Thursday, 2011/07/07 08:59:34.00
Real test::ActivateWS(2);

// Thursday, 2011/07/07 08:59:24.00
Real test.ActivateWS(2);

// Thursday, 2011/07/07 08:58:39.00
NameBlock test = TolExcel::@WorkBook::New( "/tmp/test01.xls" );

// Thursday, 2011/07/07 08:56:43.00
#Require TolExcel;

NameBlock TolExcel;



// Thursday, 2011/07/07 08:56:29.00
#Require TolExcel;



// Thursday, 2011/07/07 08:56:20.00
#Require MMS;



// Monday, 2011/07/04 16:14:22.00
Set DBTable( "select '2010-01-01'::date as fecha;" );

// Monday, 2011/07/04 16:14:18.00

  NameBlock conn = DBConnect::Create(
    "mpapme","tfnesp","tfn!116.", 
    "pgsql", "tfnespmpapme", "p-pgsql01.localbayes.es", 
    "Base de datos de ...");

Real conn::Check(?);
Real conn::Activate(?);

// Monday, 2011/07/04 13:39:28.00
  NameBlock conn = DBConnect::Create(
    "mpapme","tfnesp","tfn!116.", 
    "pgsql", "tfnespmpapme", "p-pgsql01.localbayes.es", 
    "Base de datos de ...");

Real conn::Check(?);
Real conn::Activate(?);

Set getInput(Text inputName, Real escId) {
    Text kk = "select exe.exe_fecha, exe.exe_valor from tbl_ent_x_esc as exe, tbl_entrada as ent where exe.exe_ent=ent.ent_id and ent.ent_nombre='"<<inputName<<"' and exe.exe_esc="<<escId;
    WriteLn( kk );
    Set s1= DBTable("select exe.exe_fecha, exe.exe_valor from tbl_ent_x_esc as exe, tbl_entrada as ent where exe.exe_ent=ent.ent_id and ent.ent_nombre='"<<inputName<<"' and exe.exe_esc="<<escId)
};
  
Set s1= getInput("Eco_MetPDI.Uni_GeoALLXXX_RAcXXX_DEcXXX_MacGCH_TInXXX_CFEXXX_ClaXXX_GruXXX_FreYea", 27);

// Monday, 2011/07/04 13:34:06.00
Set s1= getInput("Eco_MetPDI.Uni_GeoALLXXX_RAcXXX_DEcXXX_MacGCH_TInXXX_CFEXXX_ClaXXX_GruXXX_FreYea", 27);

// Monday, 2011/07/04 13:33:43.00
Set getInput(Text inputName, Real escId) {
    Set s1= DBTable("select exe.exe_fecha, exe.exe_valor from tbl_ent_x_esc as exe, tbl_entrada as ent where exe.exe_ent=ent.ent_id and ent.ent_nombre='"<<inputName<<"' and exe.exe_esc="<<escId)
};

// Monday, 2011/07/04 13:33:20.00
Real conn::Activate(?);

// Monday, 2011/07/04 12:30:46.00
Real conn::Activate(?);

// Monday, 2011/07/04 12:29:37.00
Real conn::Check(?);

// Monday, 2011/07/04 12:29:13.00
  NameBlock conn = DBConnect::Create(
    "mpapme","tfnesp","tfn!116.", 
    "pgsql", "tfnespmpapme", "p-pgsql01.localbayes.es", 
    "Base de datos de ...");

  



// Monday, 2011/07/04 12:28:53.00
  NameBlock rade3g = DBConnect::Create(
    "mpapme","tfnesp","tfn!116.", 
    "pgsql", "tfnespmpapme", "p-pgsql01.localbayes.es", 
    "Base de datos de ...");



// Friday, 2011/07/01 16:15:16.00
#Require MMS;


// Jueves, 2011/06/30 21:14:51.00
Text TolPackage::Client::_.localRoot;


// Jueves, 2011/06/30 21:14:38.00
Text TolPackage::Client::_.localroot;


// Jueves, 2011/06/30 21:14:28.00
Text TolPackage::Cliente::_.localroot;


// Thursday, 2011/06/30 19:04:58.00
#Require MMS;


// Thursday, 2011/06/30 18:57:11.00
#Require MMS


// Thursday, 2011/06/30 10:52:24.00
Real t0 = Copy( Time );
Set alldata1 = EvalSet( model::_.mVariables, Serie( NameBlock v ) { v::GetData(?) } );
Real dur = Time - t0;

// Thursday, 2011/06/30 10:48:24.00
Date MMS::SetMin_Dates( alldates );

// Thursday, 2011/06/30 10:46:58.00
Set alldates = EvalSet( alldata, Date( Serie s ) { First(s) } );

// Thursday, 2011/06/30 10:32:22.00
Set alldata = EvalSet( model::_.mVariables, Serie( NameBlock v ) { v::GetData(?) } );

// Thursday, 2011/06/30 10:30:34.00
Set alldata = EvaleSet( model::_.mVariables, Serie( NameBlock v ) { v::GetData(?) } );

// Thursday, 2011/06/30 10:30:30.00
NameBlock model = MMS::Container::GetEstimation(1)::GetModel(?);

// Thursday, 2011/06/30 09:29:34.00
#Require MMS;


// Wednesday, 2011/06/29 22:48:36.00
Real nn::Execute(?);

// Wednesday, 2011/06/29 22:45:27.00
Serie et::GetData(?);

// Wednesday, 2011/06/29 22:37:32.00
NameBlock et = sm::GetExpTerm(1);

// Wednesday, 2011/06/29 22:18:38.00
Set sm::GetEffects.Forecast.Mean(?);

// Wednesday, 2011/06/29 22:18:29.00
Set sm::GetEffects.Forecast.Mean(?);

// Wednesday, 2011/06/29 22:14:16.00
Serie GuiSetSum (SetOfSerie (GetObjectFromAddress("B9C9364:0:9570A08:0:90F1DA0:0:2:4:5"),GetObjectFromAddress("B9C8BA8:0:9570A08:0:90F1DA0:0:2:4:5")) )

// Wednesday, 2011/06/29 22:13:33.00
Set sm::GetMainResults(?);

// Wednesday, 2011/06/29 22:02:56.00
Text ClassOf( kk );

// Wednesday, 2011/06/29 22:01:54.00
NameBlock kk = sm::GetFilter.Forecast(?);

// Wednesday, 2011/06/29 21:50:01.00
NameBlock sm = mf::GetSubmodel(1);

// Wednesday, 2011/06/29 21:49:22.00

NameBlock mf = nn::GetModel.Forecast(1);;

// Wednesday, 2011/06/29 21:48:54.00
NameBlock mf = nn::GetForecast(1);

// Wednesday, 2011/06/29 21:48:39.00
NameBlock mf = nn::MMS::Container::GetForecast(1);

// Wednesday, 2011/06/29 21:47:18.00
#Require MMS;

NameBlock nn = MMS::Container::GetForecast(1);



// Wednesday, 2011/06/29 21:44:58.00
#Require MMS;


// Wednesday, 2011/06/29 21:23:34.00
#Require MMS;


// Wednesday, 2011/06/29 10:58:26.00
Serie filterF = submodelFHelper::GetFilter.Forecast.Mean(?);

// Wednesday, 2011/06/29 10:57:01.00
NameBlock submodelFHelper = modelFHelper::GetSubmodel(1);

// Wednesday, 2011/06/29 10:56:47.00
MMS::@Model.Forecast modelFHelper = KK::GetModel.Forecast(?);

// Wednesday, 2011/06/29 10:51:39.00
MMS::@Model.Forecast modelF_Alto = KK::GetModel.Forecast(?);

// Wednesday, 2011/06/29 10:51:31.00
Real KK::Execute(?);

// Wednesday, 2011/06/29 10:51:07.00
MMS::@Model.Forecast modelF_Alto = KK::GetModel.Forecast(?);

// Wednesday, 2011/06/29 10:50:50.00
NameBlock KK = MMS::Container::GetForecast( 1 );

// Wednesday, 2011/06/29 10:50:26.00
NameBlock KK = MMS::GetForecast( 1 );

// Wednesday, 2011/06/29 10:49:42.00
NameBlock KK = MMS::GetForecast( 1 );;

// Wednesday, 2011/06/29 10:48:52.00
MMS::@Model.Forecast modelF_Alto = forecast::GetModel.Forecast(?);

// Wednesday, 2011/06/29 10:48:24.00
MMS::@Model.Forecast modelF_Alto = forecast::GetModel.Forecast(?);

// Wednesday, 2011/06/29 10:48:20.00
MMS::@Forecast forecast = MMS::Container::ReplaceForecast([[
  Text _.name = "ForecastPoint.H";
  MMS::@Model _.model = model;
  MMS::@Estimation _.estimation = estimation;
  MMS::@SettingsForecast _.settings = [[
    Text _.mode = "Point"
  ]];
  Set _.fIntervals = [[ 
    Set [["*", y2010m01d01, y2010m04d30]] 
  ]];
  Set _.fScenarios = [[
    Set [["*", "Alto"]]
  ]]
]]);


// Wednesday, 2011/06/29 10:47:40.00
MMS::@Model.Forecast modelF_Alto = forecast::GetModel.Forecast(?);

// Wednesday, 2011/06/29 10:46:38.00
MMS::@Forecast forecast = MMS::Container::ReplaceForecast([[
  Text _.name = "ForecastPoint.H";
  MMS::@Model _.model = model;
  MMS::@Estimation _.estimation = estimation;
  MMS::@SettingsForecast _.settings = [[
    Text _.mode = "Point"
  ]];
  Set _.fIntervals = [[ 
    Set [["*", y2010m01d01, y2010m04d30]] 
  ]];
  Set _.fScenarios = [[
    Set [["*", "Alto"]]
  ]]
]]);


// Wednesday, 2011/06/29 10:45:58.00
#Require MMS


// Wednesday, 2011/06/29 10:43:19.00
NameBlock sM = MF::GetSubmodel( 1 );

// Wednesday, 2011/06/29 10:42:42.00
NameBlock MF = forecast::GetModel.Forecast(?);

// Wednesday, 2011/06/29 10:36:48.00
#Require MMS;


// Wednesday, 2011/06/29 10:25:07.00
#Require MMS;


// Wednesday, 2011/06/29 10:24:43.00
Real TolPackage::Client::RemoteUpgradeAll(?);


// Tuesday, 2011/06/28 20:08:37.00
#Require MMS;


// Sunday, 2011/06/19 13:48:31.00
Set GetRandomSampleIndex( Real sizePopulation, Real sizeSample )
{
  Matrix permIndex = RandPermutation( 1, sizePopulation );
  Matrix sampleIndex = SubCol( permIndex, Range( 1, sizeSample, 1 ) );
  Set result = MatSet( sampleIndex )[1]
};

Matrix SubSampleByRow( Matrix M, Real perc )
{
  Real size = Rows( M );
  Real sampleSize = Floor( size * perc );
  Matrix SubRow( BigMatrix, GetRandomSampleIndex( size, sampleSize ) )
};

Set test1 = {
  Real perc = 0.1;
  Real size = 10000000;
  Matrix BigMatrix = Rand( size, 3, 0, 1 );
  Real t0 = Copy( Time );
  Matrix sample = SubSampleByRow( BigMatrix, perc );
  Real t1 = Copy( Time );
  Set [[ sample, Real performance = t1-t0 ]]
}


// Sunday, 2011/06/19 12:29:49.00
Real t1-t0

// Sunday, 2011/06/19 12:25:12.00
Real t0 = Copy( Time );
Matrix SubRow( BigMatrix, GetRandomSampleIndex( sizePopulation, sampleSize ) );
Real t1 = Copy( Time );

// Sunday, 2011/06/19 12:24:39.00
Set GetRandomSampleIndex( Real sizePopulation, Real sizeSample )
{
  Matrix permIndex = RandPermutation( 1, sizePopulation );
  Matrix sampleIndex = SubCol( permIndex, Range( 1, sizeSample, 1 ) );
  Set result = MatSet( sampleIndex )[1]
};

Real perc = 0.1;
Real sizePopulation = 10000000;
Real sampleSize = Floor( sizePopulation * perc );
Matrix BigMatrix = Rand( sizePopulation, 3, 0, 1 );

// Sunday, 2011/06/19 12:23:19.00
Set GetRandomSampleIndex( Real sizePopulation, Real sizeSample )
{
  Matrix permIndex = RandPermutation( 1, sizePopulation );
  Matrix sampleIndex = SubCol( permIndex, Range( 1, sizeSample, 1 ) );
  Set result = MatSet( sampleIndex )[1]
};

Real perc = 0.1;
Real sizePopulation = 1000;
Real sampleSize = Floor( sizePopulation * perc );
Matrix BigMatrix = Rand( sizePopulation, 3, 0, 1 );

Matrix SubRow( BigMatrix, GetRandomSampleIndex( sizePopulation, sampleSize ) );


// Sunday, 2011/06/19 12:23:17.00
Set GetRandomSampleIndex( Real sizePopulation, Real sizeSample )
{
  Matrix permIndex = RandPermutation( 1, sizePopulation );
  Matrix sampleIndex = SubCol( permIndex, Range( 1, sizeSample, 1 ) );
  Set result = MatSet( sampleIndex )[1]
};

Real perc = 0.1;
Real sizePopulation = 1000;
Real sampleSize = Floor( sizePopulation * perc );
Matrix BigMatrix = Rand( sizePopulation, 3, 0, 1 );

Matrix SubRow( BigMatrix, GetRandomSampleIndex( sizePopulation, sampleSize ) );


// Sunday, 2011/06/19 12:21:40.00
Set GetRandomSampleIndex( Real sizePopulation, Real sizeSample )
{
  Matrix permIndex = RandPermutation( 1, sizePopulation );
  Matrix sampleIndex = SubCol( permIndex, Range( 1, sizeSample, 1 ) );
  Set result = MatSet( sampleIndex )[1]
};

Real perc = 0.1;
Real sizePopulation = 1000;
Real sampleSize = Floor( sizePopulation * perc );
Matrix BigMatrix = Rand( sizePopulation, 3, 0, 1 );

Matrix SubRow( BigMatrix, GetRandomSampleIndex( sizePopulation, sampleSize ) );


// Sunday, 2011/06/19 12:21:15.00
Set GetRandomSampleIndex( Real sizePopulation, Real sizeSample )
{
  Matrix permIndex = RandPermutation( 1, sizePopulation );
  Matrix sampleIndex = SubCol( permIndex, Range( 1, sizeSample, 1 ) );
  Set result = MatSet( sampleIndex )[1]
};

Real perc = 0.1;
Real sizePopulation = 1000;
Real sampleSize = Floor( sizePopulation * perc );
Matrix BigMatrix = Rand( sizePopulation, 3, 0, 1 );

Matrix SubRow( BigMatrix, GetRandomSampleIndex( sizePopulation, sampleSize );


// Sunday, 2011/06/19 12:18:28.00
Real perc = 0.1;
Real sizePopulation = 1000;
Real sampleSize = Floor( sizePopulation * perc );
Matrix BigMatrix = Rand( sizePopulation, 3, 0, 1 );
Matrix permIndex = RandPermutation( 1, sizePopulation );
Matrix sampleIndex = SubCol( permIndex, Range( 1, sampleSize, 1 ) );
Matrix SubRow( BigMatrix, Tra(sampleIndex) );


// Sunday, 2011/06/19 12:17:32.00
Real perc = 0.1;
Real sizePopulation = 1000;
Real sampleSize = Floor( sizePopulation * perc );
Matrix BigMatrix = Rand( sizePopulation, 3, 0, 1 );
Matrix permIndex = RandPermutation( 1, sizePopulation );
Matrix sampleIndex = SubCol( permIndex, Range( 1, sampleSize, 1 ) );
Matrix SubRow( BigMatrix, Tra(sampleIndex) );


// Sunday, 2011/06/19 12:16:34.00
Real perc = 0.1;
Real sizePopulation = 10000000;
Real sampleSize = Floor( sizePopulation * perc );
Matrix BigMatrix = Rand( sizePopulation, 3, 0, 1 );
Matrix permIndex = RandPermutation( 1, sizePopulation );
Matrix sampleIndex = SubCol( permIndex, Range( 1, sampleSize, 1 ) );
Matrix SubRow( BigMatrix, Tra(sampleIndex) );


// Sunday, 2011/06/19 12:08:43.00
Matrix permIndex = RandPermutation( 1, 1000 );

// Wednesday, 2011/06/15 20:19:34.00
#Require MMS;

// Wednesday, 2011/06/15 20:19:17.00
Real TolPackage::Client::RemoteUpgradeAll(1);


// Wednesday, 2011/06/15 20:18:14.00
#Require MMS;


// Wednesday, 2011/06/15 20:13:46.00
#Require MMS;

// Wednesday, 2011/06/15 20:13:00.00
Real TolPackage::Client::RemoteUpgradeAll(1)


// Sunday, 2011/06/12 01:31:20.00
GuiTools

// Sunday, 2011/06/12 01:30:02.00
#Require MMS


// Sunday, 2011/06/12 01:29:03.00
#Require MMS;


// Sunday, 2011/06/12 01:27:46.00
#Require MMS


// Sunday, 2011/06/12 00:56:23.00
Real GuiTools::MenuManager::defineDelegatedSubmenues(?);

// Sunday, 2011/06/12 00:55:30.00
#Require MMS


// Sunday, 2011/06/12 00:54:49.00
#Require GuiTools


// Sunday, 2011/06/12 00:54:18.00
#Require MMS


// Sunday, 2011/06/12 00:52:51.00
#Require MMS


// Sunday, 2011/06/12 00:51:55.00
#Require GuiTools


// Saturday, 2011/06/11 23:06:48.00
Real MenuManager::defineDelegatedOptions(?);


// Saturday, 2011/06/11 23:06:11.00
Real MenuManager::defineDelegatedOptions(?);


// Saturday, 2011/06/11 23:05:43.00
Real MenuManager::defineDelegatedOptions(?);


// Saturday, 2011/06/11 22:53:32.00
Real MenuManager::defineDelegatedOptions(?);


// Saturday, 2011/06/11 22:53:02.00
Real MenuManager::defineDelegatedOptions(?);


// Saturday, 2011/06/11 22:52:17.00
Real MenuManager::defineDelegatedOptions(?);


// Saturday, 2011/06/11 22:41:08.00
Real MenuManager::defineDelegatedOptions(?);


// Saturday, 2011/06/11 22:38:06.00
Real MenuManager::defineDelegatedOptions(?);


// Saturday, 2011/06/11 22:36:03.00
Real MenuManager::defineDelegatedOptions(?);


// Saturday, 2011/06/11 22:34:04.00
Real MenuManager::defineDelegatedOptions(?);


// Saturday, 2011/06/11 22:01:55.00
MenuManager::defineDelegatedOptions(?);


// Saturday, 2011/06/11 22:00:37.00
MenuManager::defineDelegatedOptions(?);


// Saturday, 2011/06/11 21:58:10.00
MenuManager::defineDelegatedOptions(?);


// Saturday, 2011/06/11 21:57:14.00
MenuManager::defineDelegatedOptions(?);


// Saturday, 2011/06/11 21:56:54.00
@MenuManager

// Saturday, 2011/06/11 21:56:26.00
@MenuManager::defineDelegatedOptions(?);


// Saturday, 2011/06/11 21:45:10.00
WriteLn( Name(aa) );

// Saturday, 2011/06/11 21:45:00.00
NameBlock PutName( "aa/bb", aa );

// Saturday, 2011/06/11 21:44:18.00
WriteLn( Name(aa) );

// Saturday, 2011/06/11 21:43:57.00
Class @A {
  Real a = 1;
  Real Rename( Text name ) {
    NameBlock PutName( name, _this );
    Real 0
  }
};

@A aa = [[Real a = 2]];

Real aa::Rename( "otro_nombre" );


// Saturday, 2011/06/11 21:43:43.00
Class @A {
  Real a = 1;
  Real Rename( Text name ) {
    PutName( name, _this );
    Real 0
  }
};

@A aa = [[Real a = 2]];

Real aa::Rename( "otro_nombre" );


// Saturday, 2011/06/11 21:27:58.00
MenuManager

// Saturday, 2011/06/11 18:26:21.00
Set MenuManager::getDelegatedEntries( "@Ejemplos" );


// Saturday, 2011/06/11 18:24:38.00
Set MenuManager::getDelegatedEntries( "@Ejemplos" );


// Saturday, 2011/06/11 18:23:25.00
Set MenuManager::getDelegatedEntries( "@Ejemplos" );


// Saturday, 2011/06/11 18:22:44.00
Set MenuManager::getDelegatedEntries( "@Ejemplos" );


// Saturday, 2011/06/11 18:16:33.00
Set MenuManager::getDelegatedEntries( "@Ejemplos" );


// Saturday, 2011/06/11 18:16:25.00
Set MenuManaget::getDelegatedEntries( "@Ejemplos" );


// Saturday, 2011/06/11 12:30:36.00
Class @A {
  Real a = 1;
  Real SayHello( Real void  ) {
    WriteLn( "Hola soy " << a );
    Real a
  };
  @A clone( Real v ) {
    @A _other = Copy( _this );
    Real _other::a := v;
    _other
  } 
};

@A a = [[ Real a = 2 ]];
@A a3 = a::clone( 4 );

Real a::SayHello( ? );
Real a3::SayHello( ? );


// Saturday, 2011/06/11 12:30:23.00
Class @A {
  Real a = 1;
  Real SayHello( Real void  ) {
    WriteLn( "Hola soy " << a );
    Real a
  };
  @A clone( Real v ) {
    @A _other = Copy( _this );
    Real _other::a := v;
    _other
  } 
};

@A a = [[ Real a = 2 ]];
@A a3 = a::clone( 3 );

Real a::SayHello( ? );
Real a3::SayHello( ? );


// Saturday, 2011/06/11 11:06:42.00
Real a::SayHello( ? );
Real a3::SayHello( ? );

// Saturday, 2011/06/11 11:06:36.00
@A a = [[ Real a = 2 ]];
@A a3 = Copy( a );
Real a3::a := 3;

// Saturday, 2011/06/11 11:06:30.00
Class @A {
  Real a = 1;
  Real SayHello( Real void  ) {
    WriteLn( "Hola soy " << a );
    Real a
  }
};


// Saturday, 2011/06/11 11:05:30.00
Real a::SayHello( ? );
Real a3::SayHello( ? );

// Saturday, 2011/06/11 11:05:02.00
Real a3::a := 3;

// Saturday, 2011/06/11 11:04:49.00
@A a3 = Copy( a );

// Saturday, 2011/06/11 11:04:40.00
@A a = [[ Real a = 2 ]];

// Saturday, 2011/06/11 11:04:05.00
Class @A {
  Real a = 1;
  Real SayHello( Real void  ) {
    WriteLn( "Hola soy " << a )
  }
};

@A a = [[ 2 ]];
@A a3 = Copy( a );
Real a3::a := 3;

Real a3::SayHello( ? );


// Thursday, 2011/06/09 19:46:03.00
NameBlock ex1 = MMS::Container::GetModel(1)::GetSubmodel(1)::GetExpTerm( "pob_2007" );

// Thursday, 2011/06/09 19:44:44.00
NameBlock ex = m::GetExpTerm( "pob_2007" );

// Thursday, 2011/06/09 19:43:34.00
#Require MMS;

NameBlock m = MMS::Container::GetModel(1)::GetSubmodel(1);



// Thursday, 2011/06/09 19:40:10.00
#Require MMS;

NameBlock m = MMS::Container::GetModel(1)::GetSubmodel(1);



// Thursday, 2011/06/09 19:38:01.00
#Require MMS;



// Thursday, 2011/06/09 14:23:40.00
#Require MMS


// Thursday, 2011/06/09 14:21:54.00
#Require MMS;


// Thursday, 2011/06/09 14:16:00.00
#Require MMS;


// Thursday, 2011/06/09 14:12:56.00
#Require MMS;


// Thursday, 2011/06/09 14:10:37.00
#Require MMS;

MMS


// Thursday, 2011/06/09 14:04:45.00
#Require MMS;


// Thursday, 2011/06/09 13:31:42.00
#Require MMS;


// Thursday, 2011/06/09 13:08:19.00
#Require MMS;


// Thursday, 2011/06/09 13:05:32.00
#Require MMS;


// Thursday, 2011/06/09 13:04:56.00
Real TolPackage::Client::RemoteUpgradeAll(?);

// Thursday, 2011/06/09 13:04:13.00
#Require MMS;


// Monday, 2011/06/06 21:34:39.00
#Require MMS


// Monday, 2011/06/06 20:55:44.00
#Require BysSampler;


// Monday, 2011/06/06 20:55:38.00
#Require BysMcmc;


// Monday, 2011/06/06 20:55:14.00
#Require DecoTools;


// Monday, 2011/06/06 20:55:03.00
#Require RandVar;


// Monday, 2011/06/06 20:51:10.00
Real TolPackage::Client::RemoteUpgradeAll(0)

// Monday, 2011/06/06 20:49:07.00
Text TolConfigManager::Config::ExternalTools::UrlDownloader := "tcl:curl";
Real TolConfigManager::Save(?);

Real StdLib::TolPackage::Client::RemoteUpdatePackSyncInfo(True);



// Monday, 2011/06/06 20:40:36.00
Text TolConfigManager::Config::ExternalTools::UrlDownloader := "tcl:curl";
Real TolConfigManager::Save(?);

Real StdLib::TolPackage::Client::RemoteUpdatePackSyncInfo(True);



// Monday, 2011/06/06 20:15:06.00
Text
TolConfigManager::Config::ExternalTools::UrlDownloader := "tcl:curl";
Real TolConfigManager::Save(?);

Real
StdLib::TolPackage::Client::RemoteUpdatePackSyncInfo(True);


// Monday, 2011/06/06 20:14:46.00
Real TolConfigManager::Save(?);

// Monday, 2011/06/06 20:14:29.00
Text
TolConfigManager::Config::ExternalTools::UrlDownloader := "tcl:curl";


// Wednesday, 2011/06/01 19:47:00.00
#Require MMS;


// Monday, 2011/05/30 19:24:45.00
#Require MMS;


// Monday, 2011/05/30 00:52:37.00
#Require MMS


// Monday, 2011/05/30 00:49:39.00
#Require MMS;


// Friday, 2011/05/27 19:13:43.00
#Require MMS;



// Viernes, 2011/05/27 19:13:00.00
#Require MMS


// Friday, 2011/05/27 19:10:51.00
#Require MMS;


// Viernes, 2011/05/27 13:53:44.00
Real TolPackage::Client::RemoteUpgradeAll(1)


// Viernes, 2011/05/27 13:53:27.00
Real TolPackage::Clien::RemoteUpgradeAll(1)


// Viernes, 2011/05/27 13:44:45.00
#Require MMS;


// Viernes, 2011/05/27 13:44:33.00
#Require TolExcel;


// Viernes, 2011/05/27 13:44:13.00
Real TolPackage::Client::RemoteUpdateAll(1);


// Thursday, 2011/05/26 16:23:20.00
Matrix SetCol( Range(1, 36, 1 ) ) | Rand( 36, 1, 0, 1 );


// Thursday, 2011/05/26 16:15:19.00
Matrix Rand( 37, 1, 0, 1 );


// Thursday, 2011/05/26 11:59:27.00
Matrix Rand(37,1,0,1);


// Thursday, 2011/05/26 11:58:05.00
Matrix Rand(37,1,0,1);



// Thursday, 2011/05/26 11:57:31.00
Matrix Rand(37,1,0,1);


// Thursday, 2011/05/26 11:57:05.00
Rand Matrix(37,1,0,1);


// Thursday, 2011/05/26 07:28:02.00
Matrix mat = SetCol( Range( 1, 36, 1 ) ) | Rand( 36, 1, 0, 1);



// Wednesday, 2011/05/25 21:24:26.00
Matrix mat = SetCol( Range( 1, 36, 1 ) ) | Rand( 36, 1, 0, 1);


// Wednesday, 2011/05/25 19:35:48.00
Matrix SetCol( Range( 1, 36, 1 ) ) | Rand( 36, 1, 0, 1);

// Wednesday, 2011/05/25 19:35:30.00
Matrix SetCol( Range( 1, 36, 1 ) );

// Wednesday, 2011/05/25 19:35:11.00
Set Range( 1, 36, 1 );

// Wednesday, 2011/05/25 19:31:19.00
Matrix Rand( 36, 1, 0, 1);


// Tuesday, 2011/05/24 17:27:18.00
Set For(1, 100, Set (Real i) {
  WriteLn(""<<i);
  Set CurlApi::GetUrl(
  [[ Text url = "http://packages.tol-project.org/OfficialTolArchiveNetwork/"
    "repository.php?tol_package_version=1.1&tol_version=v2.0.1%20b.4&"
    "action=ping&key=658184943" ]]
  )});



// Tuesday, 2011/05/24 16:33:16.00
Set lista = For(1, 25, Set (Real i) { [[i,  (i + Gaussian(0,1))^2 ]] });
Set listas = BinGroup("|",For(1, 25, Set (Real j) { lista }));
Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
]]);

Matrix mat = SetMat( listas );


// Tuesday, 2011/05/24 16:32:54.00
Set lista = For(1, 25, Set (Real i) { [[i,  (i + Gaussian(0,1))^2 ]] });
Set listas = BinGroup("|",For(1, 11, Set (Real j) { lista }));
Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
]]);

Matrix mat = SetMat( listas );


// Tuesday, 2011/05/24 16:18:04.00
Set lista = For(1, 25, Set (Real i) { [[i,  (i + Gaussian(0,1))^2 ]] });
Set listas = BinGroup("|",For(1, 11, Set (Real j) { lista }));
Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
]]);

Matrix mat = SetMat( listas );


// Tuesday, 2011/05/24 16:14:16.00
Set lista = For(1, 25, Set (Real i) { [[i,  (i + Gaussian(0,1))^2 ]] });
Set listas = BinGroup("|",For(1, 11, Set (Real j) { lista }));
Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
]]);

Matrix mat = SetMat( listas );


// Tuesday, 2011/05/24 16:11:30.00
Set lista = For(1, 25, Set (Real i) { [[i,  (i + Gaussian(0,1))^2 ]] });
Set listas = BinGroup("|",For(1, 11, Set (Real j) { lista }));
Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
]]);

Matrix mat = SetMat( listas );


// Tuesday, 2011/05/24 16:02:22.00
Set lista = For(1, 25, Set (Real i) { [[i,  (i + Gaussian(0,1))^2 ]] });
Set listas = BinGroup("|",For(1, 11, Set (Real j) { lista }));
Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
]]);

Matrix mat = SetMat( listas );


// Tuesday, 2011/05/24 15:46:13.00
Matrix SetMat( listas );

// Tuesday, 2011/05/24 15:23:56.00
Set lista = For(1, 25, Set (Real i) { [[i,  (i + Gaussian(0,1))^2 ]] });
Set listas = BinGroup("|",For(1, 11, Set (Real j) { lista }));
Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
]]);


// Tuesday, 2011/05/24 15:23:36.00
Set lista = For(1, 25, Set (Real i) { [[i,  (i + Gaussian(0,1))^2 ]] });
Set listas = BinGroup("|",For(1, 10, Set (Real j) { lista }));
Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
]]);


// Tuesday, 2011/05/24 15:23:25.00
Set lista = For(1, 25, Set (Real i) { [[i,  (i + Gaussian(0,1))^2 ]] });
Set listas = BinGroup("|",For(1, 3, Set (Real j) { lista }));
Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
]]);


// Tuesday, 2011/05/24 15:22:46.00
Set lista = For(1, 25, Set (Real i) { [[i,  (i + Gaussian(0,1))^2 ]] });
Set listas = BinGroup("|",For(1, 2, Set (Real j) { lista }));
Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
]]);

// Tuesday, 2011/05/24 15:22:30.00
Set lista = For(1, 25, Set (Real i) { i, [[ (i + Gaussian(0,1))^2 ]] });
Set listas = BinGroup("|",For(1, 2, Set (Real j) { lista }));
Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
]]);


// Tuesday, 2011/05/24 15:21:04.00
Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
]]);

// Tuesday, 2011/05/24 15:18:45.00
Set lista = For(1, 25, Set (Real i) { [[(i + Gaussian(0,1))^2, i]] });
Set listas = BinGroup("|",For(1, 2, Set (Real j) { lista }));

// Tuesday, 2011/05/24 15:17:58.00
Set lista = For(1, 25, Set (Real i) { [[i^2 + Gaussian(0,1), i]] });

// Tuesday, 2011/05/24 15:15:41.00
Set lista = For(1, 25, Set (Real i) { [[i^2 + Gaussian(0,1), i]] });
 Set listas = BinGroup("|",lista);

// Tuesday, 2011/05/24 15:15:33.00
Set lista = For(1, 25, Set (Real i) { [[i^2 + Gaussian(0,1), i]] });
 Set listas = BinGroup("|",lista));
 Text TclChartSet(listas, [[

// Tuesday, 2011/05/24 15:15:23.00
Set lista = For(1, 25, Set (Real i) { [[i^2 + Gaussian(0,1), i]] });
 Set listas = BinGroup("|",lista }));

// Tuesday, 2011/05/24 15:14:49.00
Set lista = For(1, 25, Set (Real i) { [[i^2 + Gaussian(0,1), i]] });
 Set listas = BinGroup("|",For(1, 2, Set (Real j) { lista[j] }));

// Tuesday, 2011/05/24 15:13:52.00
Set lista = For(1, 25, Set (Real i) { [[i^2 + Gaussian(0,1), i]] });
 Set listas = BinGroup("|",For(1, 2, Set (Real j) { lista }));
 Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
 ]]);


// Tuesday, 2011/05/24 15:12:03.00
Set lista = For(1, 25, Set (Real i) { [[i^2 + Gaussian(0,1), i]] });
 Set listas = BinGroup("|",For(1, 11, Set (Real j) { lista }));
 Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
 ]]);


// Tuesday, 2011/05/24 15:10:18.00
Set lista = For(1, 25, Set (Real i) { [[i^2, i]] });
 Set listas = BinGroup("|",For(1, 11, Set (Real j) { lista }));
 Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
 ]]);


// Tuesday, 2011/05/24 15:04:49.00
Set lista = For(1, 25, Set (Real i) { [[i, i^2]] });
 Set listas = BinGroup("|",For(1, 11, Set (Real j) { lista }));
 Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
 ]]);


// Tuesday, 2011/05/24 15:04:36.00
Set lista = For(1, 25, Set (Real i) { [[i, i^2]] });
 Set listas = BinGroup("|",For(1, 11, Set (Real j) { lista }));
 Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")


// Tuesday, 2011/05/24 14:49:09.00
Set lista = For(1, 25, Set (Real i) { [[i, i^2 + Gaussian(0,0.2)]] });
 Set listas = BinGroup("|",For(1, 25, Set (Real j) { lista }));
 Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
 ]]);



// Tuesday, 2011/05/24 14:48:44.00
Set lista = For(1, 25, Set (Real i) { [[i, i^2 + Gaussian(0,0.2)]] });
 Set listas = BinGroup("|",For(1, 25, Set (Real j) { lista }));
 Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
 ]]);



// Tuesday, 2011/05/24 14:47:55.00
Set lista = For(1, 25, Set (Real i) { [[i, i^2]] });
 Set listas = BinGroup("|",For(1, 15, Set (Real j) { lista }));
 Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
 ]]);



// Tuesday, 2011/05/24 14:42:49.00
Set lista = For(1, 25, Set (Real i) { [[i, i^2]] });
 Set listas = BinGroup("|",For(1, 11, Set (Real j) { lista }));
 Text TclChartSet(listas, [[
  @TclArgSt("-title", "Titulo"),
  @TclArgSt("-type" , "3")
 ]]);



// Tuesday, 2011/05/24 11:40:24.00
 Set result2 = CurlApi::GetUrl( [[ Text url = "http://packages.tol-project.org/OfficialTolArchiveNetwork/repository.php?action=download&format=attachment&package=BysMcmc.4.4", Text file="/tmp/BysMcmc.4.4.zip", Real verbose=1, Real connecttimeout=3 ]] );
  If( result2::failStatus, {
    WriteLn( "CurlApi::GetUrl error: "<<result2::details )
    }, {
    WriteLn( "CurlApi::GetUrl ok, the result was downloaded to: "<<result2::file )
  } );



// Tuesday, 2011/05/24 11:28:24.00
Set For(1, 100, Set (Real i) {
  WriteLn(""<<i);
  Set CurlApi::GetUrl(
    [[ Text url = "http://packages.tol-project.org/OfficialTolArchiveNetwork/"
                  "repository.php?tol_package_version=1.1&tol_version=v2.0.1%20b.4&"
                  "action=ping&key=658184943", Real connecttimeout=5 ]] )
});


// Tuesday, 2011/05/24 11:27:43.00
Set For(1, 100, Real (Real i) {
  WriteLn(""<<i);
  Text CurlApi::GetUrl(
    [[ Text url = "http://packages.tol-project.org/OfficialTolArchiveNetwork/"
                  "repository.php?tol_package_version=1.1&tol_version=v2.0.1%20b.4&"
                  "action=ping&key=658184943", Real connecttimeout=5 ]] );
1});


// Tuesday, 2011/05/24 11:22:39.00
  Set result = CurlApi::GetUrl( [[ Text url = "http://packages.tol-project.org/OfficialTolArchiveNetwork/repository.php?tol_package_version=1.1&tol_version=v2.0.1%20b.4&action=ping&key=658184943", Real verbose=1, Real connecttimeout=3 ]] );
  If( result::failStatus, {
    WriteLn( "CurlApi::GetUrl error: "<<result::details )
    }, {
    WriteLn( "CurlApi::GetUrl ok, the result is: "<<result::bodyData )
  } )



// Tuesday, 2011/05/24 11:20:23.00
  Set result = CurlApi::GetUrl( [[ Text url = "http://packages.tol-project.org/OfficialTolArchiveNetwork/repository.php?tol_package_version=1.1&tol_version=v2.0.1%20b.4&action=ping&key=658184943", Real verbose=1, Real connecttimeout=3 ]] ); 
  If( result::failStatus, {
    WriteLn( "CurlApi::GetUrl error: "<<result::details )
    }, {
    WriteLn( "CurlApi::GetUrl ok, the result is: "<<result::bodyData )
  } )



// Tuesday, 2011/05/24 11:18:03.00
 Set result = CurlApi::GetUrl( [[ Text url = "http://packages.tol-project.org/OfficialTolArchiveNetwork/repository.php?tol_package_version=1.1&tol_version=v2.0.1%20b.4&action=ping&key=658184943", Real verbose=1, Real connecttimeout=3 ]] );
  If( result::failStatus, {
    WriteLn( "CurlApi::GetUrl error: "<<result::details )
    }, {
    WriteLn( "CurlApi::GetUrl ok, the result is: "<<result::bodyData )
  } )


// Tuesday, 2011/05/24 01:33:50.00
Set CurlApi::GetUrl( [[ Text url = "http://packages.localbayes.es/BayesPrivateTolPackages/repository.php?action=download&format=attachment&package=MMS.0.6033", Text file="/tmp/mms.oza", Real timeout=0, Real connecttimeout=5, Real verbose=0 ]] );


// Tuesday, 2011/05/24 01:33:30.00
Set kk9 = CurlApi::GetUrl( [[ Text url = "http://packages.localbayes.es/BayesPrivateTolPackages/repository.php?action=download&format=attachment&package=MMS.0.6033", Text file="/tmp/mms.oza", Real timeout=0, Real connecttimeout=5, Real verbose=1 ]] );


// Jueves, 2011/05/19 13:27:46.00
#Require TolExcel



// Miercoles, 2011/05/18 22:28:29.00
#Require TolExcel;

TolExcel::@WorkBook xls = TolExcel::@WorkBook::Open("/tmp/ex1.xls");

Real xls::ActivateWS(1);

Set xls::ReadSeriesByCol( 1, 1, 12, 2, W, "%d-%m-%Y" );



// Miercoles, 2011/05/18 22:28:06.00
#Require TolExcel;

TolExcel::@WorkBook xls = TolExcel::@WorkBook::Open("/tmp/ex1.1.xls");

Real xls::ActivateWS(1);

Set xls::ReadSeriesByCol( 1, 1, 12, 2, W, "%d-%m-%Y" );

// Miercoles, 2011/05/18 22:27:08.00
#Require TolExcel;

TolExcel::@WorkBook xls = TolExcel::@WorkBook::Open("/tmp/ex1.1.xls");

Real xls::ActivateWS(1);

Set xls::ReadSeriesByCol( 1, 1, 12, 2, W, "" );



// Miercoles, 2011/05/18 22:24:22.00
#Require TolExcel;

TolExcel::@WorkBook xls = TolExcel::@WorkBook::Open("/tmp/ex1.xls");

Real xls::ActivateWS(1);

Set xls::ReadSeriesByCol( 1, 1, 12, 2, W, "" );



// Miercoles, 2011/05/18 22:07:37.00
Date d = xls2::ReadDate( 1, 1 );

// Miercoles, 2011/05/18 22:07:10.00
TolExcel::@WorkBook xls2 = TolExcel::@WorkBook::Open("/tmp/ex2.xls");
Real xls2::ActivateWS(1);
Date d = xls2::ReadCell( 1, 1 );

// Miercoles, 2011/05/18 22:06:17.00
TolExcel::@WorkBook xls2 = TolExcel::@WorkBook::Open("/tmp/ex2.xls");
Real xls2::ActivateWS(1);
Date d = xls2::ReadCell( 1, 1 );

// Miercoles, 2011/05/18 22:04:02.00
Set ser.dates = MatSerSet(Tra(data), tms.dates, dates_[1]);

// Miercoles, 2011/05/18 22:03:58.00
TimeSet tms.dates = DatesOfSet(dates_);

// Miercoles, 2011/05/18 22:01:02.00
Set dates_ = Traspose(xls::ReadRange(2,1,11,1,dateType))[1];

// Miercoles, 2011/05/18 22:00:57.00
Set dateType = If( Grammar( firstDate ) == "Text", [[""]], [[y2000]] );

// Miercoles, 2011/05/18 22:00:51.00
Anything firstDate = xls::ReadCell( 2, 1 );

// Miercoles, 2011/05/18 22:00:48.00
Real xls::ActivateWS(1);

Set xls::ReadSeriesByCol( 1, 1, 12, 2, W, "" );

Matrix data = xls::ReadMatrix( 2, 2, 11,1);

// Miercoles, 2011/05/18 22:00:42.00
TolExcel::@WorkBook xls = TolExcel::@WorkBook::Open("/tmp/ex1.xls");

// Miercoles, 2011/05/18 21:57:02.00
Set ser.dates = MatSerSet(Tra(data), tms.dates, dates_[1]);

// Miercoles, 2011/05/18 21:56:12.00
TimeSet tms.dates = DatesOfSet(dates_);

// Miercoles, 2011/05/18 21:55:37.00
TimeSet tms.dates = DatesOfSet(dates);

// Miercoles, 2011/05/18 21:53:45.00
Set dates_ = Traspose(xls::ReadRange(2,1,11,1,dateType))[1];

// Miercoles, 2011/05/18 21:53:02.00
Set dateType = If( Grammar( firstDate ) == "Text", [[""]], [[y2000]] );

// Miercoles, 2011/05/18 21:52:43.00
Anything firstDate = xls::ReadCell( 2, 1 );

// Miercoles, 2011/05/18 21:52:33.00
Anything firstDate = ReadCell( 2, 1 );

// Miercoles, 2011/05/18 21:51:26.00
Matrix data = xls::ReadMatrix( 2, 2, 11,1);

// Miercoles, 2011/05/18 21:48:52.00
Set xls::ReadSeriesByCol( 1, 1, 12, 2, W, "" );

// Miercoles, 2011/05/18 21:48:39.00
Set xls::ReadSeriesByCol( 1, 1, 12, 2, "" );

// Miercoles, 2011/05/18 21:48:33.00
TolExcel::@WorkBook xls = TolExcel::@WorkBook::Open("/tmp/ex1.xls");

Real xls::ActivateWS(1);


// Miercoles, 2011/05/18 21:46:49.00
#Require TolExcel


// Miercoles, 2011/05/18 21:42:19.00
#Require TolExcel


// Miercoles, 2011/05/18 21:35:54.00
Anything xls::ReadCell( 2, 1 );

// Miercoles, 2011/05/18 21:35:29.00
Date d2 = xls::ReadDate(2, 1 );


// Miercoles, 2011/05/18 21:35:14.00
Date d1 = xls::ReadDate(2, 1 );


// Miercoles, 2011/05/18 21:34:00.00
Date d1 = xls::ReadDate(2, 1 );


// Miercoles, 2011/05/18 21:33:26.00
Date d1 = xls::ReadDate(2, 1 );


// Miercoles, 2011/05/18 21:32:46.00
Date d = xls::ReadDate(2, 1 );


// Miercoles, 2011/05/18 21:32:28.00
Date d = wb::ReadDate(2, 1 );


// Miercoles, 2011/05/18 21:31:18.00
Anything aa = wb::ReadCell(2, 1 );


// Miercoles, 2011/05/18 21:19:28.00
Set wb::ReadRange(2, 1, 19, 1, [[ "" ]] );

// Miercoles, 2011/05/18 21:19:00.00
Set wb::ReadRange(2, 1, 19, 1, numSer, [[ "" ]] );

// Tuesday, 2011/05/17 14:09:34.00
Text ChartAsACF( MA1TeoACF );

// Sunday, 2011/05/15 21:04:38.00
Serie SubFact_2W = DatCh(SubFact,D22_2W,FirstS);

// Sunday, 2011/05/15 20:15:30.00
TimeSet Range(D(22),0,13)


// Sunday, 2011/05/15 20:15:16.00
Range(D(22),0,13)

// Friday, 2011/05/13 00:27:46.00
Text Version;

Real TolPackage::Client::DownloadCompatibleDeepDependencies( "/tmp/", 0, "v2.0.1 b.1", [[ "MMS" ]] );


// Friday, 2011/05/13 00:27:27.00
Text Version;

Real TolPackage::Client::DownloadCompatibleDeepDependencies( "/tmp/MMS_Root", 0, "v2.0.1 b.1", [[ "MMS" ]] );


// Friday, 2011/05/13 00:26:07.00
Text Version;

Real TolPackage::Client::DownloadCompatibleDeepDependencies( "/tmp/MMS_Root", 0, "v2.0.1 b.1", [[ "MMS" ]] );


// Friday, 2011/05/13 00:24:51.00
Text Version;

// Friday, 2011/05/13 00:24:37.00
Real TolPackage::Client::DownloadCompatibleDeepDependencies( "/tmp/MMS_Root", 0, "2.0.1 b1", [[ "MMS" ]] );


// Wednesday, 2011/05/11 09:41:46.00
Real TolPackage::Client::RemoteUpgradeAll(1);


// Wednesday, 2011/05/11 09:41:29.00
Real TolPackage::Client::UpgradeAll(1);


// Wednesday, 2011/05/11 08:45:46.00
Set holDates = Dates( festivos, y2006, y2008m12d05 );
Set holPulses = EvalSet( holDates, Serie( Date d ) {
  Text name = "Pulso_Festivos_" << d;
  Serie aux = Pulse( d, Diario );
  Serie PutName( name, aux )
} );

// Wednesday, 2011/05/11 08:45:01.00
Text "Pulso_Festivos" << y2006;

// Wednesday, 2011/05/11 08:31:44.00
Serie residual = estimation["Series"]["Residuals"];


// Lunes, 2011/05/09 21:00:49.00
TimeSet W;

// Lunes, 2011/05/09 20:59:37.00
Set Include( "/tmp/data.oza" );


// Lunes, 2011/05/09 19:37:30.00
Set Include( "/tmp/data.oza" );


// Lunes, 2011/05/09 19:35:28.00
 Set GenOza(Real cut)
 {
   Serie ser = SubSer(Gaussian(10, 1, Daily), y2006, y2008m12d31);

   Serie serCut = DatCh(ser, D(If(cut == 1, cut, cut -1)), FirstS);
   SetOfSerie
   (
     serCut
   )
 };

 Set data = GenOza(16);
 Real Ois.Store(data, "/tmp/data.oza");


// Sabado, 2011/05/07 23:38:00.00
TimeSet W;



// Sabado, 2011/05/07 23:13:13.00
Serie CalInd( W, Daily );


// Sabado, 2011/05/07 23:10:00.00
Serie CalInd( W, Diario );


// Sabado, 2011/05/07 23:08:51.00
Serie CalInd( W, Diario );


// Sabado, 2011/05/07 23:07:58.00
Serie CalInd( W, Diario );


// Sabado, 2011/05/07 23:07:38.00
Serie CalInd( W, Diario );


// Sabado, 2011/05/07 23:06:53.00
Serie CalInd( W, Diario );


// Sabado, 2011/05/07 23:05:20.00
Serie CalInd( W, Diario );


// Sabado, 2011/05/07 23:04:33.00
Serie CalInd( W, Diario );


// Sabado, 2011/05/07 23:04:26.00
Serie Calnd( W, Diario );


// Sabado, 2011/05/07 23:01:27.00
Serie CalInd( W, Diario );


// Miercoles, 2011/05/04 19:41:31.00
Set GetArimaFromLabel( "P1_52DIF1_1AR0_0MA0_52" );


// Lunes, 2011/05/02 14:45:42.00
#Require BysVecLinReg;



// Jueves, 2011/04/28 21:02:04.00
Set GetArimaFromLabel( "P1DIF1AR0MA0" );


// Martes, 2011/04/19 18:57:56.00
#Require MMS;


// Martes, 2011/04/19 16:34:49.00
Text {
  Real lower_vol3g = -1;
  Real lower_duracion_voz = -1;
  Real lower_cob_ba = -1;
  Real is_estim = 1;
  Text period = "monthly_mean_2010";
  Text file.suffix = "";
  Real pob_threshold = 20000;
  Real bts_group = -1;
  Text G1 = FormatReal( pob_threshold, "%.0f" );
  Real needs_where = 0;
  Text cond_grp =
    If( bts_group < 0,
        "", {
          If( needs_where,
            { Real needs_where:=0;Text " WHERE " },
            Text " AND " ) +
            "g.bts_group=" + FormatReal( bts_group, "%.0f" ) } );
  Text cond_v3g =
    If( lower_vol3g < 0,
        "", {
          If( needs_where,
            { Real needs_where:=0;Text " WHERE " },
            Text " AND " ) +
            "t.qt_vol_umts>" << lower_vol3g } );
  Text cond_duracion_voz =
    If( lower_duracion_voz < 0,
        "",
        If( needs_where,
          { Real needs_where:=0;Text " WHERE " },
          Text " AND " ) +
        "t.qt_duracion_voz_gsm + t.qt_duracion_voz_umts>"<<
        lower_duracion_voz );
  Text cond_cob_ba =
    If( lower_cob_ba < 0,
        "",
        If( needs_where,
          { Real needs_where:=0;Text " WHERE " },
          Text " AND " ) +
        "t.perc_cob_ba_umts>" << lower_cob_ba );

  Text query =
"
SELECT 
 t.id_bts,
 t.qt_lineas_gprs as qt_lineas_datos_gprs,
 t.qt_lineas_umts as qt_lineas_datos_umts,
 tt.qt_lineas_umts as qt_lineas_datos_umts_tarifa,
 t.qt_vol_gprs/(1024*1024) as qt_vol_gprs,
 tt.qt_vol_gprs/(1024*1024) as qt_vol_gprs_tarifa,
 t.qt_vol_umts/(1024*1024) as qt_vol_umts,
 tt.qt_vol_umts/(1024*1024) as qt_vol_umts_tarifa,
 t.qt_vol_gprs_pot/(1024*1024) AS qt_vol_gprs_pot,
 t.qt_vol_umts_pot_0/(1024*1024) AS qt_vol_umts_pot_0,
 t.qt_vol_umts_pot_1/(1024*1024) AS qt_vol_umts_pot_1,
 t.qt_vol_umts_pot_2/(1024*1024) AS qt_vol_umts_pot_2,
 t.qt_lineas_censored as qt_lineas_censored ,
 t.qt_vol_umts_censored/(1024*1024) AS qt_vol_umts_censored,
 t.qt_lineas_voz_gsm,
 tt.qt_lineas_voz_gsm AS qt_lineas_voz_gsm_tarifa,
 t.qt_lineas_voz_umts,
 tt.qt_lineas_voz_umts AS qt_lineas_voz_umts_tarifa,
 t.qt_duracion_voz_gsm, 
 tt.qt_duracion_voz_gsm AS qt_duracion_voz_gsm_tarifa, 
 t.qt_duracion_voz_umts,
 tt.qt_duracion_voz_umts AS qt_duracion_voz_umts_tarifa,
 t.qt_llamadas_voz_gsm,
 t.qt_llamadas_voz_umts, 
 t.qt_locales_gprs,
 t.qt_locales_umts,
 t.qt_rtb_total0_gprs,
 t.qt_rtb_total0_umts,
 t.qt_adsl_total_gprs,
 t.qt_adsl_total_umts,
 t.qt_rtb_empresas_gprs AS qt_rtb_nres_gprs,
 t.qt_rtb_empresas_umts AS qt_rtb_nres_umts,
 t.qt_adsl_empresa_gprs AS qt_adsl_nres_gprs,
 t.qt_adsl_empresa_umts AS qt_adsl_nres_umts,
 t.qt_poblacion_gprs,
 t.qt_poblacion_umts,
 t.qt_rtb_total_gprs AS qt_lineas_rtb_gprs,
 t.qt_rtb_total_umts AS qt_lineas_rtb_umts,
 t.perc_cob_ba_gprs, 
 t.perc_cob_ba_umts, 
 t.qt_pob_no_cob_ba_gprs,
 t.qt_pob_no_cob_ba_umts,
 t.perc_tm0_gprs,
 t.perc_tm0_umts,
 t.perc_tm1_gprs,
 t.perc_tm1_umts,
 t.perc_tm2_gprs,
 t.perc_tm2_umts,
 t.perc_tm3_gprs,
 t.perc_tm3_umts,
 t.perc_tm4_gprs,
 t.perc_tm4_umts,
 t.perc_tm5_gprs,
 t.perc_tm5_umts,
 t.perc_tm6_gprs,
 t.perc_tm6_umts,
 t.perc_tm7_gprs,
 t.perc_tm7_umts,
 t.perc_tm8_gprs,
 t.perc_tm8_umts,
 t.perc_tm9_gprs,
 t.perc_tm9_umts,
 v.qt_duracion_voz_tot_tar_dia,
 v.qt_duracion_voz_tot_tar_plana,
 v.qt_duracion_voz_tot_big_scr,
 v.qt_duracion_voz_tot_iphone_small_scr,
 v.qt_lineas_voz_tot_tar_dia,
 v.qt_lineas_voz_tot_tar_plana,
 v.qt_lineas_voz_tot_big_scr,
 v.qt_lineas_voz_tot_iphone_small_scr,
 v.qt_vol_umts_pot_big_scr/(1024*1024) as qt_vol_umts_pot_big_scr,
 v.qt_vol_umts_censored_big_scr/(1024*1024) as qt_vol_umts_censored_big_scr,
 v.qt_lineas_censored_big_scr, 
 sc.qt_poblacion_sc_2g,
 sc.qt_poblacion_sc_3g,
 sc.qt_locales_sc_2g,
 sc.qt_locales_sc_3g,
 sc.qt_hogares_sc_2g,
 sc.qt_hogares_sc_3g,
 sc.vl_dim_status_sc_pob_avg_2g,
 sc.vl_dim_status_sc_pob_avg_3g,
 sc.vl_dim_juventud_sc_pob_avg_2g,
 sc.vl_dim_juventud_sc_pob_avg_3g,
 sc.qt_pob_sc_tipol_1_2g,
 sc.qt_pob_sc_tipol_1_3g,
 sc.qt_pob_sc_tipol_2_2g,
 sc.qt_pob_sc_tipol_2_3g,
 sc.qt_pob_sc_tipol_3_2g,
 sc.qt_pob_sc_tipol_3_3g,
 sc.qt_pob_sc_tipol_4_2g,
 sc.qt_pob_sc_tipol_4_3g,
 sc.qt_pob_sc_tipol_5_2g,
 sc.qt_pob_sc_tipol_5_3g,
 sc.qt_pob_sc_tipol_6_2g,
 sc.qt_pob_sc_tipol_6_3g,
 sc.qt_pob_sc_tipol_7_2g,
 sc.qt_pob_sc_tipol_7_3g,
 sc.qt_pob_sc_tipol_8_2g,
 sc.qt_pob_sc_tipol_8_3g,
 sc.qt_pob_sc_tipol_9_2g,
 sc.qt_pob_sc_tipol_9_3g,
 sc.qt_pob_sc_tipol_10_2g,
 sc.qt_pob_sc_tipol_10_3g,
 sc.qt_pob_sc_tipol_11_2g,
 sc.qt_pob_sc_tipol_11_3g,
 sc.qt_pob_sc_tipol_12_2g,
 sc.qt_pob_sc_tipol_12_3g,
 sc.qt_pob_sc_tipol_13_2g,
 sc.qt_pob_sc_tipol_13_3g,                                                                             
 sc.qt_pob_sc_tipol_14_2g,
 sc.qt_pob_sc_tipol_14_3g, 
 sc.qt_pob_sc_tipol_15_2g,
 sc.qt_pob_sc_tipol_15_3g,            
 sc.qt_lineas_res_sc_2g,
 sc.qt_lineas_res_sc_3g,
 sc.qt_lineas_nre_sc_2g,
 sc.qt_lineas_nre_sc_3g,                                   
 sc.qt_cob_adsl_te_res_sc_2g,
 sc.qt_cob_adsl_te_res_sc_3g, 
 sc.qt_cob_adsl_te_nre_sc_2g,
 sc.qt_cob_adsl_te_nre_sc_3g, 
 sc.qt_obad_y_n_res_sc_2g,
 sc.qt_obad_y_n_res_sc_3g, 
 sc.qt_obad_y_n_nre_sc_2g,
 sc.qt_obad_y_n_nre_sc_3g, 
 sc.qt_cable_res_sc_2g,
 sc.qt_cable_res_sc_3g, 
 sc.qt_cable_nre_sc_2g,
 sc.qt_cable_nre_sc_3g,   
 sc.qt_banda_ancha_res_sc_2g,
 sc.qt_banda_ancha_res_sc_3g,              
 sc.qt_banda_ancha_nre_sc_2g,
 sc.qt_banda_ancha_nre_sc_3g, 
 sc.qt_cob_ba_estim_res_sc_2g,
 sc.qt_cob_ba_estim_res_sc_3g,          
 sc.qt_cob_ba_estim_nre_sc_2g,
 sc.qt_cob_ba_estim_nre_sc_3g,
 vias.ind_via_autopista, 
 vias.ind_via_autovia, 
 vias.ind_via_ctra_nac, 
 vias.ind_via_ctra_auton, 
 vias.ind_via_ctra_local,
 vias.invkm_via_autopista, 
 vias.invkm_via_autovia, 
 vias.invkm_via_ctra_nac, 
 vias.invkm_via_ctra_auton, 
 vias.invkm_via_ctra_local
FROM 
marzo2011.table_modelo_bts_" + period + " t 
LEFT OUTER JOIN	marzo2011.view_bts_sc_vars_" + period + " sc
                ON  t.id_bts = sc.id_bts
LEFT OUTER JOIN (
				SELECT CAST(etv.id_emplazamiento AS INTEGER) AS id_bts, 
					   -- etv.id_tramo_via,
					   -- gtv.id_via,   
					   CASE WHEN gv.no_via LIKE 'AUTOPISTA%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_autopista, 
					   CASE WHEN gv.no_via LIKE 'AUTOVIA%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_autovia, 
					   CASE WHEN gv.no_via LIKE 'CTRA. NACIONAL%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_ctra_nac, 
					   CASE WHEN gv.no_via LIKE 'CTRA. AUTON%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_ctra_auton, 
					   CASE WHEN gv.no_via LIKE 'CTRA. LOCAL%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_ctra_local, 
					   etv.vl_distancia_via,
					   CASE WHEN gv.no_via LIKE 'AUTOPISTA%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END  AS invkm_via_autopista, 
					   CASE WHEN gv.no_via LIKE 'AUTOVIA%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END AS invkm_via_autovia, 
					   CASE WHEN gv.no_via LIKE 'CTRA. NACIONAL%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END AS invkm_via_ctra_nac, 
					   CASE WHEN gv.no_via LIKE 'CTRA. AUTON%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END AS invkm_via_ctra_auton, 
					   CASE WHEN gv.no_via LIKE 'CTRA. LOCAL%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END AS invkm_via_ctra_local 	   
				FROM emp_f_emplazamiento_tramo_via etv
					 INNER JOIN
					 ges_d_tramo_via gtv
					 ON etv.id_tramo_via = gtv.id_tramo_via
					 INNER JOIN
					 ges_d_via gv
					 ON gtv.id_via = gv.id_via 
	            ) vias
				ON t.id_bts = vias.id_bts, " +
"marzo2011.table_modelo_bts_tarifa_" + period + " tt, marzo2011.fun_bts_group("+G1+") g,  "+
	"
	(
	select id_bts,
	   sum(case when tarifa = 'Tarifa Diaria' 
				then qt_duracion_voz_gsm + qt_duracion_voz_umts 
				else 0 end) as qt_duracion_voz_tot_tar_dia,
	   sum(case when tarifa != 'Tarifa Diaria' 
				then qt_duracion_voz_gsm + qt_duracion_voz_umts 
				else 0 end) as qt_duracion_voz_tot_tar_plana,
	   sum(case when tarifa = 'Big Screen' 
				then qt_duracion_voz_gsm + qt_duracion_voz_umts 
				else 0 end) as qt_duracion_voz_tot_big_scr,
	   sum(case when tarifa in ( 'iPhone', 'Small Screen' )
				then qt_duracion_voz_gsm + qt_duracion_voz_umts 
				else 0 end) as qt_duracion_voz_tot_iphone_small_scr,									
	   sum(case when tarifa = 'Tarifa Diaria' 
				then qt_lineas_voz_gsm + qt_lineas_voz_umts 
				else 0 end) as qt_lineas_voz_tot_tar_dia,
	   sum(case when tarifa != 'Tarifa Diaria' 
				then qt_lineas_voz_gsm + qt_lineas_voz_umts 
				else 0 end) as qt_lineas_voz_tot_tar_plana,
	   sum(case when tarifa = 'Big Screen' 
				then qt_lineas_voz_gsm + qt_lineas_voz_umts 
				else 0 end) as qt_lineas_voz_tot_big_scr,
	   sum(case when tarifa in ( 'iPhone', 'Small Screen' )
				then qt_lineas_voz_gsm + qt_lineas_voz_umts 
				else 0 end) as qt_lineas_voz_tot_iphone_small_scr,
	   sum(case when tarifa = 'Big Screen' 
				then qt_vol_umts_pot_0 + qt_vol_umts_pot_1 + qt_vol_umts_pot_2 
				else 0 end) as qt_vol_umts_pot_big_scr,
	   sum(case when tarifa = 'Big Screen' 
				then qt_vol_umts_censored 
				else 0 end) as qt_vol_umts_censored_big_scr,
	   sum(case when tarifa = 'Big Screen' 
				then qt_lineas_censored 
				else 0 end) as qt_lineas_censored_big_scr 								
	from marzo2011.table_modelo_bts_tarifa_" + period + "
	group by id_bts
	) v
WHERE t.id_bts = g.id_bts AND 
       t.id_bts = tt.id_bts AND 
	   t.id_bts = v.id_bts "
	   + cond_grp + cond_v3g + cond_duracion_voz + cond_cob_ba

}



// Martes, 2011/04/19 16:29:24.00
Text {
  Real lower_vol3g = -1;
  Real lower_duracion_voz = -1;
  Real lower_cob_ba = -1;
  Real is_estim = 1;
  Text period = "monthly_mean_2010";
  Text file.suffix = "";
  Real pob_threshold = 20000;
  Real bts_group = -1;
  Text G1 = FormatReal( pob_threshold, "%.0f" );
  Real needs_where = 0;
  Text cond_grp =
    If( bts_group < 0,
        "", {
          If( needs_where,
            { Real needs_where:=0;Text " WHERE " },
            Text " AND " ) +
            "g.bts_group=" + FormatReal( bts_group, "%.0f" ) } );
  Text cond_v3g =
    If( lower_vol3g < 0,
        "", {
          If( needs_where,
            { Real needs_where:=0;Text " WHERE " },
            Text " AND " ) +
            "t.qt_vol_umts>" << lower_vol3g } );
  Text cond_duracion_voz =
    If( lower_duracion_voz < 0,
        "",
        If( needs_where,
          { Real needs_where:=0;Text " WHERE " },
          Text " AND " ) +
        "t.qt_duracion_voz_gsm + t.qt_duracion_voz_umts>"<<
        lower_duracion_voz );
  Text cond_cob_ba =
    If( lower_cob_ba < 0,
        "",
        If( needs_where,
          { Real needs_where:=0;Text " WHERE " },
          Text " AND " ) +
        "t.perc_cob_ba_umts>" << lower_cob_ba );
  Text query =
"
SELECT 
 t.id_bts,
 t.qt_lineas_gprs as qt_lineas_datos_gprs,
 t.qt_lineas_umts as qt_lineas_datos_umts,
 t.qt_vol_gprs/(1024*1024) as qt_vol_gprs,
 t.qt_vol_umts/(1024*1024) as qt_vol_umts,
 t.qt_vol_gprs_pot/(1024*1024) AS qt_vol_gprs_pot,
 t.qt_vol_umts_pot_0/(1024*1024) AS qt_vol_umts_pot_0,
 t.qt_vol_umts_pot_1/(1024*1024) AS qt_vol_umts_pot_1,
 t.qt_vol_umts_pot_2/(1024*1024) AS qt_vol_umts_pot_2,
 t.qt_lineas_censored as qt_lineas_censored ,
 t.qt_vol_umts_censored/(1024*1024) AS qt_vol_umts_censored,
 t.qt_lineas_voz_gsm,
 t.qt_lineas_voz_umts,
 t.qt_duracion_voz_gsm, 
 t.qt_duracion_voz_umts,
 t.qt_llamadas_voz_gsm,
 t.qt_llamadas_voz_umts, 
 t.qt_locales_gprs,
 t.qt_locales_umts,
 t.qt_rtb_total0_gprs,
 t.qt_rtb_total0_umts,
 t.qt_adsl_total_gprs,
 t.qt_adsl_total_umts,
 t.qt_rtb_empresas_gprs AS qt_rtb_nres_gprs,
 t.qt_rtb_empresas_umts AS qt_rtb_nres_umts,
 t.qt_adsl_empresa_gprs AS qt_adsl_nres_gprs,
 t.qt_adsl_empresa_umts AS qt_adsl_nres_umts,
 t.qt_poblacion_gprs,
 t.qt_poblacion_umts,
 t.qt_rtb_total_gprs AS qt_lineas_rtb_gprs,
 t.qt_rtb_total_umts AS qt_lineas_rtb_umts,
 t.perc_cob_ba_gprs, 
 t.perc_cob_ba_umts, 
 t.qt_pob_no_cob_ba_gprs,
 t.qt_pob_no_cob_ba_umts,
 t.perc_tm0_gprs,
 t.perc_tm0_umts,
 t.perc_tm1_gprs,
 t.perc_tm1_umts,
 t.perc_tm2_gprs,
 t.perc_tm2_umts,
 t.perc_tm3_gprs,
 t.perc_tm3_umts,
 t.perc_tm4_gprs,
 t.perc_tm4_umts,
 t.perc_tm5_gprs,
 t.perc_tm5_umts,
 t.perc_tm6_gprs,
 t.perc_tm6_umts,
 t.perc_tm7_gprs,
 t.perc_tm7_umts,
 t.perc_tm8_gprs,
 t.perc_tm8_umts,
 t.perc_tm9_gprs,
 t.perc_tm9_umts,
 v.qt_duracion_voz_tot_tar_dia,
 v.qt_duracion_voz_tot_tar_plana,
 v.qt_duracion_voz_tot_big_scr,
 v.qt_duracion_voz_tot_iphone_small_scr,
 v.qt_lineas_voz_tot_tar_dia,
 v.qt_lineas_voz_tot_tar_plana,
 v.qt_lineas_voz_tot_big_scr,
 v.qt_lineas_voz_tot_iphone_small_scr,
 v.qt_vol_umts_pot_big_scr/(1024*1024) as qt_vol_umts_pot_big_scr,
 v.qt_vol_umts_censored_big_scr/(1024*1024) as qt_vol_umts_censored_big_scr,
 v.qt_lineas_censored_big_scr, 
 sc.qt_poblacion_sc_2g,
 sc.qt_poblacion_sc_3g,
 sc.qt_locales_sc_2g,
 sc.qt_locales_sc_3g,
 sc.qt_hogares_sc_2g,
 sc.qt_hogares_sc_3g,
 sc.vl_dim_status_sc_pob_avg_2g,
 sc.vl_dim_status_sc_pob_avg_3g,
 sc.vl_dim_juventud_sc_pob_avg_2g,
 sc.vl_dim_juventud_sc_pob_avg_3g,
 sc.qt_pob_sc_tipol_1_2g,
 sc.qt_pob_sc_tipol_1_3g,
 sc.qt_pob_sc_tipol_2_2g,
 sc.qt_pob_sc_tipol_2_3g,
 sc.qt_pob_sc_tipol_3_2g,
 sc.qt_pob_sc_tipol_3_3g,
 sc.qt_pob_sc_tipol_4_2g,
 sc.qt_pob_sc_tipol_4_3g,
 sc.qt_pob_sc_tipol_5_2g,
 sc.qt_pob_sc_tipol_5_3g,
 sc.qt_pob_sc_tipol_6_2g,
 sc.qt_pob_sc_tipol_6_3g,
 sc.qt_pob_sc_tipol_7_2g,
 sc.qt_pob_sc_tipol_7_3g,
 sc.qt_pob_sc_tipol_8_2g,
 sc.qt_pob_sc_tipol_8_3g,
 sc.qt_pob_sc_tipol_9_2g,
 sc.qt_pob_sc_tipol_9_3g,
 sc.qt_pob_sc_tipol_10_2g,
 sc.qt_pob_sc_tipol_10_3g,
 sc.qt_pob_sc_tipol_11_2g,
 sc.qt_pob_sc_tipol_11_3g,
 sc.qt_pob_sc_tipol_12_2g,
 sc.qt_pob_sc_tipol_12_3g,
 sc.qt_pob_sc_tipol_13_2g,
 sc.qt_pob_sc_tipol_13_3g,                                                                             
 sc.qt_pob_sc_tipol_14_2g,
 sc.qt_pob_sc_tipol_14_3g, 
 sc.qt_pob_sc_tipol_15_2g,
 sc.qt_pob_sc_tipol_15_3g,            
 sc.qt_lineas_res_sc_2g,
 sc.qt_lineas_res_sc_3g,
 sc.qt_lineas_nre_sc_2g,
 sc.qt_lineas_nre_sc_3g,                                   
 sc.qt_cob_adsl_te_res_sc_2g,
 sc.qt_cob_adsl_te_res_sc_3g, 
 sc.qt_cob_adsl_te_nre_sc_2g,
 sc.qt_cob_adsl_te_nre_sc_3g, 
 sc.qt_obad_y_n_res_sc_2g,
 sc.qt_obad_y_n_res_sc_3g, 
 sc.qt_obad_y_n_nre_sc_2g,
 sc.qt_obad_y_n_nre_sc_3g, 
 sc.qt_cable_res_sc_2g,
 sc.qt_cable_res_sc_3g, 
 sc.qt_cable_nre_sc_2g,
 sc.qt_cable_nre_sc_3g,   
 sc.qt_banda_ancha_res_sc_2g,
 sc.qt_banda_ancha_res_sc_3g,              
 sc.qt_banda_ancha_nre_sc_2g,
 sc.qt_banda_ancha_nre_sc_3g, 
 sc.qt_cob_ba_estim_res_sc_2g,
 sc.qt_cob_ba_estim_res_sc_3g,          
 sc.qt_cob_ba_estim_nre_sc_2g,
 sc.qt_cob_ba_estim_nre_sc_3g,
 vias.ind_via_autopista, 
 vias.ind_via_autovia, 
 vias.ind_via_ctra_nac, 
 vias.ind_via_ctra_auton, 
 vias.ind_via_ctra_local,
 vias.invkm_via_autopista, 
 vias.invkm_via_autovia, 
 vias.invkm_via_ctra_nac, 
 vias.invkm_via_ctra_auton, 
 vias.invkm_via_ctra_local
FROM 
marzo2011.table_modelo_bts_" + period +
" t LEFT OUTER JOIN	marzo2011.view_bts_sc_vars_" + period + " sc
                    ON  t.id_bts = sc.id_bts
    LEFT OUTER JOIN (
					SELECT CAST(etv.id_emplazamiento AS INTEGER) AS id_bts, 
						   -- etv.id_tramo_via,
						   -- gtv.id_via,   
						   CASE WHEN gv.no_via LIKE 'AUTOPISTA%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_autopista, 
						   CASE WHEN gv.no_via LIKE 'AUTOVIA%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_autovia, 
						   CASE WHEN gv.no_via LIKE 'CTRA. NACIONAL%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_ctra_nac, 
						   CASE WHEN gv.no_via LIKE 'CTRA. AUTON%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_ctra_auton, 
						   CASE WHEN gv.no_via LIKE 'CTRA. LOCAL%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_ctra_local, 
						   etv.vl_distancia_via,
						   CASE WHEN gv.no_via LIKE 'AUTOPISTA%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END  AS invkm_via_autopista, 
						   CASE WHEN gv.no_via LIKE 'AUTOVIA%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END AS invkm_via_autovia, 
						   CASE WHEN gv.no_via LIKE 'CTRA. NACIONAL%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END AS invkm_via_ctra_nac, 
						   CASE WHEN gv.no_via LIKE 'CTRA. AUTON%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END AS invkm_via_ctra_auton, 
						   CASE WHEN gv.no_via LIKE 'CTRA. LOCAL%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END AS invkm_via_ctra_local 	   
					FROM emp_f_emplazamiento_tramo_via etv
						 INNER JOIN
						 ges_d_tramo_via gtv
						 ON etv.id_tramo_via = gtv.id_tramo_via
						 INNER JOIN
						 ges_d_via gv
						 ON gtv.id_via = gv.id_via 
	            ) vias
	ON t.id_bts = vias.id_bts,					
	marzo2011.fun_bts_group("+G1+") g,  "+
	"
	(
	select id_bts,
	   sum(case when tarifa = 'Tarifa Diaria' 
				then qt_duracion_voz_gsm + qt_duracion_voz_umts 
				else 0 end) as qt_duracion_voz_tot_tar_dia,
	   sum(case when tarifa != 'Tarifa Diaria' 
				then qt_duracion_voz_gsm + qt_duracion_voz_umts 
				else 0 end) as qt_duracion_voz_tot_tar_plana,
	   sum(case when tarifa = 'Big Screen' 
				then qt_duracion_voz_gsm + qt_duracion_voz_umts 
				else 0 end) as qt_duracion_voz_tot_big_scr,
	   sum(case when tarifa in ( 'iPhone', 'Small Screen' )
				then qt_duracion_voz_gsm + qt_duracion_voz_umts 
				else 0 end) as qt_duracion_voz_tot_iphone_small_scr,									
	   sum(case when tarifa = 'Tarifa Diaria' 
				then qt_lineas_voz_gsm + qt_lineas_voz_umts 
				else 0 end) as qt_lineas_voz_tot_tar_dia,
	   sum(case when tarifa != 'Tarifa Diaria' 
				then qt_lineas_voz_gsm + qt_lineas_voz_umts 
				else 0 end) as qt_lineas_voz_tot_tar_plana,
	   sum(case when tarifa = 'Big Screen' 
				then qt_lineas_voz_gsm + qt_lineas_voz_umts 
				else 0 end) as qt_lineas_voz_tot_big_scr,
	   sum(case when tarifa in ( 'iPhone', 'Small Screen' )
				then qt_lineas_voz_gsm + qt_lineas_voz_umts 
				else 0 end) as qt_lineas_voz_tot_iphone_small_scr,
	   sum(case when tarifa = 'Big Screen' 
				then qt_vol_umts_pot_0 + qt_vol_umts_pot_1 + qt_vol_umts_pot_2 
				else 0 end) as qt_vol_umts_pot_big_scr,
	   sum(case when tarifa = 'Big Screen' 
				then qt_vol_umts_censored 
				else 0 end) as qt_vol_umts_censored_big_scr,
	   sum(case when tarifa = 'Big Screen' 
				then qt_lineas_censored 
				else 0 end) as qt_lineas_censored_big_scr 								
	from marzo2011.table_modelo_bts_tarifa_" + period + "
	group by id_bts
	) v
WHERE t.id_bts = g.id_bts "+
"AND t.id_bts = v.id_bts " +
cond_grp + cond_v3g + cond_duracion_voz + cond_cob_ba
}



// Martes, 2011/04/19 16:22:14.00
Text {
  Real lower_vol3g = -1;
  Real lower_duracion_voz = -1;
  Real lower_cob_ba = -1;
  Real is_estim =  1;
  Text period = "monthly_mean_2010";
  Text file.suffix = "";
  Real pob_threshold = 20000;
  Real bts_group = -1;
  Text G1 = FormatReal( pob_threshold, "%.0f" );
  Real needs_where = 0;
  Text cond_grp =
    If( bts_group < 0,
        "", {
          If( needs_where,
            { Real needs_where:=0;Text " WHERE " },
            Text " AND " ) +
            "g.bts_group=" + FormatReal( bts_group, "%.0f" ) } );
  Text cond_v3g =
    If( lower_vol3g < 0,
        "", {
          If( needs_where,
            { Real needs_where:=0;Text " WHERE " },
            Text " AND " ) +
            "t.qt_vol_umts>" << lower_vol3g } );
  Text cond_duracion_voz =
    If( lower_duracion_voz < 0,
        "",
        If( needs_where,
          { Real needs_where:=0;Text " WHERE " },
          Text " AND " ) +
        "t.qt_duracion_voz_gsm + t.qt_duracion_voz_umts>"<<
        lower_duracion_voz );
  Text cond_cob_ba =
    If( lower_cob_ba < 0,
        "",
        If( needs_where,
          { Real needs_where:=0;Text " WHERE " },
          Text " AND " ) +
        "t.perc_cob_ba_umts>" << lower_cob_ba );
  Text query =
"
SELECT 
 t.id_bts,
 t.qt_lineas_gprs as qt_lineas_datos_gprs,
 t.qt_lineas_umts as qt_lineas_datos_umts,
 t.qt_vol_gprs/(1024*1024) as qt_vol_gprs,
 t.qt_vol_umts/(1024*1024) as qt_vol_umts,
 t.qt_vol_gprs_pot/(1024*1024) AS qt_vol_gprs_pot,
 t.qt_vol_umts_pot_0/(1024*1024) AS qt_vol_umts_pot_0,
 t.qt_vol_umts_pot_1/(1024*1024) AS qt_vol_umts_pot_1,
 t.qt_vol_umts_pot_2/(1024*1024) AS qt_vol_umts_pot_2,
 t.qt_lineas_censored as qt_lineas_censored ,
 t.qt_vol_umts_censored/(1024*1024) AS qt_vol_umts_censored,
 t.qt_lineas_voz_gsm,
 t.qt_lineas_voz_umts,
 t.qt_duracion_voz_gsm, 
 t.qt_duracion_voz_umts,
 t.qt_llamadas_voz_gsm,
 t.qt_llamadas_voz_umts, 
 t.qt_locales_gprs,
 t.qt_locales_umts,
 t.qt_rtb_total0_gprs,
 t.qt_rtb_total0_umts,
 t.qt_adsl_total_gprs,
 t.qt_adsl_total_umts,
 t.qt_rtb_empresas_gprs AS qt_rtb_nres_gprs,
 t.qt_rtb_empresas_umts AS qt_rtb_nres_umts,
 t.qt_adsl_empresa_gprs AS qt_adsl_nres_gprs,
 t.qt_adsl_empresa_umts AS qt_adsl_nres_umts,
 t.qt_poblacion_gprs,
 t.qt_poblacion_umts,
 t.qt_rtb_total_gprs AS qt_lineas_rtb_gprs,
 t.qt_rtb_total_umts AS qt_lineas_rtb_umts,
 t.perc_cob_ba_gprs, 
 t.perc_cob_ba_umts, 
 t.qt_pob_no_cob_ba_gprs,
 t.qt_pob_no_cob_ba_umts,
 t.perc_tm0_gprs,
 t.perc_tm0_umts,
 t.perc_tm1_gprs,
 t.perc_tm1_umts,
 t.perc_tm2_gprs,
 t.perc_tm2_umts,
 t.perc_tm3_gprs,
 t.perc_tm3_umts,
 t.perc_tm4_gprs,
 t.perc_tm4_umts,
 t.perc_tm5_gprs,
 t.perc_tm5_umts,
 t.perc_tm6_gprs,
 t.perc_tm6_umts,
 t.perc_tm7_gprs,
 t.perc_tm7_umts,
 t.perc_tm8_gprs,
 t.perc_tm8_umts,
 t.perc_tm9_gprs,
 t.perc_tm9_umts,
 v.qt_duracion_voz_tot_tar_dia,
 v.qt_duracion_voz_tot_tar_plana,
 v.qt_duracion_voz_tot_big_scr,
 v.qt_duracion_voz_tot_iphone_small_scr,
 v.qt_lineas_voz_tot_tar_dia,
 v.qt_lineas_voz_tot_tar_plana,
 v.qt_lineas_voz_tot_big_scr,
 v.qt_lineas_voz_tot_iphone_small_scr,
 v.qt_vol_umts_pot_big_scr/(1024*1024) as qt_vol_umts_pot_big_scr,
 v.qt_vol_umts_censored_big_scr/(1024*1024) as qt_vol_umts_censored_big_scr,
 v.qt_lineas_censored_big_scr, 
 sc.qt_poblacion_sc_2g,
 sc.qt_poblacion_sc_3g,
 sc.qt_locales_sc_2g,
 sc.qt_locales_sc_3g,
 sc.qt_hogares_sc_2g,
 sc.qt_hogares_sc_3g,
 sc.vl_dim_status_sc_pob_avg_2g,
 sc.vl_dim_status_sc_pob_avg_3g,
 sc.vl_dim_juventud_sc_pob_avg_2g,
 sc.vl_dim_juventud_sc_pob_avg_3g,
 sc.qt_pob_sc_tipol_1_2g,
 sc.qt_pob_sc_tipol_1_3g,
 sc.qt_pob_sc_tipol_2_2g,
 sc.qt_pob_sc_tipol_2_3g,
 sc.qt_pob_sc_tipol_3_2g,
 sc.qt_pob_sc_tipol_3_3g,
 sc.qt_pob_sc_tipol_4_2g,
 sc.qt_pob_sc_tipol_4_3g,
 sc.qt_pob_sc_tipol_5_2g,
 sc.qt_pob_sc_tipol_5_3g,
 sc.qt_pob_sc_tipol_6_2g,
 sc.qt_pob_sc_tipol_6_3g,
 sc.qt_pob_sc_tipol_7_2g,
 sc.qt_pob_sc_tipol_7_3g,
 sc.qt_pob_sc_tipol_8_2g,
 sc.qt_pob_sc_tipol_8_3g,
 sc.qt_pob_sc_tipol_9_2g,
 sc.qt_pob_sc_tipol_9_3g,
 sc.qt_pob_sc_tipol_10_2g,
 sc.qt_pob_sc_tipol_10_3g,
 sc.qt_pob_sc_tipol_11_2g,
 sc.qt_pob_sc_tipol_11_3g,
 sc.qt_pob_sc_tipol_12_2g,
 sc.qt_pob_sc_tipol_12_3g,
 sc.qt_pob_sc_tipol_13_2g,
 sc.qt_pob_sc_tipol_13_3g,                                                                             
 sc.qt_pob_sc_tipol_14_2g,
 sc.qt_pob_sc_tipol_14_3g, 
 sc.qt_pob_sc_tipol_15_2g,
 sc.qt_pob_sc_tipol_15_3g,            
 sc.qt_lineas_res_sc_2g,
 sc.qt_lineas_res_sc_3g,
 sc.qt_lineas_nre_sc_2g,
 sc.qt_lineas_nre_sc_3g,                                   
 sc.qt_cob_adsl_te_res_sc_2g,
 sc.qt_cob_adsl_te_res_sc_3g, 
 sc.qt_cob_adsl_te_nre_sc_2g,
 sc.qt_cob_adsl_te_nre_sc_3g, 
 sc.qt_obad_y_n_res_sc_2g,
 sc.qt_obad_y_n_res_sc_3g, 
 sc.qt_obad_y_n_nre_sc_2g,
 sc.qt_obad_y_n_nre_sc_3g, 
 sc.qt_cable_res_sc_2g,
 sc.qt_cable_res_sc_3g, 
 sc.qt_cable_nre_sc_2g,
 sc.qt_cable_nre_sc_3g,   
 sc.qt_banda_ancha_res_sc_2g,
 sc.qt_banda_ancha_res_sc_3g,              
 sc.qt_banda_ancha_nre_sc_2g,
 sc.qt_banda_ancha_nre_sc_3g, 
 sc.qt_cob_ba_estim_res_sc_2g,
 sc.qt_cob_ba_estim_res_sc_3g,          
 sc.qt_cob_ba_estim_nre_sc_2g,
 sc.qt_cob_ba_estim_nre_sc_3g,
 vias.ind_via_autopista, 
 vias.ind_via_autovia, 
 vias.ind_via_ctra_nac, 
 vias.ind_via_ctra_auton, 
 vias.ind_via_ctra_local,
 vias.invkm_via_autopista, 
 vias.invkm_via_autovia, 
 vias.invkm_via_ctra_nac, 
 vias.invkm_via_ctra_auton, 
 vias.invkm_via_ctra_local
FROM 
marzo2011.table_modelo_bts_" + period +
" t LEFT OUTER JOIN	marzo2011.view_bts_sc_vars_" + period + " sc
                    ON  t.id_bts = sc.id_bts
    LEFT OUTER JOIN (
					SELECT CAST(etv.id_emplazamiento AS INTEGER) AS id_bts, 
						   -- etv.id_tramo_via,
						   -- gtv.id_via,   
						   CASE WHEN gv.no_via LIKE 'AUTOPISTA%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_autopista, 
						   CASE WHEN gv.no_via LIKE 'AUTOVIA%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_autovia, 
						   CASE WHEN gv.no_via LIKE 'CTRA. NACIONAL%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_ctra_nac, 
						   CASE WHEN gv.no_via LIKE 'CTRA. AUTON%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_ctra_auton, 
						   CASE WHEN gv.no_via LIKE 'CTRA. LOCAL%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_ctra_local, 
						   etv.vl_distancia_via,
						   CASE WHEN gv.no_via LIKE 'AUTOPISTA%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END  AS invkm_via_autopista, 
						   CASE WHEN gv.no_via LIKE 'AUTOVIA%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END AS invkm_via_autovia, 
						   CASE WHEN gv.no_via LIKE 'CTRA. NACIONAL%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END AS invkm_via_ctra_nac, 
						   CASE WHEN gv.no_via LIKE 'CTRA. AUTON%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END AS invkm_via_ctra_auton, 
						   CASE WHEN gv.no_via LIKE 'CTRA. LOCAL%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END AS invkm_via_ctra_local 	   
					FROM emp_f_emplazamiento_tramo_via etv
						 INNER JOIN
						 ges_d_tramo_via gtv
						 ON etv.id_tramo_via = gtv.id_tramo_via
						 INNER JOIN
						 ges_d_via gv
						 ON gtv.id_via = gv.id_via 
	            ) vias
	ON t.id_bts = vias.id_bts,					
	marzo2011.fun_bts_group("+G1+") g,  "+
	"
	(
	select id_bts,
	   sum(case when tarifa = 'Tarifa Diaria' 
				then qt_duracion_voz_gsm + qt_duracion_voz_umts 
				else 0 end) as qt_duracion_voz_tot_tar_dia,
	   sum(case when tarifa != 'Tarifa Diaria' 
				then qt_duracion_voz_gsm + qt_duracion_voz_umts 
				else 0 end) as qt_duracion_voz_tot_tar_plana,
	   sum(case when tarifa = 'Big Screen' 
				then qt_duracion_voz_gsm + qt_duracion_voz_umts 
				else 0 end) as qt_duracion_voz_tot_big_scr,
	   sum(case when tarifa in ( 'iPhone', 'Small Screen' )
				then qt_duracion_voz_gsm + qt_duracion_voz_umts 
				else 0 end) as qt_duracion_voz_tot_iphone_small_scr,									
	   sum(case when tarifa = 'Tarifa Diaria' 
				then qt_lineas_voz_gsm + qt_lineas_voz_umts 
				else 0 end) as qt_lineas_voz_tot_tar_dia,
	   sum(case when tarifa != 'Tarifa Diaria' 
				then qt_lineas_voz_gsm + qt_lineas_voz_umts 
				else 0 end) as qt_lineas_voz_tot_tar_plana,
	   sum(case when tarifa = 'Big Screen' 
				then qt_lineas_voz_gsm + qt_lineas_voz_umts 
				else 0 end) as qt_lineas_voz_tot_big_scr,
	   sum(case when tarifa in ( 'iPhone', 'Small Screen' )
				then qt_lineas_voz_gsm + qt_lineas_voz_umts 
				else 0 end) as qt_lineas_voz_tot_iphone_small_scr,
	   sum(case when tarifa = 'Big Screen' 
				then qt_vol_umts_pot_0 + qt_vol_umts_pot_1 + qt_vol_umts_pot_2 
				else 0 end) as qt_vol_umts_pot_big_scr,
	   sum(case when tarifa = 'Big Screen' 
				then qt_vol_umts_censored 
				else 0 end) as qt_vol_umts_censored_big_scr,
	   sum(case when tarifa = 'Big Screen' 
				then qt_lineas_censored 
				else 0 end) as qt_lineas_censored_big_scr 								
	from marzo2011.table_modelo_bts_tarifa_" + period + "
	group by id_bts
	) v
WHERE t.id_bts = g.id_bts "+
"AND t.id_bts = v.id_bts " +
cond_grp + cond_v3g + cond_duracion_voz + cond_cob_ba
}



// Martes, 2011/04/19 16:22:00.00
Text {
  Real lower_vol3g = -1;
  Real lower_duracion_voz = -1;
  Real lower_cob_ba = -1;
  Real is_estim =  1;
  Text period = monthly_mean_2010;
  Text file.suffix = "";
  Real pob_threshold = 20000;
  Real bts_group = -1;
  Text G1 = FormatReal( pob_threshold, "%.0f" );
  Real needs_where = 0;
  Text cond_grp =
    If( bts_group < 0,
        "", {
          If( needs_where,
            { Real needs_where:=0;Text " WHERE " },
            Text " AND " ) +
            "g.bts_group=" + FormatReal( bts_group, "%.0f" ) } );
  Text cond_v3g =
    If( lower_vol3g < 0,
        "", {
          If( needs_where,
            { Real needs_where:=0;Text " WHERE " },
            Text " AND " ) +
            "t.qt_vol_umts>" << lower_vol3g } );
  Text cond_duracion_voz =
    If( lower_duracion_voz < 0,
        "",
        If( needs_where,
          { Real needs_where:=0;Text " WHERE " },
          Text " AND " ) +
        "t.qt_duracion_voz_gsm + t.qt_duracion_voz_umts>"<<
        lower_duracion_voz );
  Text cond_cob_ba =
    If( lower_cob_ba < 0,
        "",
        If( needs_where,
          { Real needs_where:=0;Text " WHERE " },
          Text " AND " ) +
        "t.perc_cob_ba_umts>" << lower_cob_ba );
  Text query =
"
SELECT 
 t.id_bts,
 t.qt_lineas_gprs as qt_lineas_datos_gprs,
 t.qt_lineas_umts as qt_lineas_datos_umts,
 t.qt_vol_gprs/(1024*1024) as qt_vol_gprs,
 t.qt_vol_umts/(1024*1024) as qt_vol_umts,
 t.qt_vol_gprs_pot/(1024*1024) AS qt_vol_gprs_pot,
 t.qt_vol_umts_pot_0/(1024*1024) AS qt_vol_umts_pot_0,
 t.qt_vol_umts_pot_1/(1024*1024) AS qt_vol_umts_pot_1,
 t.qt_vol_umts_pot_2/(1024*1024) AS qt_vol_umts_pot_2,
 t.qt_lineas_censored as qt_lineas_censored ,
 t.qt_vol_umts_censored/(1024*1024) AS qt_vol_umts_censored,
 t.qt_lineas_voz_gsm,
 t.qt_lineas_voz_umts,
 t.qt_duracion_voz_gsm, 
 t.qt_duracion_voz_umts,
 t.qt_llamadas_voz_gsm,
 t.qt_llamadas_voz_umts, 
 t.qt_locales_gprs,
 t.qt_locales_umts,
 t.qt_rtb_total0_gprs,
 t.qt_rtb_total0_umts,
 t.qt_adsl_total_gprs,
 t.qt_adsl_total_umts,
 t.qt_rtb_empresas_gprs AS qt_rtb_nres_gprs,
 t.qt_rtb_empresas_umts AS qt_rtb_nres_umts,
 t.qt_adsl_empresa_gprs AS qt_adsl_nres_gprs,
 t.qt_adsl_empresa_umts AS qt_adsl_nres_umts,
 t.qt_poblacion_gprs,
 t.qt_poblacion_umts,
 t.qt_rtb_total_gprs AS qt_lineas_rtb_gprs,
 t.qt_rtb_total_umts AS qt_lineas_rtb_umts,
 t.perc_cob_ba_gprs, 
 t.perc_cob_ba_umts, 
 t.qt_pob_no_cob_ba_gprs,
 t.qt_pob_no_cob_ba_umts,
 t.perc_tm0_gprs,
 t.perc_tm0_umts,
 t.perc_tm1_gprs,
 t.perc_tm1_umts,
 t.perc_tm2_gprs,
 t.perc_tm2_umts,
 t.perc_tm3_gprs,
 t.perc_tm3_umts,
 t.perc_tm4_gprs,
 t.perc_tm4_umts,
 t.perc_tm5_gprs,
 t.perc_tm5_umts,
 t.perc_tm6_gprs,
 t.perc_tm6_umts,
 t.perc_tm7_gprs,
 t.perc_tm7_umts,
 t.perc_tm8_gprs,
 t.perc_tm8_umts,
 t.perc_tm9_gprs,
 t.perc_tm9_umts,
 v.qt_duracion_voz_tot_tar_dia,
 v.qt_duracion_voz_tot_tar_plana,
 v.qt_duracion_voz_tot_big_scr,
 v.qt_duracion_voz_tot_iphone_small_scr,
 v.qt_lineas_voz_tot_tar_dia,
 v.qt_lineas_voz_tot_tar_plana,
 v.qt_lineas_voz_tot_big_scr,
 v.qt_lineas_voz_tot_iphone_small_scr,
 v.qt_vol_umts_pot_big_scr/(1024*1024) as qt_vol_umts_pot_big_scr,
 v.qt_vol_umts_censored_big_scr/(1024*1024) as qt_vol_umts_censored_big_scr,
 v.qt_lineas_censored_big_scr, 
 sc.qt_poblacion_sc_2g,
 sc.qt_poblacion_sc_3g,
 sc.qt_locales_sc_2g,
 sc.qt_locales_sc_3g,
 sc.qt_hogares_sc_2g,
 sc.qt_hogares_sc_3g,
 sc.vl_dim_status_sc_pob_avg_2g,
 sc.vl_dim_status_sc_pob_avg_3g,
 sc.vl_dim_juventud_sc_pob_avg_2g,
 sc.vl_dim_juventud_sc_pob_avg_3g,
 sc.qt_pob_sc_tipol_1_2g,
 sc.qt_pob_sc_tipol_1_3g,
 sc.qt_pob_sc_tipol_2_2g,
 sc.qt_pob_sc_tipol_2_3g,
 sc.qt_pob_sc_tipol_3_2g,
 sc.qt_pob_sc_tipol_3_3g,
 sc.qt_pob_sc_tipol_4_2g,
 sc.qt_pob_sc_tipol_4_3g,
 sc.qt_pob_sc_tipol_5_2g,
 sc.qt_pob_sc_tipol_5_3g,
 sc.qt_pob_sc_tipol_6_2g,
 sc.qt_pob_sc_tipol_6_3g,
 sc.qt_pob_sc_tipol_7_2g,
 sc.qt_pob_sc_tipol_7_3g,
 sc.qt_pob_sc_tipol_8_2g,
 sc.qt_pob_sc_tipol_8_3g,
 sc.qt_pob_sc_tipol_9_2g,
 sc.qt_pob_sc_tipol_9_3g,
 sc.qt_pob_sc_tipol_10_2g,
 sc.qt_pob_sc_tipol_10_3g,
 sc.qt_pob_sc_tipol_11_2g,
 sc.qt_pob_sc_tipol_11_3g,
 sc.qt_pob_sc_tipol_12_2g,
 sc.qt_pob_sc_tipol_12_3g,
 sc.qt_pob_sc_tipol_13_2g,
 sc.qt_pob_sc_tipol_13_3g,                                                                             
 sc.qt_pob_sc_tipol_14_2g,
 sc.qt_pob_sc_tipol_14_3g, 
 sc.qt_pob_sc_tipol_15_2g,
 sc.qt_pob_sc_tipol_15_3g,            
 sc.qt_lineas_res_sc_2g,
 sc.qt_lineas_res_sc_3g,
 sc.qt_lineas_nre_sc_2g,
 sc.qt_lineas_nre_sc_3g,                                   
 sc.qt_cob_adsl_te_res_sc_2g,
 sc.qt_cob_adsl_te_res_sc_3g, 
 sc.qt_cob_adsl_te_nre_sc_2g,
 sc.qt_cob_adsl_te_nre_sc_3g, 
 sc.qt_obad_y_n_res_sc_2g,
 sc.qt_obad_y_n_res_sc_3g, 
 sc.qt_obad_y_n_nre_sc_2g,
 sc.qt_obad_y_n_nre_sc_3g, 
 sc.qt_cable_res_sc_2g,
 sc.qt_cable_res_sc_3g, 
 sc.qt_cable_nre_sc_2g,
 sc.qt_cable_nre_sc_3g,   
 sc.qt_banda_ancha_res_sc_2g,
 sc.qt_banda_ancha_res_sc_3g,              
 sc.qt_banda_ancha_nre_sc_2g,
 sc.qt_banda_ancha_nre_sc_3g, 
 sc.qt_cob_ba_estim_res_sc_2g,
 sc.qt_cob_ba_estim_res_sc_3g,          
 sc.qt_cob_ba_estim_nre_sc_2g,
 sc.qt_cob_ba_estim_nre_sc_3g,
 vias.ind_via_autopista, 
 vias.ind_via_autovia, 
 vias.ind_via_ctra_nac, 
 vias.ind_via_ctra_auton, 
 vias.ind_via_ctra_local,
 vias.invkm_via_autopista, 
 vias.invkm_via_autovia, 
 vias.invkm_via_ctra_nac, 
 vias.invkm_via_ctra_auton, 
 vias.invkm_via_ctra_local
FROM 
marzo2011.table_modelo_bts_" + period +
" t LEFT OUTER JOIN	marzo2011.view_bts_sc_vars_" + period + " sc
                    ON  t.id_bts = sc.id_bts
    LEFT OUTER JOIN (
					SELECT CAST(etv.id_emplazamiento AS INTEGER) AS id_bts, 
						   -- etv.id_tramo_via,
						   -- gtv.id_via,   
						   CASE WHEN gv.no_via LIKE 'AUTOPISTA%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_autopista, 
						   CASE WHEN gv.no_via LIKE 'AUTOVIA%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_autovia, 
						   CASE WHEN gv.no_via LIKE 'CTRA. NACIONAL%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_ctra_nac, 
						   CASE WHEN gv.no_via LIKE 'CTRA. AUTON%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_ctra_auton, 
						   CASE WHEN gv.no_via LIKE 'CTRA. LOCAL%' AND etv.vl_distancia_via <= 1000 THEN 1 ELSE 0 END AS ind_via_ctra_local, 
						   etv.vl_distancia_via,
						   CASE WHEN gv.no_via LIKE 'AUTOPISTA%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END  AS invkm_via_autopista, 
						   CASE WHEN gv.no_via LIKE 'AUTOVIA%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END AS invkm_via_autovia, 
						   CASE WHEN gv.no_via LIKE 'CTRA. NACIONAL%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END AS invkm_via_ctra_nac, 
						   CASE WHEN gv.no_via LIKE 'CTRA. AUTON%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END AS invkm_via_ctra_auton, 
						   CASE WHEN gv.no_via LIKE 'CTRA. LOCAL%' AND etv.vl_distancia_via <= 10000 THEN CAST(1000 AS FLOAT)/(etv.vl_distancia_via+1) ELSE 0 END AS invkm_via_ctra_local 	   
					FROM emp_f_emplazamiento_tramo_via etv
						 INNER JOIN
						 ges_d_tramo_via gtv
						 ON etv.id_tramo_via = gtv.id_tramo_via
						 INNER JOIN
						 ges_d_via gv
						 ON gtv.id_via = gv.id_via 
	            ) vias
	ON t.id_bts = vias.id_bts,					
	marzo2011.fun_bts_group("+G1+") g,  "+
	"
	(
	select id_bts,
	   sum(case when tarifa = 'Tarifa Diaria' 
				then qt_duracion_voz_gsm + qt_duracion_voz_umts 
				else 0 end) as qt_duracion_voz_tot_tar_dia,
	   sum(case when tarifa != 'Tarifa Diaria' 
				then qt_duracion_voz_gsm + qt_duracion_voz_umts 
				else 0 end) as qt_duracion_voz_tot_tar_plana,
	   sum(case when tarifa = 'Big Screen' 
				then qt_duracion_voz_gsm + qt_duracion_voz_umts 
				else 0 end) as qt_duracion_voz_tot_big_scr,
	   sum(case when tarifa in ( 'iPhone', 'Small Screen' )
				then qt_duracion_voz_gsm + qt_duracion_voz_umts 
				else 0 end) as qt_duracion_voz_tot_iphone_small_scr,									
	   sum(case when tarifa = 'Tarifa Diaria' 
				then qt_lineas_voz_gsm + qt_lineas_voz_umts 
				else 0 end) as qt_lineas_voz_tot_tar_dia,
	   sum(case when tarifa != 'Tarifa Diaria' 
				then qt_lineas_voz_gsm + qt_lineas_voz_umts 
				else 0 end) as qt_lineas_voz_tot_tar_plana,
	   sum(case when tarifa = 'Big Screen' 
				then qt_lineas_voz_gsm + qt_lineas_voz_umts 
				else 0 end) as qt_lineas_voz_tot_big_scr,
	   sum(case when tarifa in ( 'iPhone', 'Small Screen' )
				then qt_lineas_voz_gsm + qt_lineas_voz_umts 
				else 0 end) as qt_lineas_voz_tot_iphone_small_scr,
	   sum(case when tarifa = 'Big Screen' 
				then qt_vol_umts_pot_0 + qt_vol_umts_pot_1 + qt_vol_umts_pot_2 
				else 0 end) as qt_vol_umts_pot_big_scr,
	   sum(case when tarifa = 'Big Screen' 
				then qt_vol_umts_censored 
				else 0 end) as qt_vol_umts_censored_big_scr,
	   sum(case when tarifa = 'Big Screen' 
				then qt_lineas_censored 
				else 0 end) as qt_lineas_censored_big_scr 								
	from marzo2011.table_modelo_bts_tarifa_" + period + "
	group by id_bts
	) v
WHERE t.id_bts = g.id_bts "+
"AND t.id_bts = v.id_bts " +
cond_grp + cond_v3g + cond_duracion_voz + cond_cob_ba
}



// Viernes, 2011/04/15 18:45:24.00
Real _a = 1;
Real _.b = 2;
Real c = 3;


// Viernes, 2011/04/15 18:45:15.00
Real _a = 1;
Real _.b = 2;


// Viernes, 2011/04/15 18:44:18.00
Real _a = 0;
Real _.a = _a;



// Viernes, 2011/04/15 18:44:14.00
Real _a = 0;
Real _.a = _a;



// Viernes, 2011/04/15 18:44:03.00
Real _a = 0;
Real _.a = a;



// Jueves, 2011/04/14 07:41:37.00
Set GetGlobalFunctions( "Real");

// Jueves, 2011/04/14 07:41:17.00
NameBlock dbconn =
  DBConnect::Create(
                    "alias","user","pass", 
                    "conntype", "database", "server", 
                    "connection description");


Set GetGlobalFunctions(0);


// Jueves, 2011/04/07 11:34:14.00
Real inf

// Jueves, 2011/04/07 11:34:03.00
Real inf = 3;




// Jueves, 2011/04/07 11:32:35.00
Real inf



// Jueves, 2011/04/07 11:17:47.00
#Require MMS


// Miercoles, 2011/04/06 21:15:11.00
#Require MMS;


// Miercoles, 2011/04/06 21:13:49.00
#Require MMS;


// Miercoles, 2011/04/06 21:11:51.00
Real TolPackage::Client::RemoteUpgradeAll( True );


// Miercoles, 2011/04/06 21:10:51.00
#Require MMS


// Lunes, 2011/04/04 15:45:38.00
Set Include( "/tmp/ElectricityDemandSpain.oza" );


// Lunes, 2011/04/04 15:45:29.00
Set Include( "data/ElectricityDemandSpain.oza" );


// Lunes, 2011/04/04 15:43:55.00
Serie LoadDemandData( 0 );


// Lunes, 2011/04/04 15:38:16.00
#Require MMS;


// Lunes, 2011/04/04 15:37:43.00
Real IsInstanceOf(aa, "Modulo::@A");

// Lunes, 2011/04/04 15:37:31.00
Real IsInstanceOf(aa, "@A");

// Lunes, 2011/04/04 15:37:18.00
@A aa = [[ Real value = 2 ]];

// Lunes, 2011/04/04 15:36:51.00
Real IsInstanceOf(a, "@A");

// Lunes, 2011/04/04 15:36:48.00
Real IsInstanceOf(a, "Modulo::@A");

// Lunes, 2011/04/04 15:36:40.00
Real UsingNameBlock( Modulo );

// Lunes, 2011/04/04 15:35:55.00
 NameBlock Modulo = [[
  Class @A {
    Real value
  }
]];
Modulo::@A a = [[ Real value = 2 ]];
Real IsInstanceOf(a, "Modulo::@A"); // -> False
Real IsInstanceOf(a, "@A"); // -> True


// Lunes, 2011/04/04 15:29:58.00
Set kkk = IncludeBDT("/tmp/data.bdt" );

// Lunes, 2011/04/04 15:27:43.00
Date iniEstim  = Succ( First(Output), Diario, Degree(ma*Dif));
Date endEstim  = Last(Output);
Set  modelEst  = Estimate (modelDef,iniEstim, endEstim);



// Lunes, 2011/04/04 15:27:15.00
Serie Output = { Include( "/tmp/ElectricityDemandSpain.oza" )[1] };

//Se transforma la serie con el logaritmo porque es más homocedástica y se
//postula que los efectos son multiplicativos
Real FstTransfor = 0; //boxCoxTrans[1];
Real SndTransfor = 0; //boxCoxTrans[2]; 
Real Period      = 7;
Real Constant    = 0;

//LA serie se diferencia en las dos estacionalidades semanal y anual
Polyn  Dif        = (1-B^7)*(1-B^364); 
Serie  difOutput  =  Dif:Output;
Polyn  ARr  =  1-0.1*B-0.1*B^2;
Polyn  ARsS =  1;
Polyn  ARsA =  1;
Polyn  MAr  =  1;
Polyn  MAsS =  1-0.1*B^7;
Polyn  MAsA =  1-0.1*B^364;

Set AR = SetOfPolyn(ARr, ARsS, ARsA);
Set MA = SetOfPolyn(MAr, MAsS, MAsA); 

Polyn ar = SetProd(AR);
Polyn ma = SetProd(MA);

Set  modelDef = ModelDef(
  ElectricityDemand, 
  FstTransfor, 
  SndTransfor,
  Period,Constant,  
  Dif, 
  AR, 
  MA,   
  Empty, 
  Empty
);



// Lunes, 2011/04/04 15:03:07.00
Serie ElectricityDemand = { Include( "/tmp/ElectricityDemandSpain.oza" )[1] };


// Lunes, 2011/04/04 15:02:58.00
Serie ElectricityDemand = { Include( "data/ElectricityDemandSpain.oza" )[1] };


// Lunes, 2011/04/04 14:54:15.00
Serie ElectricityDemandSpain = demand1[1];

Real Ois.Store( [[ ElectricityDemandSpain ]], "/tmp/ElectricityDemandSpain.oza" );

// Lunes, 2011/04/04 14:54:00.00
Real Ois.Store( [[ ElectricityDemandSpain ]], "/tmp/ElectricityDemandSpain.oza" );

// Lunes, 2011/04/04 14:50:24.00
Serie demand1[1] + demand1[3] - demand1[2]

// Lunes, 2011/04/04 14:50:18.00
Serie demand1[1] + demand1[3] - demand[2]

// Lunes, 2011/04/04 14:49:04.00
Serie demand1[1] - demand1[3]

// Lunes, 2011/04/04 14:46:27.00
Set demand2 = { Include( "/tmp/ElectricityDemand.oza" ) };



// Lunes, 2011/04/04 14:45:55.00
Set demand1 = { Include( "/tmp/ElectricityDemand.oza" )[1] };


// Viernes, 2011/04/01 20:45:02.00
Code InputDef


// Viernes, 2011/04/01 13:59:15.00
Set Include( "/tmp/Cjto_Series_Electricidad.oza" );


// Jueves, 2011/03/31 20:13:48.00
Real aaaa = 1;


// Martes, 2011/03/29 20:49:59.00
/*
Class @Test {
  Real _.prot = 1;
  Real _priv = 0
};

@Test AA = [[ Real _.prot = 1, Real _priv = 0 ]];
*/

Real TolConfigManager::Config::Various::View::PrivateMembers := 1



// Martes, 2011/03/29 20:49:30.00
Class @Test {
  Real _.prot = 1;
  Real _priv = 0
};

@Test AA = [[ Real _.prot = 1, Real _priv = 0 ]];



// Martes, 2011/03/29 20:48:57.00
Class @Test {
  Real _.prot = 1;
  Real _priv = 0
};

@Test AA = [[ _.prot = 1, _priv = 0 ]];



// Martes, 2011/03/29 20:47:28.00
#Require MMS;



// Lunes, 2011/03/28 18:10:52.00
#Require MMS;



// Lunes, 2011/03/28 17:10:19.00
#Require MMS;



// Martes, 2011/03/22 17:46:32.00

Real order = 10;
Polyn AR = 1-0.7*B+0.1*B^2;
Polyn MA = 1;

// calculo autocovarianza
Matrix acov = ARMATACov( AR, MA,order+1);

// calculo ACF a partir de ACVF
Matrix acf = acov * 1/MatDat(acov,1,1);

// calculo PACF
Matrix fi = DurbinAutoReg(Sub(acf,2,1,order,1),order);
Matrix pacf = Tra(SubDiag(fi,0));



// Martes, 2011/03/22 17:39:53.00
Real order = 10;
Matrix acov = ARMATACov(1-0.7*B+0.1*B^2, 1,order+1);
Matrix acf = acov * 1/MatDat(acov,1,1);
Matrix fi = DurbinAutoReg(Sub(acf,2,1,order,1),order);
Matrix pacf = Tra(SubDiag(fi,0));



// Martes, 2011/03/22 17:38:54.00
Real order = 10;
Matrix acov = ARMATACov(1-0.5*B,1+0.4*B,order+1);
Matrix acf = acov * 1/MatDat(acov,1,1);
Matrix fi = DurbinAutoReg(Sub(acf,2,1,order,1),order);
Matrix pacf = Tra(SubDiag(fi,0));



// Martes, 2011/03/22 15:43:44.00
Matrix acf = ARMATACov(1-0.5*B,1+0.4*B, 5);
Matrix acf0 = acf $/ Rand( Rows(acf), 1, MatDat(acf,1,1), MatDat(acf,1,1) );



// Martes, 2011/03/22 15:42:57.00
Matrix acf = ARMATACov(1-0.5*B,1+0.4*B, 5);
Matrix acf0 = acf $/ MatDat(acf,1,1);



// Martes, 2011/03/22 15:42:47.00
Matrix acf = ARMATACov(1-0.5*B,1+0.4*B, 5);
Matrix acf0 = acf / MatDat(acf,1,1);



// Martes, 2011/03/22 15:42:14.00
Matrix acf = ARMATACov(1-0.5*B,1+0.4*B, 5);



// Martes, 2011/03/22 14:51:09.00
Matrix ARMATACov(1-0.7*B+0.1*B^2,1, 5);
Polyn ARMATACov(1-0.7*B,1+0.1*B,10);


// Martes, 2011/03/22 14:49:16.00
Matrix ARMATACov(1-0.7*B+0.1*B,1, 5);
Polyn ARMATACov(1-0.7*B,1+0.1*B,10);


// Martes, 2011/03/22 14:49:03.00
Matrix ARMATACov(1-0.7*B+0.1*B,5);
Polyn ARMATACov(1-0.7*B,1+0.1*B,10);


// Martes, 2011/03/22 14:45:37.00
Matrix ARMATACov(1-0.7*B,1+0.1*B,5);
Polyn ARMATACov(1-0.7*B,1+0.1*B,10);


// Martes, 2011/03/22 14:44:52.00
Matrix ARMATACov(1+0.7*B,1-0.1*B,5);
Polyn ARMATACov(1-0.7*B,1+0.1*B,10);


// Martes, 2011/03/22 14:41:33.00
Matrix ARMATACov(1-0.7*B,1+0.1*B,100);
Polyn ARMATACov(1-0.7*B,1+0.1*B,10);


// Martes, 2011/03/22 14:24:57.00
Matrix ARMATACov(1-0.7*B,1+0.1*B,10);
Polyn ARMATACov(1-0.7*B,1+0.1*B,10);


// Martes, 2011/03/22 14:17:45.00
Matrix ARMATACov(1-0.7*B,1-0.95*B,10);
Polyn ARMATACov(1-0.7*B,1-0.95*B,10);


// Jueves, 2011/03/17 11:14:53.00
#Require MMS


// Jueves, 2011/03/17 10:44:33.00
Text Description(TolConfigManager::Default);


// Miercoles, 2011/03/16 12:39:37.00
Date d2= Succ( y2012, ts1 );


// Miercoles, 2011/03/16 12:39:31.00
Date d1= Succ( y2012, ts1 );


// Miercoles, 2011/03/16 12:39:23.00
Date d1= Succ( y2011, ts1 );


// Miercoles, 2011/03/16 12:34:32.00
TimeSet ts1=WD(1)*Y(2011);


// Jueves, 2011/02/24 14:45:15.00
#Require MMS;


// Jueves, 2011/02/24 14:29:46.00
#Require MMS;


// Jueves, 2011/02/24 14:28:52.00
Real TolPackage::Client::RemoteUpgradeAll ( True );



// Jueves, 2011/02/24 14:23:32.00
#Require MMS;



// Jueves, 2011/02/24 14:09:24.00
#Require MMS



// Lunes, 2011/02/21 23:58:09.00
Matrix Rand( 100, 3, 0, 1 );



// Lunes, 2011/02/21 23:06:52.00

Real TolPackage::Client::RemoteUpgradeAll(True);


// Lunes, 2011/02/21 23:06:33.00
#Require PubDatDanielPena;



// Domingo, 2011/02/20 21:56:53.00
Real Ois.Store( [[OrthoA]], "/tmp/OrthoA.oza" );


// Viernes, 2011/02/18 18:17:08.00
Set DistAA( Matrix A, Matrix B )
{
  Set For( 1, Rows( B ), Matrix( Real r ) {
    Matrix row_i = SubRow( B, [[ r ]] );
    Matrix matRow_i = Group("ConcatRows",NCopy( Rows(A), row_i ));
    Matrix dif = matRow_i - A;
   (dif $* dif) * Constant(Columns(B),1,1)
  } )
};

Set DistAA( Rand( 10, 3, 0, 1), Rand( 3, 3, 0, 1 ) );

/*
Set GetRandomSampleIndex( Real sizePopulation, Real sizeSample )
{
  Matrix permIndex = RandPermutation( 1, sizePopulation );
  Matrix sampleIndex = SubCol( permIndex, Range( 1, sizeSample, 1 ) );
  Set result = MatSet( sampleIndex )[1]
};

Set GetRandomSampleIndex( 400, 30 );
*/




// Viernes, 2011/02/18 18:16:49.00
Set DistAA( Matrix A, Matrix B )
{
  Set For( 1, Rows( B ), Matrix( Real r ) {
    Matrix row_i = SubRow( B, [[ r ]] );
    Matrix matRow_i = Group("ConcatRows",NCopy( Rows(A), row_i ));
    Matrix dif = matRow_i - A;
   (dif $* dif) * Constant(Columns(B),1,1)
  } )
};

Set DistAA( Rand( 10, 3, 0, 1), Rand( 3, 2, 0, 1 ) );

/*
Set GetRandomSampleIndex( Real sizePopulation, Real sizeSample )
{
  Matrix permIndex = RandPermutation( 1, sizePopulation );
  Matrix sampleIndex = SubCol( permIndex, Range( 1, sizeSample, 1 ) );
  Set result = MatSet( sampleIndex )[1]
};

Set GetRandomSampleIndex( 400, 30 );
*/




// Viernes, 2011/02/18 18:16:04.00
Set DistAA( Matrix A, Matrix B )
{
  Set For( 1, Rows( B ), Matrix( Real r ) {
    Matrix row_i = SubRow( B, [[ r ]] );
    Matrix matRow_i = Group("ConcatRows",NCopy( Rows(A), row_i ));
    Matrix dif = matRow_i - A;
   (dif $* dif) * Constant(n,1,1)
  } )
};

Set DistAA( Rand( 10, 3, 0, 1), Rand( 3, 2, 0, 1 ) );

/*
Set GetRandomSampleIndex( Real sizePopulation, Real sizeSample )
{
  Matrix permIndex = RandPermutation( 1, sizePopulation );
  Matrix sampleIndex = SubCol( permIndex, Range( 1, sizeSample, 1 ) );
  Set result = MatSet( sampleIndex )[1]
};

Set GetRandomSampleIndex( 400, 30 );
*/




// Viernes, 2011/02/18 18:15:39.00
Set DistAA( Matrix A, Matrix B )
{
  Set For( 1, Rows( B ), Matrix( Real r ) {
    Matrix row_i = SubRow( B, [[ r ]] );
    Matrix matRow_i = Group("ConcatRows",NCopy( Rows(B), row_i ));
    Matrix dif = matRow_i - A;
   (dif $* dif) * Constant(n,1,1)
  } )
};

Set DistAA( Rand( 10, 3, 0, 1), Rand( 3, 2, 0, 1 ) );

/*
Set GetRandomSampleIndex( Real sizePopulation, Real sizeSample )
{
  Matrix permIndex = RandPermutation( 1, sizePopulation );
  Matrix sampleIndex = SubCol( permIndex, Range( 1, sizeSample, 1 ) );
  Set result = MatSet( sampleIndex )[1]
};

Set GetRandomSampleIndex( 400, 30 );
*/




// Viernes, 2011/02/18 18:15:10.00
Set DistAA( Matrix A, Matrix B )
{
  Set For( 1, Rows( B ), Matrix( Real r ) {
    Matrix row_i = SubRow( B, [[ r ]] );
    Matrix matRow_i = Group("ConcatRows",NCopy( m, row_i ));
    Matrix dif = matRow_i - A;
   (dif $* dif) * Constant(n,1,1)
  } )
};

Set DistAA( Rand( 10, 3, 0, 1), Rand( 3, 2, 0, 1 ) );

/*
Set GetRandomSampleIndex( Real sizePopulation, Real sizeSample )
{
  Matrix permIndex = RandPermutation( 1, sizePopulation );
  Matrix sampleIndex = SubCol( permIndex, Range( 1, sizeSample, 1 ) );
  Set result = MatSet( sampleIndex )[1]
};

Set GetRandomSampleIndex( 400, 30 );
*/




// Viernes, 2011/02/18 18:14:56.00
Set DistAA( Matrix A, Matrix B )
{
  Set For( 1, Rows( B ), Matrix( Real r ) {
    Matrix row_i = SubRow( B, [[ r ]] );
    Matrix matRow_i = Group("ConcatRows",NCopy( m, row_i ));
    Matrix dif = matRow_i - A;
   (dif $* dif) * Constant(n,1,1)
  } )
};

Set DistAA( Rand( 10, 3, 0, 1), Rand( 3, 2, 0, 1 ) );

/*
Set GetRandomSampleIndex( Real sizePopulation, Real sizeSample )
{
  Matrix permIndex = RandPermutation( 1, sizePopulation );
  Matrix sampleIndex = SubCol( permIndex, Range( 1, sizeSample, 1 ) );
  Set result = MatSet( sampleIndex )[1]
};

Set GetRandomSampleIndex( 400, 30 );
*/




// Viernes, 2011/02/18 18:00:12.00
Set GetRandomSampleIndex( Real sizePopulation, Real sizeSample )
{
  Matrix permIndex = RandPermutation( 1, sizePopulation );
  Matrix sampleIndex = SubCol( permIndex, Range( 1, sizeSample, 1 ) );
  Set result = MatSet( sampleIndex )[1]
};

Set GetRandomSampleIndex( 400, 30 );


// Viernes, 2011/02/18 17:59:41.00
Set GetRandomSampleIndex( Real sizePopulation, Real sizeSample )
{
  Matrix permIndex = RandPermutation( 1, sizePopulation );
  Matrix sampleIndex = SubCol( permIndex, Range( 1, sizeSample, 1 ) );
  Set result = MatSet( sampleIndex )
};

Set GetRandomSampleIndex( 400, 30 );


// Viernes, 2011/02/18 17:59:13.00
Set GetRandomSampleIndex( Real sizePopulation, Real sizeSample )
{
  Matrix permIndex = RandPermutation( 1, sizePopulation );
  Matrix sampleIndex = SubCol( permIndex, Range( 1, sizeSample, 1 ) );
  Set result = SetMat( sampleIndex )
};

Set GetRandomSampleIndex( 400, 30 );


// Viernes, 2011/02/18 17:57:12.00
Real sizePop = 400;
Real sizeSample = 35;
Matrix permIndex = RandPermutation( 1, sizePop );
Matrix sampleIndex = SubCol( permIndex, Range( 1, sizeSample, 1 ) );


// Viernes, 2011/02/18 17:51:02.00
Matrix RandPermutation( 1, 10 );


// Viernes, 2011/02/18 15:35:20.00
Set rowsDist = For( 1, n, Matrix( Real r ), {
  Matrix row_i = SubRow( orthoA, [[ r ]] );
  Matrix matRow_i = Group("ConcatRows", NCopy( n, row_i )) ;
  Matrix diff = MtMSqr( matRow_i - orthoA )
} );


// Viernes, 2011/02/18 15:34:38.00
Set rowsDist = For( 1, n, Matrix( Real r ), {
  Matrix row_i = SubRow( orthoA, [[ r ]] );
  Matrix matRow_i = Group("ConcatRows", NCopy( n, row_i ) ;
  Matrix diff = MtMSqr( matRow_i - orthoA )
} );


// Viernes, 2011/02/18 15:34:09.00
Set rowsDist = For( 1, n, Matrix( Real r ), {
  Matrix row_i = SubRow( orthoA, [[ r ]] );
  Matrix matRow_i = Group("ConcatRows", NCopy( n, row_i ) );
  Matrix diff = MtMSqr( matRow_i - orthoA )
} );


// Viernes, 2011/02/18 15:24:31.00
Matrix orthoA = Tra(TrSolve( L, Tra(A) ));

// Viernes, 2011/02/18 15:24:16.00
Matrix orthoA = Tra(TrSolve( L, Tra(A) );)

// Viernes, 2011/02/18 10:30:48.00
R

// Jueves, 2011/02/17 10:00:40.00
Real datosTiendas[1][6]


// Jueves, 2011/02/17 10:00:33.00
Real datosTienda[1][6]


// Miercoles, 2011/02/16 16:18:18.00
Set Include( "/tmp/datosTiendas.oza" );


// Miercoles, 2011/02/16 16:17:50.00
Real Ois.Store( datosTiendas, "/tmp/datosTiendas.oza"  );


// Miercoles, 2011/02/16 16:17:40.00
Real Ois.Store( datosTienda, "/tmp/datosTienda.oza"  );


// Miercoles, 2011/02/16 16:17:25.00
Real Ois.Store( "/tmp/datosTienda.oza", datosTienda );


// Lunes, 2011/02/14 11:03:18.00
#Require MMS;


// Viernes, 2011/02/11 10:26:39.00
Timer::Start( "test" );



// Viernes, 2011/02/11 10:25:21.00
Timer



// Miercoles, 2011/02/09 23:57:05.00
#Require MMS;


// Martes, 2011/01/18 09:04:01.00
NameBlock mdlFore = fore::GetModel.Forecast(?);
NameBlock submdlFore = mdlFore::GetSubmodel(1);


// Martes, 2011/01/18 09:03:48.00
NameBlock mdlFore = fore::GetModelForecast(?);
NameBlock submdlFore = mdlFore::GetSubmodel(1);


// Martes, 2011/01/18 09:03:05.00
NameBlock submdlFore = mdlFore::GetSubmodel(1);


// Martes, 2011/01/18 09:02:20.00
NameBlock mdlFore = fore::GetModel.Forecast(?);


// Martes, 2011/01/18 09:02:03.00
NameBlock mdlFore = fore::GetModelForecast(?);


// Jueves, 2011/01/13 21:32:37.00
Set Include( "/tmp/Model.at.PRICTA.Mod.WOE_Fmz.SI_Gen.2006XX_Ctr.XXXX_Seg.EXCImp_in_91_12mes7.0LogitMLE1.0LogitNLO__1.0.oza" );


// Martes, 2011/01/11 14:56:48.00
#Require QltvRespModel;

NameBlock qltvModel = { (Set Include( "/tmp/modelQRM.oza" ))[1] };



// Lunes, 2011/01/10 19:37:12.00
Text TolAppDataPath + "OIS/module/"


// Lunes, 2011/01/10 19:37:08.00
ex

// Lunes, 2011/01/10 19:34:28.00
Text TolAppDataPath + "/TolPackage"


// Jueves, 2011/01/06 00:34:34.00
#Require MMS


// Jueves, 2011/01/06 00:02:45.00
NameBlock result3 = (kk[1])::find_max_likelihood( 100 );

// Jueves, 2011/01/06 00:00:02.00
NameBlock result2 = (kk[1])::bayesian_estimation( 1000 );

// Miercoles, 2011/01/05 23:58:30.00
#Require QltvRespModel;
Set kk = { Include( "/tmp/modelQRM.oza" ) };
NameBlock result = (kk[1])::find_max_likelihood( 0 );


// Miercoles, 2011/01/05 10:35:03.00
NameBlock (kk[1])::find_max_likelihood( 0 );

// Miercoles, 2011/01/05 10:34:20.00
NameBlock kk[1]::find_max_likelihood( 0 );

// Miercoles, 2011/01/05 10:31:30.00
Set kk = { Include( "/tmp/modelQRM.oza" ) };


// Miercoles, 2011/01/05 10:30:50.00
#Require QltvRespModel;


// Miercoles, 2011/01/05 10:30:37.00
Real TolPackage::Client::LocalClean( "QltvRespModel" );


// Jueves, 2010/12/30 11:35:17.00
Real (MMS::Container::GetEstimation(1))::Execute(?);


// Jueves, 2010/12/30 11:27:14.00
MMS::@Submodel subm = MMS::@Submodel::Spc( (mdl::Submodels)[1] );

// Jueves, 2010/12/30 11:26:32.00
Set mdl = model::GetSpecification(?);

// Jueves, 2010/12/30 11:19:13.00
Set model::GetSpecification(?);


// Jueves, 2010/12/30 07:31:17.00
#Require QltvRespModel;

Set Include( "/tmp/QRM_model.oza" );


// Jueves, 2010/12/30 07:30:19.00
Set Include( "/tmp/QRM_model.oza" );


// Martes, 2010/12/28 15:12:48.00
#Require MMS;


// Martes, 2010/12/28 14:57:46.00
#Require MMS;


// Martes, 2010/12/28 14:32:17.00
#Require MMS;


// Martes, 2010/12/28 14:25:15.00
Set Include( "/home/jsperez/TOL/projects/mms/branches/PRE-1.0/MMS/_ini_MMS.tol" );


// Lunes, 2010/12/27 13:36:46.00
#Require MMS;


// Lunes, 2010/12/27 13:36:46.00
#Require MMS;


// Lunes, 2010/12/27 13:36:45.00
#Require MMS;


// Lunes, 2010/12/27 13:36:44.00
#Require MMS;


// Lunes, 2010/12/27 13:36:31.00
#Require MMS;


// Lunes, 2010/12/27 13:22:26.00
Real ObjectExist( "Set", "mlh::_.param3_signif_t" );

// Lunes, 2010/12/27 13:22:20.00
Real ObjectExist( "Set", "mlh::_.param_signif_t" );

// Lunes, 2010/12/27 13:22:07.00
Real ObjectExist( "mlh::_.param_signif_t" );

// Lunes, 2010/12/27 13:22:01.00

Real ObjectExists( "mlh::_.param_signif_t" );

// Lunes, 2010/12/27 13:21:34.00
Real FindIndexByName( mlh, "_.param_signif_t" );

// Lunes, 2010/12/27 13:06:40.00
       Set For( 1, Card( aux::_.param_signif_t ), Real( Real k ) {
            Set info = (aux::_.param_signif_t)[k];
            Set PutName( info::Name, aux::_.param_signif_t[k] );
            Real 0
          } );


// Lunes, 2010/12/27 13:06:02.00
NameBlock aux = mlh;

        Set For( 1, Card( aux::_.param_signif_t ), Real( Real k ) {
            Set info = (aux::_.param_signif_)[k];
            Set PutName( info::Name, aux::_.param_signif_t[k] );
            Real 0
          } );



// Lunes, 2010/12/27 11:58:06.00
VMatrix H = mlh::_.evaluation::_.hessian;
VMatrix C = mlh::_.param_cross::_.cov;

VMatrix checkH = Tra(H) - H;
VMatrix checkC = Tra(C) - C;


// Lunes, 2010/12/27 11:57:27.00
VMatrix H = mlh::_.evaluation::_.hessian;
VMatrix C = mlh::_.param_cross::_.cov;


// Lunes, 2010/12/27 11:56:07.00
VMatrix H = mlh::_.evaluation::_hessian;
VMatrix C = mlh::_.param_cross::_.cov;


// Lunes, 2010/12/27 10:21:26.00
Matrix QRMTestData::intercept


// Miercoles, 2010/12/22 15:06:35.00
#Require MMS;


// Martes, 2010/12/21 22:04:14.00
#Require QltvRespModel;


// Martes, 2010/12/21 16:21:34.00
#Require TolCint;


// Miercoles, 2010/12/15 15:50:18.00
VMatrix m3 = SetCol( [[2,3,4]] ) | SetCol( [[1,5,7]] );


// Miercoles, 2010/12/15 15:46:47.00
Real Cint.calc("pow(2.234,2)")


// Miercoles, 2010/12/15 15:46:21.00
Real Cint.calc("2.234")


// Martes, 2010/12/14 16:30:17.00
#Require MMS;


// Martes, 2010/12/07 14:27:37.00
Set ll = ss::CheckMulticollinearity(0);

// Martes, 2010/12/07 14:27:11.00
NameBlock ss = MMS::Container::GetEstimation(1)::GetModel(1)::GetSubmodel(1);
Set ll = ss::CheckCollinearity(0);


// Martes, 2010/12/07 14:26:30.00
NameBlock ss = MMS::Container::GetEstimation(1)::GetModel(1)::GetSubmodel(1);


// Martes, 2010/12/07 14:25:50.00
MMS::Container::GetEstimation(1)::GetModel(1)::GetSubModel(1);


// Martes, 2010/12/07 14:25:38.00
MMS::Container::GetEstimation(1)::GetModel(1);


// Martes, 2010/12/07 14:25:20.00
MMS::Container::GetEstimation(1);


// Martes, 2010/12/07 14:18:10.00
#Require MMS;


// Martes, 2010/12/07 10:51:10.00
Set GetArimaFromLabel("P1_1_1_1DIF0_0_0_0AR1.2_1.2_1.2_1.2MA1.2_1.2_1.2_0")

// Martes, 2010/12/07 10:49:34.00
Set kk = GetArimaFromLabel( "P1DIF0AR1..8MA1..6" );


// Viernes, 2010/12/03 17:33:15.00
Set GetArimaFromLabel( "P1DIF0AR1.2.3.4.5.6.7.8MA1.2.3.4.5.6" );


// Viernes, 2010/12/03 17:33:08.00
Set GetARIMAFromLabel( "P1DIF0AR1.2.3.4.5.6.7.8MA1.2.3.4.5.6" );


// Lunes, 2010/11/22 10:31:51.00
#Require RmtPsClient;


// Miercoles, 2010/11/17 13:47:11.00
Real OSCmdWait( "cvs --help >& /tmp/cvs.log " );


// Miercoles, 2010/11/17 13:35:10.00
Real OSCmdWait( "cvs --help" );


// Miercoles, 2010/11/10 19:23:51.00
#Require MMS;


// Miercoles, 2010/11/10 15:50:18.00
#Require MMS;


// Miercoles, 2010/11/10 14:47:49.00
MMS::@Submodel submodel = MMS::Container::GetModel(1)::GetSubmodel(1)


// Miercoles, 2010/11/10 14:03:27.00
#Require MMS;


// Miercoles, 2010/11/10 14:03:15.00
MMS


// Miercoles, 2010/11/10 09:55:10.00
Real TolPackage::Client::RemoteUpdateAll(True);



// Miercoles, 2010/11/10 09:54:54.00
Real TolPackage::Client::RemoteUpdateAll(False);



// Miercoles, 2010/11/10 09:53:43.00
Real TolPackage::Client::RemoteInstallPackage("","MMS",True);


// Martes, 2010/11/09 17:42:42.00
Set DBSeries("select * from `31`", Anual, [["S1", "S2", "S3", "S4"]] );



// Martes, 2010/11/09 17:42:05.00
Set DBSeries("select * from `31`", Anual, Empty );



// Martes, 2010/11/09 17:41:33.00
Set DBSeries("select * from '31'", Anual, Empty );



// Martes, 2010/11/09 17:36:24.00
Real kk::Activate(0);



// Martes, 2010/11/09 15:10:50.00
NameBlock kk1 = BayesStore.DB::GetConnection(?);

// Martes, 2010/11/09 15:10:40.00
NameBlock BayesStore.DB =
[[
  Set _dbconn = Copy( Empty );

  NameBlock GetConnection( Real void )
  {
    Set If( !Card( _dbconn ),
        Set Append( _dbconn, [[ _init(?) ]] ) );
    NameBlock _dbconn[ 1 ]
  };

  NameBlock _init( Real void )
  {
    NameBlock conn =
    DBConnect::Create( "BayeStore","bayes","bayes",
                       "mysql", "bayes_tienda", "localhost", 
                       "Conexion a las tablas de la tienda" )
  }
]];

NameBlock kk = BayesStore.DB::GetConnection(?);


// Martes, 2010/11/09 15:10:21.00
NameBlock BayesStore.DB =
[[
  Set _dbconn = Copy( Empty );

  NameBlock GetConnection( Real void )
  {
    If( !Card( _dbconn ),
        Set Append( _dbconn, [[ _init(?) ]] ) );
    NameBlock _dbconn[ 1 ]
  };

  NameBlock _init( Real void )
  {
    NameBlock conn =
    DBConnect::Create( "BayeStore","bayes","bayes",
                       "mysql", "bayes_tienda", "localhost", 
                       "Conexion a las tablas de la tienda" )
  }
]];

NameBlock kk = BayesStore.DB::GetConnection(?);


// Martes, 2010/11/09 15:09:48.00
NameBlock kk = BayesStore.DB::GetConnection(?);

// Martes, 2010/11/09 15:09:13.00
NameBlock BayesStore.DB =
[[
  Set _dbconn = Copy( Empty );

  NameBlock GetConnection( Real void )
  {
    If( !Card( _dbconn ),
        Append( _dbconn, [[ _init(?) ]] ) );
    NameBlock _dbconn[ 1 ]
  };

  NameBlock _init( Real void )
  {
    NameBlock conn =
    DBConnect::Create( "BayeStore","bayes","bayes",
                       "mysql", "bayes_tienda", "localhost", 
                       "Conexion a las tablas de la tienda" )
  }
]];


// Martes, 2010/11/09 10:12:51.00
Real {
WriteLn("inf="<<inf);
Real inf = 2;
Real b = 3;
If(inf<b, WriteLn("2 < 3"),WriteLn("2 > 3") );
inf
};


// Martes, 2010/11/09 10:12:36.00
Real {
WriteLn("inf="<<inf);
Real inf = 2;
Real b = 3;
If(inf<b, WriteLn("2 < 3"),WriteLn("2 > 3") );
inf
};


// Martes, 2010/11/09 10:06:55.00
Real {
  Real inf = 2;
  Real b = 3;
  If(inf<b, WriteLn("2<3"),WriteLn("2>3") )
};


// Martes, 2010/11/09 09:58:42.00
Real TestValue(NameBlock args, Real value)
  ////////////////////////////////////////////////////////////////////////////
  {
    // El test devuelve:
    // ?: si la restricción no es válida
    // -1: si el valor es menor que el mínimo
    // +1: si el valor es mayor que el máximo
    // 0: si el valor respeta la restricción
    Real inferiorValue = {
      Real low = getOptArg(args, "_.inferiorValue", ?);
      If(IsUnknown(inf), -1/0, low)
    };
    Real superiorValue = {
      Real sup = getOptArg(args, "_.superiorValue", ?);
      If(IsUnknown(sup), +1/0, sup)
    };
    WriteLn( "low=" << inferiorValue );
    WriteLn( "high=" << superiorValue );
    Case(superiorValue < inferiorValue, ?, value < inferiorValue, -1, 
      superiorValue < value, 1, True, 0)
  };

Real TestValue( [[
  Real _.inferiorValue = -2; 
  Real _.superiorValue = 0
]], -1 );




// Martes, 2010/11/09 09:57:08.00
Real TestValue(NameBlock args, Real value)
  ////////////////////////////////////////////////////////////////////////////
  {
    // El test devuelve:
    // ?: si la restricción no es válida
    // -1: si el valor es menor que el mínimo
    // +1: si el valor es mayor que el máximo
    // 0: si el valor respeta la restricción
    Real inferiorValue = {
      Real inf = getOptArg(args, "_.inferiorValue", ?);
      If(IsUnknown(inf), -1/0, inf)
    };
    Real superiorValue = {
      Real sup = getOptArg(args, "_.superiorValue", ?);
      If(IsUnknown(sup), +1/0, sup)
    };
    WriteLn( "low=" << inferiorValue );
    WriteLn( "high=" << superiorValue );
    Case(superiorValue < inferiorValue, ?, value < inferiorValue, -1, 
      superiorValue < value, 1, True, 0)
  };

Real TestValue( [[
  Real _.inferiorValue = -2; 
  Real _.superiorValue = 0
]], -1 );




// Martes, 2010/11/09 09:56:58.00
Real TestValue(NameBlock args, Real value)
  ////////////////////////////////////////////////////////////////////////////
  {
    // El test devuelve:
    // ?: si la restricción no es válida
    // -1: si el valor es menor que el mínimo
    // +1: si el valor es mayor que el máximo
    // 0: si el valor respeta la restricción
    Real inferiorValue = {
      Real inf = getOptArg(args, "_.inferiorValue", ?);
      If(IsUnknown(inf), -1/0, inf)
    };
    Real superiorValue = {
      Real sup = getOptArg(args, "_.superiorValue", ?);
      If(IsUnknown(sup), +1/0, sup)
    };
    WriteLn( "low" << inferiorValue );
    WriteLn( "high" << superiorValue );
    Case(superiorValue < inferiorValue, ?, value < inferiorValue, -1, 
      superiorValue < value, 1, True, 0)
  };

Real TestValue( [[
  Real _.inferiorValue = -2; 
  Real _.superiorValue = 0
]], -1 );




// Martes, 2010/11/09 09:56:10.00
Real TestValue(NameBlock args, Real value)
  ////////////////////////////////////////////////////////////////////////////
  {
    // El test devuelve:
    // ?: si la restricción no es válida
    // -1: si el valor es menor que el mínimo
    // +1: si el valor es mayor que el máximo
    // 0: si el valor respeta la restricción
    Real inferiorValue = {
      Real inf = getOptArg(args, "_.inferiorValue", ?);
      If(IsUnknown(inf), -1/0, inf)
    };
    Real superiorValue = {
      Real sup = getOptArg(args, "_.superiorValue", ?);
      If(IsUnknown(sup), +1/0, sup)
    };
    Case(superiorValue < inferiorValue, ?, value < inferiorValue, -1, 
      superiorValue < value, 1, True, 0)
  };

Real TestValue( [[
  Real _.inferiorValue = -2; 
  Real _.superiorValue = 0
]], -1 );




// Martes, 2010/11/09 09:56:02.00
Real TestValue(NameBlock args, Real value)
  ////////////////////////////////////////////////////////////////////////////
  {
    // El test devuelve:
    // ?: si la restricción no es válida
    // -1: si el valor es menor que el mínimo
    // +1: si el valor es mayor que el máximo
    // 0: si el valor respeta la restricción
    Real inferiorValue = {
      Real inf = getOptArg(args, "_.inferiorValue", ?);
      If(IsUnknown(inf), -1/0, inf)
    };
    Real superiorValue = {
      Real sup = getOptArg(args, "_.superiorValue", ?);
      If(IsUnknown(sup), +1/0, sup)
    };
    Case(superiorValue < inferiorValue, ?, value < inferiorValue, -1, 
      superiorValue < value, 1, True, 0)
  }

Real TestValue( [[
  Real _.inferiorValue = -2; 
  Real _.superiorValue = 0
]], -1 );




// Martes, 2010/11/09 09:38:03.00
Real MMS::@Constraint::TestValue( [[
  Real _.inferiorValue = -2; 
  Real _.superiorValue = 0
]], -1 );

// Martes, 2010/11/09 09:37:53.00
Real MMS::@Constraint::TestValue( [[
  Real _.inferiorValue = -1/0; 
  Real _.superiorValue = 0
]], -1 );

// Martes, 2010/11/09 09:35:47.00
Real MMS::@Constraint::TestValue( [[
  Real _.inferiorValue = ?; 
  Real _.superiorValue = 0
]], -1 );

// Martes, 2010/11/09 09:35:21.00
Real MMS::@Constraint::TestValue( [[
  Real _.inferiorValue = ?; 
  Real _.superiorValue = 0
]], parkk::_.initialValue );

// Martes, 2010/11/09 09:34:51.00
MMS::@Parameter parkk = model::GetParameter(
  [["Veh.Tur.Mat", "Crisis.200801", [["Linear", 0]] ]]
);

// Martes, 2010/11/09 09:33:21.00
Code MMS::@Constraint::TestValue


// Lunes, 2010/11/08 21:04:52.00
Real Copy(NObject);
 Set Ois.Load("/tmp/oza1.oza");
 Real Copy(NObject);


// Lunes, 2010/11/08 21:04:47.00
Real Copy(NObject);
 Set Ois.Load("/tmp/oza1.oza");
 Real Copy(NObject);


// Lunes, 2010/11/08 21:04:43.00
Real Copy(NObject);
 Set Ois.Load("/tmp/oza1.oza");
 Real Copy(NObject);


// Lunes, 2010/11/08 21:04:39.00
Real Copy(NObject);
 Set Ois.Load("/tmp/oza1.oza");
 Real Copy(NObject);


// Lunes, 2010/11/08 21:04:35.00
Real Copy(NObject);
 Set Ois.Load("/tmp/oza1.oza");
 Real Copy(NObject);


// Lunes, 2010/11/08 21:04:30.00
Real Copy(NObject);
 Set Ois.Load("/tmp/oza1.oza");
 Real Copy(NObject);


// Lunes, 2010/11/08 21:04:04.00
Real Ois.Store([[Real 1]], "/tmp/oza1.oza");


// Miercoles, 2010/11/03 19:16:57.00
#Require MMS;


// Miercoles, 2010/11/03 17:10:58.00
Matrix KK = Rand( 1000, 1000, 0, 1 );
Matrix YY = Rand( 100, 10000, 0, 1 );

Real Ois.Store( [[ KK, YY ]], "/tmp/kk.oza" );


// Miercoles, 2010/11/03 17:07:36.00
Real Ois.Store( [[ StdLib ]], "/tmp/StdLib.oza" );


// Martes, 2010/11/02 20:55:16.00
Serie G = Gaussian( 0,1);
Serie G1 = DatCh( G, M(1) + M(4) + M(7) + M(10), MaxS );
Serie G2 = DatCh( G, Trimestral, MaxS );


// Martes, 2010/11/02 20:53:23.00
Serie G = Gaussian( 0,1);
Serie G1 = DatCh( G, M(1) + M(4) + M(8), MaxS );



// Martes, 2010/11/02 20:41:50.00
#Require MMS;



// Martes, 2010/11/02 20:41:30.00
#Require BysMcmc;



// Martes, 2010/11/02 20:41:10.00
#Require GuiTools;



// Viernes, 2010/10/29 15:44:01.00
Code @Transformation.BoxCoxNotSer::Declare

// Viernes, 2010/10/29 15:32:12.00
#Require MMS;

Real @Transformation.BoxCoxNotSer::Declare(?);

Code MMS::@Transformation::AppendFamily


// Viernes, 2010/10/29 15:29:35.00
#Require MMS;

Real @Transformation.BoxCoxNotSer::Declare(?);

Code MMS::@Transformation::AppendFamily


// Viernes, 2010/10/29 15:29:24.00
#Require MMS;

Real @Transformation.BoxCoxNotSer::Declare(?)

Code MMS::@Transformation::AppendFamily


// Viernes, 2010/10/29 15:28:38.00
Code MMS::@Transformation::AppendFamily

// Viernes, 2010/10/29 15:28:33.00
#Require MMS;

Real @Transformation.BoxCoxNotSer::Declare(?)

Code MMS::@Transformation::AppendFamily


// Viernes, 2010/10/29 15:28:03.00
#Require MMS;

Real @Transformation.BoxCoxNotSer::Declare(?)


// Viernes, 2010/10/29 15:27:36.00
#Require MMS;

Real @Transformation.BoxCoxNotSer::Declare(?)


// Viernes, 2010/10/29 15:26:50.00
#Require MMS;

Real @Transformation.BoxCoxNotSer::Declare(?)


// Viernes, 2010/10/29 15:24:05.00
#Require MMS;


// Miercoles, 2010/10/27 17:05:36.00
#Require MMS;


// Miercoles, 2010/10/27 12:46:03.00
//Real TolPackage::Client::RemoteUpgradeAll(True);
#Require MMS;




// Miercoles, 2010/10/27 12:45:02.00
Real TolPackage::Client::RemoteUpgradeAll(True);




// Lunes, 2010/10/25 16:57:55.00
Set kk = Include( "/media/nas/bdr/entity/PrjBysForMeMoCC/data/modelMensual/ModMens2010MovilTotSerSet20101025.oza" );


// Viernes, 2010/10/22 23:36:13.00
Date DefFirst := y2005;
Date DefLast := y2012;

#Require MMS;

Real MMS::Container::LoadFile( "/tmp/test.oza" );



// Viernes, 2010/10/22 22:42:45.00
#Require MMS;

Real MMS::Container::LoadFile( "/tmp/test.oza" );


// Viernes, 2010/10/22 22:42:31.00
#Require MMS;

Real MMS::Container::LoadFile( "/tmp/test.oza" );


// Viernes, 2010/10/22 22:41:44.00
Date DefFirst := y2005;
Date DefLast := y2012;




// Viernes, 2010/10/22 18:24:41.00
Date DefFirst := y2005;
Date DefLast := y2012;

// Viernes, 2010/10/22 18:22:46.00
Real MMS::Container::LoadFile( "/tmp/test.oza" );

// Viernes, 2010/10/22 18:06:19.00

Real MMS::Container::LoadFile( "/tmp/SPMPNP_INP_FAC__1.0_Empty.oza" );

// Viernes, 2010/10/22 18:06:13.00
#Require MMS;

// Viernes, 2010/10/22 10:47:22.00
Serie SpainHolidays::GetPaisSerieFestivos(0);


// Jueves, 2010/10/21 16:04:18.00
Real SpainHolidays::LoadHolidays( "/home/jsperez/TOL/projects/bsd/entity/PrjBysForMeMoCC/data/Festivos/bst" );



// Jueves, 2010/10/21 16:01:23.00
Real SpainHolidays::LoadHolidays( "/home/jsperez/TOL/projects/bsd/entity/PrjBysForMeMoCC/data/Festivos/bst" );



// Jueves, 2010/10/21 15:58:46.00
Real SpainHolidays::LoadHolidays( "/home/jsperez/TOL/projects/bsd/entity/PrjBysForMeMoCC/data/Festivos/bst" );



// Jueves, 2010/10/21 15:58:15.00
Real SpainHolidays::LoadHolidays( "/home/jsperez/TOL/projects/bsd/entity/PrjBysForMeMoCC/data/Festivos/bst" );



// Jueves, 2010/10/21 15:57:17.00
Real SpainHolidays::LoadHolidays( "/home/jsperez/TOL/projects/bsd/entity/PrjBysForMeMoCC/data/Festivos/bst" );



// Miercoles, 2010/10/20 20:22:11.00
NameBlock kk = [[
  Struct @aa { Real a; Real b };
  Set bb = @aa(1,2)
]];

Set cc = kk::@aa(3,4);


// Miercoles, 2010/10/20 20:21:51.00
NameBlock kk = [[
  Struct @aa { Real a; Real b };
  Set bb = @aa(1,2)
]];

Set cc = @aa(3,4);


// Miercoles, 2010/10/20 20:21:00.00
NameBlock kk = [[
  Struct @aa { Real a; Real b };
  Set bb = @aa(1,2)
]];


// Miercoles, 2010/10/20 20:20:52.00
NAmeBlock kk = [[
  Struct @aa { Real a; Real b };
  Set bb = @aa(1,2)
]];


// Martes, 2010/10/19 00:43:20.00
#Require MMS;


// Jueves, 2010/10/14 10:12:16.00
NameBlock MMS::Containter::GetModel( "jjj" );


// Miercoles, 2010/10/13 20:35:44.00
Text GetSourcePath(INC.MMS[1])


// Miercoles, 2010/10/13 20:26:30.00
Real TextFind(GetTOLPath(INC.MMS), "RELEASE-0.5")


// Miercoles, 2010/10/13 20:25:30.00
Text GetTOLPath(INC.MMS)


// Miercoles, 2010/10/13 20:25:21.00
Text GetTOLPath(INC.MMS[1])


// Miercoles, 2010/10/13 20:22:25.00
Text Name(INC.MMS[1])


// Miercoles, 2010/10/13 18:57:25.00
Real estBSR::Execute(?);

// Miercoles, 2010/10/13 18:56:37.00
Real estEstimate::Execute(?);


// Miercoles, 2010/10/13 18:51:28.00
MMS::@Model _.model = MMS::Container::GetModel([["Model.CheckBsrEstimate","1.0"]]);



// Miercoles, 2010/10/13 18:50:51.00
MMS::@Model _.model = MMS::Container::GetModel([["Model.CheckBsrEstimate","1"]]);



// Miercoles, 2010/10/13 18:32:02.00
Real MMS::Container::FindModel(SetOfAnything("Model.CheckBsrEstimate", "1"))


// Miercoles, 2010/10/13 18:30:55.00
NameBlock MMS::Container::GetModel(SetOfAnything("Model.CheckBsrEstimate", "1"))


// Miercoles, 2010/10/13 18:30:16.00
MMS::Container::GetModel(1)


// Miercoles, 2010/10/13 18:30:04.00
MMS::Container::GetModel


// Miercoles, 2010/10/13 18:27:57.00
MMS::Container::GetModel([["Model.CheckBsrEstimate","1"]]);


// Miercoles, 2010/10/13 17:59:20.00
MMS::Container


// Miercoles, 2010/10/13 17:51:47.00
MMS::Container::GetModel


// Miercoles, 2010/10/13 17:51:19.00
MMS::Container


// Miercoles, 2010/10/13 16:29:13.00
MMS


// Miercoles, 2010/10/13 16:20:09.00
Set GetArimaFromLabel( "P1DIF1AR0MA1" )

// Miercoles, 2010/10/13 16:19:34.00
Set GetArimaFromLabel( "P1DIF0AR0MA1" )

// Viernes, 2010/10/08 00:47:50.00
Polyn IRF1 = Expand( (1-2)/(1-2*B), 50 );
Polyn IRF2 = Expand( (1-0.9)/(1-0.9*B), 100 );


Matrix matIRF1 = PolMat( IRF1, 101, 1 );
Matrix matIRF2 = PolMat( IRF2, 102, 1 );

Real Gain1 = MatSum( matIRF1 );
Real Gain2 = MatSum( matIRF2 );


// Viernes, 2010/10/08 00:47:30.00
Polyn IRF1 = Expand( (1-2)/(1-2*B), 50 );
Polyn IRF2 = Expand( (1-0.1)/(1-0.1*B), 100 );


Matrix matIRF1 = PolMat( IRF1, 101, 1 );
Matrix matIRF2 = PolMat( IRF2, 102, 1 );

Real Gain1 = MatSum( matIRF1 );
Real Gain2 = MatSum( matIRF2 );


// Viernes, 2010/10/08 00:44:48.00
Polyn IRF1 = Expand( (1-2)/(1-2*B), 50 );
Polyn IRF2 = Expand( (1-0.5)/(1-0.5*B), 100 );


Matrix matIRF1 = PolMat( IRF1, 101, 1 );
Matrix matIRF2 = PolMat( IRF2, 102, 1 );

Real Gain1 = MatSum( matIRF1 );
Real Gain2 = MatSum( matIRF2 );

// Viernes, 2010/10/08 00:43:57.00
Polyn IRF1 = Expand( (1-2)/(1-2*B), 50 );
Polyn IRF2 = Expand( (1-0.5)/(1-0.5*B), 100 );


Matrix PolMat( IRF1, 101, 1 );
Matrix PolMat( IRF2, 102, 1 );

Real Gain1 = MatSum( IRF1 );
Real Gain2 = MatSum( IRF2 );

// Viernes, 2010/10/08 00:42:26.00
Polyn IRF1 = Expand( (1-2)/(1-2*B), 50 );
Polyn IRF2 = Expand( (1-0.5)/(1-0.5*B), 50 );


Matrix PolMat( IRF1, 51, 1 );
Matrix PolMat( IRF2, 51, 1 );


// Viernes, 2010/10/08 00:41:33.00
Polyn IRF1 = Expand( (1-2)/(1-2*B), 50 );
Polyn IRF2 = Expand( (1-0.5)/(1-0.5*B), 50 );


Matrix PolMat( IRF1, 51, 1 );
Matrix PolMat( IRF1, 51, 1 );

// Viernes, 2010/10/08 00:40:25.00
Matrix PolMat( IRF1, 10, 1 );
Matrix PolMat( IRF1, 11, 1 );

// Viernes, 2010/10/08 00:39:46.00
Polyn IRF1 = Expand( (1-2)/(1-2*B), 10 );

// Viernes, 2010/10/08 00:39:39.00
Expand( (1-2)/(1-2*B), 10 );

// Jueves, 2010/10/07 23:34:27.00
Serie Trend02 = SubSer(DifEq(1/(1-B), TrendG),y2009m01,y2011m01);

// Jueves, 2010/10/07 23:30:11.00
Serie indicator = CalInd(M(1) + M(2) + M(3),Monthly);

// Jueves, 2010/10/07 23:26:17.00
Serie PulseG     = Pulse(y2010, Monthly);
Serie CompensG   = Compens(y2010, Monthly);
Serie StepG      = Step(y2010m06, Monthly);
Serie TrendG     = SubSer(Trend(y2010, Monthly),y2009m01,y2011m01);
Serie IndicatorG = CalInd(Y(2010),Monthly);

// Jueves, 2010/10/07 23:00:45.00
Serie g = Gaussian(0,1);
Serie g0 = SubSer( g, y2010,y2011);
Serie f = (F-2+B):g;
Serie f0 = (F-2+B):g0;

// Jueves, 2010/10/07 21:40:00.00
Serie F:serieWithMissing;

// Jueves, 2010/10/07 21:37:28.00
Serie B:serieWithMissing;

// Jueves, 2010/10/07 21:09:35.00
Real SumSMissing(Serie ser, Date ini, Date end)
{
  Serie unknown = SubSer(IsUnknown(ser), ini, end);
  Date firstNotUnknown = FirstNotEqual(unknown, ini, 0);
  If(firstNotUnknown <= end, ?,  SumS(ser, ini, end))
};

Serie serieSum2 = DatCh( serieWithMissing, Monthly, SumSMissing );

// Jueves, 2010/10/07 21:09:23.00
Serie serieWithMissing  = 
(SubSer(CalInd(C, Diario), y2001m01d01, y2002m01d01)*
 Not(Pulse(y2001m03d04, Diario)))/Not(Pulse(y2001m03d04, Diario));

Serie serieSum1 =  DatCh( serieWithMissing, Monthly, SumS );


// Jueves, 2010/10/07 20:54:41.00
Serie cal  = 
(SubSer(CalInd(C, Diario), y2001m01d01, y2002m01d01)*
 Not(Pulse(y2001m03d04, Diario)))/Not(Pulse(y2001m03d04, Diario));

// Jueves, 2010/10/07 20:30:01.00
Serie a = 1;
Serie b = DatCh( a, WeekEnd, SumS );


// Jueves, 2010/10/07 16:35:20.00
Real MatSum( PolMat( Expand(aa, 50), 50, 1 ) );

// Jueves, 2010/10/07 16:34:39.00
Matrix PolMat( Expand(aa, 50), 50, 1 );

// Jueves, 2010/10/07 16:30:30.00
Ratio aa = (1-0.7)/(1-0.7*B);
Polyn Expand(aa, 50)

// Jueves, 2010/10/07 16:29:39.00
Ratio aa = (1-0.7)/(1-0.7*B);
Polyn RationExpand(aa)

// Jueves, 2010/10/07 15:21:42.00
TimeSet WD(0);

// Jueves, 2010/10/07 15:12:01.00
TimeSet Periodic(y2010,10,WD(6));

// Jueves, 2010/10/07 15:11:57.00
Serie DatCh(CalInd(WeekEnd,WeekEnd),Monthly,CountS);

Serie CalVar(WeekEnd,Monthly);

Serie CalInd( WD(7)*D(1), Monthly );

Serie CalVar(WeekEnd,Monthly)/2 + CalInd( WD(7)*D(1), Monthly ) + CalInd( WD(6)*Succ( D(1),-1 ), Monthly )

CalInd(WD(1)+WD(2)+WD(3)+WD(4)+WD(5), Diario)

Serie Gaussian( 0, 1, Hourly );

TimeSet M(1)+M(2)

//////////////////////////////////////////////////////////////////////////////
Serie SubSer( DifEqRho(Date y2008m5, 0.7 ), y2008, y2009 );
Serie SubSer( DifEqRho(Date y2008m5, 0.5 ), y2008, y2009 );
Serie SubSer( DifEqRho(Date y2008m5, 0.3 ), y2008, y2009 );
Serie SubSer( DifEqRho(Date y2008m5, 0.1 ), y2008, y2009 );

TimeSet Y(0);

Serie SubSer( Gaussian(0,1,Y(1583)), y1583,y1584);

TimeSet CtFifthSunMonth = (D(29)+D(30)+D(31)) * WD(7);
TimeSet CtFirstDayMonth5Sun = Succ(CtFifthSunMonth, -1, D(1));

TimeSet Periodic(y2010,10,WD(6));


// Jueves, 2010/10/07 15:11:22.00
TimeSet Periodic(y2010,10,Daily);

// Jueves, 2010/10/07 15:10:52.00
TimeSet Periodic(y2010,1,Daily);

// Jueves, 2010/10/07 15:07:20.00
TimeSet CtFifthSunMonth = (D(29)+D(30)+D(31)) * WD(7);
TimeSet CtFirstDayMonth5Sun = Succ(CtFifthSunMonth, -1, D(1));

// Jueves, 2010/10/07 14:59:49.00
Serie SubSer( Gaussian(0,1,Y(1583)), y1583,y1584);

// Jueves, 2010/10/07 14:59:38.00
Serie SubSer( Gaussian(0,1,Y(1582)), y1582,y1583);

// Jueves, 2010/10/07 14:59:27.00
Serie SubSer( Gaussian(0,1,Y(1585)), y1585,y1585);

// Jueves, 2010/10/07 14:59:17.00
Serie SubSer( Gaussian(0,1,Y(1581)), y1581,y1582);

// Jueves, 2010/10/07 14:59:07.00

Serie SubSer( Gaussian(0,1,Y(1580)), y1580,y1581);

// Jueves, 2010/10/07 14:58:04.00
Serie SubSer( Gaussian(0,1,Y(1590)), y1590,y1591);

// Jueves, 2010/10/07 14:57:37.00
Serie SubSer( Gaussian(0,1,Y(1600)), y1600,y1601);

// Jueves, 2010/10/07 14:57:22.00
Serie SubSer( Gaussian(0,1,Y(1580)), y1580,y1581);

// Jueves, 2010/10/07 14:56:46.00
Serie SubSer( Gaussian(0,1,Y(1700)), y1700,y1701);

// Jueves, 2010/10/07 14:56:17.00
Serie SubSer( Gaussian(0,1,Y(1500)), y1500,y1501);

// Jueves, 2010/10/07 14:56:02.00
Serie SubSer( Gaussian(0,1,Y(0)), y0,y1);

// Jueves, 2010/10/07 14:55:43.00
Serie SubSer( Gaussian(0,1,Y(2000)), y2000,y2001);

// Jueves, 2010/10/07 14:55:10.00
Serie Gaussian(0,1,Y(2000));

// Jueves, 2010/10/07 14:54:56.00
Serie Gaussian(0,1,Y(1900));

// Jueves, 2010/10/07 14:54:44.00
Serie Gaussian(0,1,Y(1800));

// Jueves, 2010/10/07 14:54:25.00
Serie Gaussian(0,1,Y(1600));

// Jueves, 2010/10/07 14:54:08.00
Serie Gaussian(0,1,Y(1500));

// Jueves, 2010/10/07 14:53:52.00

Serie Gaussian(0,1,Y(1));

// Jueves, 2010/10/07 14:53:34.00
Serie Gaussian(0,1,Y(0));

// Jueves, 2010/10/07 14:53:06.00
TimeSet Y(0);

// Jueves, 2010/10/07 13:57:55.00
Serie Gaussian( 0, 1, Hourly );

// Jueves, 2010/10/07 13:48:16.00
Serie SubSer( DifEqRho(Date y2008m5, 0.7 ), y2008, y2009 );
Serie SubSer( DifEqRho(Date y2008m5, 0.5 ), y2008, y2009 );
Serie SubSer( DifEqRho(Date y2008m5, 0.3 ), y2008, y2009 );
Serie SubSer( DifEqRho(Date y2008m5, 0.1 ), y2008, y2009 );

// Jueves, 2010/10/07 13:47:47.00
Serie SubSer( DifEqRho(Date y2008m5, 0.7 ), y2008, y2009 );

// Jueves, 2010/10/07 13:47:13.00
Serie DifEqRho(Date y2008m5, 0.7 );

// Jueves, 2010/10/07 13:47:06.00
Serie DatCh(CalInd(WeekEnd,WeekEnd),Monthly,CountS);

Serie CalVar(WeekEnd,Monthly);

Serie CalInd( WD(7)*D(1), Monthly );

Serie CalVar(WeekEnd,Monthly)/2 + CalInd( WD(7)*D(1), Monthly ) + CalInd( WD(6)*Succ( D(1),-1 ), Monthly )

CalInd(WD(1)+WD(2)+WD(3)+WD(4)+WD(5), Diario)

TimeSet M(1)+M(2)

//////////////////////////////////////////////////////////////////////////////
Serie DifEqRho(Date y2008m5, 0.7 );


// Jueves, 2010/10/07 13:46:31.00
Serie DifEqRho(Date y2010m5, 0.7 );

// Jueves, 2010/10/07 13:46:00.00
Serie DifEqRho(Date d1, Real rho )
//////////////////////////////////////////////////////////////////////////////
{
Serie ser   = SubSer(Pulse(d1, Diario), y1999, y2009);
Serie difEq = DifEq( (1-rho)/(1-rho*B), ser, 0);
Serie out   = difEq;
out 
};


// Jueves, 2010/10/07 12:42:48.00
TimeSet M(1)+M(2)

// Jueves, 2010/10/07 12:40:09.00
CalInd(WD(1)+WD(2)+WD(3)+WD(4)+WD(5), Diario)

// Jueves, 2010/10/07 12:11:33.00
Serie CalVar(WeekEnd,Monthly)/2 + CalInd( WD(7)*D(1), Monthly ) + CalInd( WD(6)*Succ( D(1),-1 ), Monthly )

// Jueves, 2010/10/07 12:05:13.00

Serie CalVar(WeekEnd,Monthly)/2 + CalInd( WD(7)*D(1), Monthly );

// Jueves, 2010/10/07 12:04:29.00

Serie CalInd( WD(7)*D(1), Monthly );

// Jueves, 2010/10/07 12:01:21.00
CalInd(WeekEnd,WeekEnd)

// Jueves, 2010/10/07 12:00:57.00
Serie DatCh(CalInd(WeekEnd,WeekEnd),Monthly,CountS);

Serie CalVar(WeekEnd,Monthly);


// Jueves, 2010/10/07 09:58:54.00
TimeSet WD(6)-(Range(D(1)*M(1), -5, 2, Diario))

// Jueves, 2010/10/07 09:55:31.00
TimeSet Range(D(1)*M(1), -5, 2, Diario);

// Jueves, 2010/10/07 09:53:07.00
TimeSet CtSem445 = D(1)*M(1)+(WD(6)-(Range(D(1)*M(1), -5, 2, Diario))); 


// Miercoles, 2010/10/06 17:01:36.00
Real F1(Real a )
{
  Real j = a;
  Real k = F2( j );
  WriteLn( "voy por aqui" );
  Real j + k

};

Real F2( Real k )
{
  malo
};

Real ii = F1( 2 );


// Viernes, 2010/09/24 12:23:25.00
Serie test1 = SubSer( Gaussian(0,1, WeekEnd), y2010, y2010m12d31 );
Serie DatCh( test1, Mensual, CountS );


// Viernes, 2010/09/24 12:20:24.00
Serie test1 = SubSer( Gaussian(0,1), y2010, y2010m12d31 );
Serie DatCh( test1, Mensual, CountS );


// Jueves, 2010/09/23 21:39:16.00
Serie SubSer( Gaussian( 0, 1, WeekEnd ), y2010, y2010m12d31 );


// Jueves, 2010/09/23 21:39:11.00
Serie SubSer( Gaussian( 0, 1, WeekEnd ) y2010, y2010m12d31 );


// Miercoles, 2010/09/22 18:30:06.00
Serie ser01 = SubSer(Gaussian(100, 10, Diario), y2010m01d01, y2011m01d01);
Serie ser01.Sem = DatCh(ser01, Semanal, FirstS);
Serie ser01.WD2 = DatCh(ser01, WD(2), FirstS);
Serie ser01.WD3 = DatCh(ser01, WD(3), FirstS);


// Miercoles, 2010/09/22 16:06:30.00
Serie test = SubSer( Gaussian( 0, 1 ), y2010m1d5, y2010m12d18 );
Real AvrS( test, y2010, y2010m2 );

Real (1 + ?)/2


// Miercoles, 2010/09/22 16:06:14.00
Serie test = SubSer( Gaussian( 0, 1 ), y2010m1d5, y2010m12d18 );
Real AvrS( test, y2010, y2010m2 );

Real 1 + ?


// Miercoles, 2010/09/22 16:03:26.00
Real Avr( 1,2,3, ?);

// Miercoles, 2010/09/22 16:03:18.00
Real Avr( 1,2,3);

// Miercoles, 2010/09/22 16:02:55.00
Serie test = SubSer( Gaussian( 0, 1 ), y2010m1d5, y2010m12d18 );
Real AvrS( test, y2010, y2010m2 );


// Martes, 2010/09/21 23:12:48.00
Serie test1 = SubSer( Gaussian( 4, 0.1 ), y2010m1d25, y2010m12d5 );
Serie test2 = DatCh( test1, Monthly, AvrS );


// Martes, 2010/09/21 21:49:25.00
Serie test1 = SubSer( Gaussian( 4, 0.1 ), y2010m1d25, y2010m12d5 );
Serie test2 = DatCh( test1, Monthly, FirstS );


// Martes, 2010/09/21 21:30:15.00
Serie test1 = SubSer( Gaussian( 4, 0.1 ), y2010m1d25, y2010m12d5 );
Serie test2 = DatCh( test1, Monthly, AvrS );


// Martes, 2010/09/21 21:29:51.00
Serie test1 = SubSer( Gaussian( 4, 1 ), y2010m1d25, y2010m12d5 );
Serie test2 = DatCh( test1, Monthly, AvrS );


// Martes, 2010/09/21 21:29:29.00
Serie test1 = SubSer( Gaussian( 4, 1 ), y2010m1d25, y2010m12d5 );
Serie test2 = DatCh( test1, Monhtly, AvrS );


// Martes, 2010/09/21 21:28:15.00
Serie test1 = SubSer( Gaussian( 4, 1 ), y2010m1d25, y2010m12d5 );


// Martes, 2010/09/21 16:06:33.00
/*
  Muestrea Y ~ N(means,sigma^2*I)*I(Y>Y_Bs) 
*/
Matrix SampleV3GTotalConditioned( Matrix means, Real sigma, Matrix volBS )
{
  Matrix SetCol( For( 1, Rows( means ), Real( Real r ) {
    Real m = MatDat( means, r, 1 );
    Real low = MatDat( volBS, r, 1 );
    Real gsl_ran_gaussian_tail( low - m, sigma) + m
  } ) )
};

/*
  Muestrea Y ~ N(means,sigma^2*I)*I(Y<Y_tot) 
*/
Matrix SampleV3GBigScrConditioned( Matrix means, Real sigma, Matrix volTot )
{
  Matrix SetCol( For( 1, Rows( means ), Real( Real r ) {
    Real m = MatDat( means, r, 1 );
    Real low = MatDat( volTot, r, 1 );
    Real -gsl_ran_gaussian_tail( -low + m, sigma) + m
  } ) )
};

// esto es un ejemplo de uso

Real N = 2500;
Real sigmaTot = 0.8;
Real sigmaBs = 0.7;
Matrix Y_tot = Gaussian( 2500, 1, 10, sigmaTot );
Matrix Y_bs = Gaussian( 2500, 1, 9.5, sigmaBs );
Matrix doesNotHold = Y_tot | Y_bs;

Matrix sampleYTot = SampleV3GTotalConditioned( Y_tot, sigmaTot, Y_bs );

Matrix sampleYBs = SampleV3GBigScrConditioned( Y_bs, sigmaBs, sampleYTot );

Matrix doHold = sampleYTot | sampleYBs;


// Martes, 2010/09/21 16:06:06.00
/*
  Muestrea Y ~ N(means,sigma^2*I)*I(Y>Y_Bs) 
*/
Matrix SampleV3GTotalConditioned( Matrix means, Real sigma, Matrix volBS )
{
  Matrix SetCol( For( 1, Rows( means ), Real( Real r ) {
    Real m = MatDat( means, r, 1 );
    Real low = MatDat( volBS, r, 1 );
    Real gsl_ran_gaussian_tail( low - m, sigma) + m
  } ) )
};

/*
  Muestrea Y ~ N(means,sigma^2*I)*I(Y<Y_tot) 
*/
Matrix SampleV3GBigScrConditioned( Matrix means, Real sigma, Matrix volTot )
{
  Matrix SetCol( For( 1, Rows( means ), Real( Real r ) {
    Real m = MatDat( means, r, 1 );
    Real low = MatDat( volTot, r, 1 );
    Real -gsl_ran_gaussian_tail( -low + m, sigma) + m
  } ) )
};

// esto es un ejemplo de uso

Real N = 2500;
Real sigmaTot = 0.8;
Real sigmaBs = 0.7;
Matrix Y_tot = Gaussian( 2500, 1, 10, sigmaTot );
Matrix Y_bs = Gaussian( 2500, 1, 9.5, sigmaBs );
Matrix doesNotHold = Y_tot | Y_bs;

Matrix sampleYTot = SampleV3GTotalConditioned( Y_tot, sigmaTot, Y_bs );

Matrix sampleYBs = SampleV3GBigScrConditioned( Y_bs, sigmaBs, sampleYTot );

Matrix doHold = sampleYTot | sampleYBs;


// Martes, 2010/09/21 16:05:56.00
/*
  Muestrea Y ~ N(means,sigma^2*I)*I(Y>Y_Bs) 
*/
Matrix SampleV3GTotalConditioned( Matrix means, Real sigma, Matrix volBS )
{
  Matrix SetCol( For( 1, Rows( means ), Real( Real r ) {
    Real m = MatDat( means, r, 1 );
    Real low = MatDat( volBS, r, 1 );
    Real gsl_ran_gaussian_tail( low - m, sigma) + m
  } ) )
};

/*
  Muestrea Y ~ N(means,sigma^2*I)*I(Y<Y_tot) 
*/
Matrix SampleV3GBigScrConditioned( Matrix means, Real sigma, Matrix volTot )
{
  Matrix SetCol( For( 1, Rows( means ), Real( Real r ) {
    Real m = MatDat( means, r, 1 );
    Real low = MatDat( volTot, r, 1 );
    Real -gsl_ran_gaussian_tail( -low + m, sigma) + m
  } ) )
};

// esto es un ejemplo de uso

Real N = 2500;
Real sigmaTot = 0.8;
Real sigmaBs = 0.7;
Matrix Y_tot = Gaussian( 2500, 1, 10, sigmaTot );
Matrix Y_bs = Gaussian( 2500, 1, 9.5, sigmaBs );
Matrix doesNotHold = Y_tot | Y_bs;

Matrix sampleYTot = SampleV3GTotalConditioned( Y_tot, sigmaTot, Y_bs );

Matrix sampleYBs = SampleV3GBigScrConditioned( Y_bs, sigmaBs, sampleYTot );

Matrix doHold = sampleYTot | sampleYBs;


// Martes, 2010/09/21 16:02:54.00
/*
  Muestrea Y ~ N(means,sigma^2*I)*I(Y>Y_Bs) 
*/
Matrix SampleV3GTotalConditioned( Matrix means, Real sigma, Matrix volBS )
{
  Matrix SetCol( For( 1, Rows( means ), Real( Real r ) {
    Real m = MatDat( means, r, 1 );
    Real low = MatDat( volBS, r, 1 );
    Real gsl_ran_gaussian_tail( low - m, sigma) + m
  } ) )
};

/*
  Muestrea Y ~ N(means,sigma^2*I)*I(Y<Y_tot) 
*/
Matrix SampleV3GBigScrConditioned( Matrix means, Real sigma, Matrix volTot )
{
  Matrix SetCol( For( 1, Rows( means ), Real( Real r ) {
    Real m = MatDat( means, r, 1 );
    Real low = MatDat( volTot, r, 1 );
    Real -gsl_ran_gaussian_tail( -low + m, sigma) + m
  } ) )
};

Real N = 2500;
Real sigmaTot = 0.8;
Real sigmaBs = 0.7;
Matrix Y_tot = Gaussian( 2500, 1, 10, sigmaTot );
Matrix Y_bs = Gaussian( 2500, 1, 9.5, sigmaBs );
Matrix Y_tot | Y_bs;

Matrix sampleYTot = SampleV3GTotalConditioned( Y_tot, sigmaTot, Y_bs );

Matrix sampleYTot | Y_bs;

Matrix sampleYBs = SampleV3GBigScrConditioned( Y_bs, sigmaBs, sampleYTot );

Matrix sampleYTot | sampleYBs;



// Martes, 2010/09/21 16:02:10.00
/*
  Muestrea Y ~ N(means,sigma^2*I)*I(Y>Y_Bs) 
*/
Matrix SampleV3GTotalConditioned( Matrix means, Real sigma, Matrix volBS )
{
  Matrix SetCol( For( 1, Rows( means ), Real( Real r ) {
    Real m = MatDat( means, r, 1 );
    Real low = MatDat( volBS, r, 1 );
    Real gsl_ran_gaussian_tail( low - m, sigma) + m
  } ) )
};

/*
  Muestrea Y ~ N(means,sigma^2*I)*I(Y<Y_tot) 
*/
Matrix SampleV3GBigScrConditioned( Matrix means, Real sigma, Matrix volTot )
{
  Matrix SetCol( For( 1, Rows( means ), Real( Real r ) {
    Real m = MatDat( means, r, 1 );
    Real low = MatDat( volTot, r, 1 );
    Real -gsl_ran_gaussian_tail( -low + m, sigma) + m
  } ) )
};

Real sigmaTot = 0.8;
Real sigmaBs = 0.7;
Matrix Y_tot = Gaussian( 100, 1, 10, sigmaTot );
Matrix Y_bs = Gaussian( 100, 1, 9.5, sigmaBs );
Matrix Y_tot | Y_bs;

Matrix sampleYTot = SampleV3GTotalConditioned( Y_tot, sigmaTot, Y_bs );

Matrix sampleYTot | Y_bs;

Matrix sampleYBs = SampleV3GBigScrConditioned( Y_bs, sigmaBs, sampleYTot );

Matrix sampleYTot | sampleYBs;






// Martes, 2010/09/21 16:01:06.00
Matrix sampleYTot | Y_bs;

// Martes, 2010/09/21 15:59:15.00
/*
  Muestrea Y ~ N(means,sigma^2*I)*I(Y>Y_Bs) 
*/
Matrix SampleV3GTotalConditioned( Matrix means, Real sigma, Matrix volBS )
{
  Matrix SetCol( For( 1, Rows( means ), Real( Real r ) {
    Real m = MatDat( means, r, 1 );
    Real low = MatDat( volBS, 3, 1 );
    Real gsl_ran_gaussian_tail( low - m, sigma) + m
  } ) )
};

/*
  Muestrea Y ~ N(means,sigma^2*I)*I(Y<Y_tot) 
*/
Matrix SampleV3GBigScrConditioned( Matrix means, Real sigma, Matrix volTot )
{
  Matrix SetCol( For( 1, Rows( means ), Real( Real r ) {
    Real m = MatDat( means, r, 1 );
    Real low = MatDat( volTot, 3, 1 );
    Real -gsl_ran_gaussian_tail( -low + m, sigma) + m
  } ) )
};

Real sigmaTot = 0.8;
Real sigmaBs = 0.7;
Matrix Y_tot = Gaussian( 100, 1, 10, sigmaTot );
Matrix Y_bs = Gaussian( 100, 1, 9.5, sigmaBs );
Matrix Y_tot | Y_bs;

Matrix sampleYTot = SampleV3GTotalConditioned( Y_tot, sigmaTot, Y_bs );
Matrix sampleYBs = SampleV3GBigScrConditioned( Y_bs, sigmaBs, sampleYTot );

Matrix sampleYTot | sampleYBs;






// Martes, 2010/09/21 15:57:30.00
Matrix SampleV3GTotalConditioned( Y_tot, sigmaTot, Y_bs );

// Martes, 2010/09/21 15:55:42.00
/*
  Muestrea Y ~ N(means,sigma^2*I)*I(Y>Y_Bs) 
*/
Matrix SampleV3GTotalConditioned( Matrix means, Real sigma, Matrix volBS )
{
  Matrix SetCol( For( 1, Rows( means ), Real( Real r ) {
    Real m = MatDat( means, r, 1 );
    Real low = MatDat( volBS, 3, 1 );
    Real gsl_ran_gaussian_tail( low - m, sigma) + m
  } ) )
};

/*
  Muestrea Y ~ N(means,sigma^2*I)*I(Y<Y_tot) 
*/
Matrix SampleV3GBigScrConditioned( Matrix means, Real sigma, Matrix volTot )
{
  Matrix SetCol( For( 1, Rows( means ), Real( Real r ) {
    Real m = MatDat( means, r, 1 );
    Real low = MatDat( volTot, 3, 1 );
    Real -gsl_ran_gaussian_tail( -low + m, sigma) + m
  } ) )
};

Real sigmaTot = 0.8;
Real sigmaBs = 0.7;
Matrix Y_tot = Gaussian( 100, 1, 10, sigmaTot );
Matrix Y_bs = Gaussian( 100, 1, 9.5, sigmaBs );




// Lunes, 2010/09/20 10:39:52.00
#Require GuiTools;


// Lunes, 2010/09/20 10:39:13.00
Real TolPackage::Client::Upgrade.AllInAll(0);


// Viernes, 2010/09/17 10:46:29.00
#Require BysMcmc


// Viernes, 2010/09/17 10:45:47.00
#Require GuiTools


// Viernes, 2010/09/17 10:43:52.00
Real TolPackage::Client::Upgrade.AllInAll(0);


// Viernes, 2010/09/17 10:35:57.00
#Require GuiTools


// Lunes, 2010/09/13 15:40:48.00
Set GetArimaFromLabel( "P1_7DIF0_1AR1.2_0MA0_7" );


// Miercoles, 2010/09/08 10:37:58.00
#Require PtswClient;

Text co_country = "ESP";
Text co_concept = "GdpRea";
Text co_metric = "AnnGrw";
Text co_units = "Prc";
Date dh_published_min = y2005m06d01;

Set seriesBySourceAndPublished = DBSeriesColumn("
SELECT  
  co_source||'.'||
  co_country||'.'||
  co_concept||'.'||
  co_metric||'.'||
  co_units||'.'||
  (case when nu_year_base is null then '' else 'B'||nu_year_base||'.' end)||
  'Pub'||to_char(dh_published,'YYYYMMDD') series_code,
  dh_date,
  round(avg(vl_value)*1000000.0)/1000000.0 as value_
FROM 
  bayes_economic_outlook.data_f_collected as Dat,
  bayes_economic_outlook.country_d_declare as Ctr,
  bayes_economic_outlook.source_d_declare as Src,
  bayes_economic_outlook.magnitude_d_declare as Mag,
  bayes_economic_outlook.concept_d_declare as Con,
  bayes_economic_outlook.metric_d_declare as Met,
  bayes_economic_outlook.units_d_declare as Uni
WHERE
      Ctr.co_country = '"+co_country+"'
  and Con.co_concept = '"+co_concept+"'
  and Met.co_metric = '"+co_metric+"'
  and Uni.co_units = '"+co_units+"'
  and Dat.id_country = Ctr.id_country 
  and Dat.id_magnitude = Mag.id_magnitude 
  and Dat.id_source = Src.id_source  
  and Mag.id_concept = Con.id_concept 
  and Mag.id_metric = Met.id_metric 
  and Mag.id_units = Uni.id_units 
  and dh_published >= '"+FormatDate(dh_published_min)+"' 
GROUP BY 
  co_country, co_concept, co_metric, co_units, nu_year_base, co_source,
  dh_published, dh_date   
ORDER BY
  co_country, co_concept, co_metric, co_units, nu_year_base, co_source,
  dh_published, dh_date   
",
Yearly,
?);


// Lunes, 2010/09/06 16:43:44.00
Set GetArimaFromLabel( "P0_0DIF0_0AR1_7MA1_0" )


// Lunes, 2010/09/06 16:41:12.00
Set GetArimaFromLabel( "P1_7DIF0_0AR1_7MA1_0" );


// Lunes, 2010/09/06 16:37:42.00
Set GetArimaFromLabel( "P0_0DIF0_0AR1_7MA1_0" );


// Miercoles, 2010/08/04 16:59:53.00
Real Group("And", [[1,0,1]]);


// Miercoles, 2010/08/04 16:59:46.00
Real Group("And", [[1,1,1]]);


// Miercoles, 2010/08/04 16:59:33.00
Real Group([[1,1,1]], And);


// Lunes, 2010/08/02 21:51:56.00
#Require MMS;


// Lunes, 2010/08/02 19:43:28.00
#Require GuiTools;


// Viernes, 2010/07/30 17:05:25.00
#Require MMS;


// Viernes, 2010/07/30 16:54:56.00
Real TolPackage::Client::Install( "http://packages.localbayes.es/BayesPrivateTolPackages/", "MMS.0.6", 1 );


// Viernes, 2010/07/30 16:52:32.00
Real TolPackage::Client::Install( "http://packages.localbayes.es/BayesPrivateTolPackages/", "MMS", 1 );


// Viernes, 2010/07/30 16:50:39.00
Real TolPackage::Client::Install( "http://packages.localbayes.es/BayesPrivateTolPackages/", "MMS", 1 );


// Viernes, 2010/07/30 16:49:06.00
Real TolPackage::Client::Install( "http://packages.localbayes.es/BayesPrivateTolPackages/", "MMS", 1 );


// Viernes, 2010/07/30 16:46:04.00
#Require MMS;


// Viernes, 2010/07/30 16:14:15.00
NameBlock vv = MMS::GetVariable( "VariableA01" );
Real IsInstanceOf( vv, "@MenuDesc" );
Real IsInstanceOf( vv, "GuiTools::@MenuDesc" );


// Viernes, 2010/07/30 16:13:23.00
NameBlock vv = MMS::GetVariable( "VariableA01" );


// Viernes, 2010/07/30 16:12:24.00
MMS


// Viernes, 2010/07/30 13:44:14.00

Set IncludeText(SetSum(EvalSet(buildConfig::_.packages, Text(Text pkgName) {
    "Set IncludeTOL(\""+buildConfig::_.sourceRoot+pkgName+"/"+pkgName+".tol\",True);"
  })));



// Viernes, 2010/07/30 13:43:13.00
Text SetSum(EvalSet(buildConfig::_.packages, Text(Text pkgName) {
    "Set IncludeTOL(\""+buildConfig::_.sourceRoot+pkgName+"/"+pkgName+".tol\",True);"
  }))


// Viernes, 2010/07/30 13:42:35.00
Set SetSum(EvalSet(buildConfig::_.packages, Text(Text pkgName) {
    "Set IncludeTOL(\""+buildConfig::_.sourceRoot+pkgName+"/"+pkgName+".tol\",True);"
  }))


// Viernes, 2010/07/30 13:42:21.00
SetSum(EvalSet(buildConfig::_.packages, Text(Text pkgName) {
    "Set IncludeTOL(\""+buildConfig::_.sourceRoot+pkgName+"/"+pkgName+".tol\",True);"
  }))


// Viernes, 2010/07/30 13:18:59.00
#Require GuiTools;


// Jueves, 2010/07/29 20:30:32.00
#Require PtswClient.1.1;


// Jueves, 2010/07/29 20:29:18.00
Real TolPackage::Client::Install( "http://packages.localbayes.es/BayesPrivateTolPackages/", "PtswClient", 1 );


// Jueves, 2010/07/29 20:26:05.00
Real TolPackage::Client::Install( "http://packages.localbayes.es/BayesPrivateTolPackages/", "PtswClient", 1 );


// Jueves, 2010/07/29 20:05:33.00
#Require PtswClient;


// Jueves, 2010/07/29 20:04:59.00
#Require PtswClient;


// Jueves, 2010/07/29 19:56:16.00
#Require PtswClient;


// Jueves, 2010/07/29 19:55:13.00
#Require PtswClient;


// Jueves, 2010/07/29 18:54:14.00
Real TolPackage::Client::Install( "http://packages.localbayes.es/BayesPrivateTolPackages/", "MMS", 1 );


// Jueves, 2010/07/29 18:46:33.00
Real TolPackage::Client::Install( "http://packages.localbayes.es/BayesPrivateTolPackages/", "MMS", 1 );


// Jueves, 2010/07/29 18:46:11.00
Real TolPackage::Client::Install( "http://packages.localbayes.es/BayesPrivate/TolPackages", "MMS", 1 );


// Jueves, 2010/07/29 18:45:41.00
Real TolPackage::Client::Install( "http://packages.localbayes.es/BayesPrivateTolPackages", "MMS", 1 );


// Jueves, 2010/07/29 18:45:29.00
Real TolPackage::Client::Install( "http://packages.localbayes.es/BayesPrivateTolPackages", "MMS" );


// Miercoles, 2010/07/28 14:26:06.00
// Función de busqueda
Set GetTolObjects( Text grammar, Text pattern )
{
  // cambio del status tcl
  Real {
  Text script =
  "
  proc ::getTolObjects { grammar pattern } {
    set selection [ list ]
    if { $grammar eq \"Code\" } {
      array set visitedHash {}
      foreach g [ tol::info grammars ] {
        set functionsInG [ tol::info functions $g ]
        if { $g eq \"Code\" } {
          eval lappend functionsInG [ tol::info var Code ]
        }
        foreach f $functionsInG {
          if { [ info exists visitedHash($f) ] } continue
          set visitedHash($f) 1
          if { [ string match $pattern $f  ] } {
            lappend selection \\\"$f\\\"
          }
        }
      }
    } else {
      foreach obj [ tol::info variable $grammar ] {
        if { [ string match $pattern $obj  ] } {
          lappend selection \\\"$obj\\\"
        }
      }
    }
    #puts \"selection = $selection\"
    if { [llength $selection] } {
      return \"\\[\\[[ join $selection , ]\\]\\]\"
    } else {
      return \"Copy(Empty)\"
    }
  }
  ";
   Set tclResult = Tcl_Eval( script );
   Real tclResult["status"]
  };
  // evalua a traves de TCL las opciones que se le pasan
  Set tclResult = Tcl_EvalEx( [[ "::getTolObjects", grammar, pattern ]] );
  Set If( tclResult["status"], Eval(tclResult["result"]), {
        Error( "GetTolObjects: " + tclResult["result"] );
        Copy(Empty)
      } )
};

// mis funciones de prueba
Real CodePrueba(Real a){a};
Code CodePrueba2 = CodePrueba;

Set A = GetTolObjects( "Code", "StdLib::M*" );
Set B1 = GetTolObjects( "Code", "CodeP*" );    // no devuelve nada!
Set B2 = GetTolObjects( "Real", "CodeP*" );     // no devuelve nada!

// este ejemplo deberia devolver un montón de Codes, como se ve en
// Gramaticas + Code, o bien con el buscador de funciones
Set C = GetTolObjects( "Code", "ARIMA*" );     // solo devuelve 2 resultados




// Miercoles, 2010/07/28 14:21:36.00
// Función de busqueda
Set GetTolObjects( Text grammar, Text pattern )
{
  // cambio del status tcl
  Real {
  Text script =
  "
  proc ::getTolObjects { grammar pattern } {
    set selection [ list ]
    if { $grammar eq \"Code\" } {
      array set visitedHash {}
      foreach g [ tol::info grammars ] {
        set functionsInG [ tol::info functions $g ]
        if { $g eq \"Code\" } {
          eval lappend functionsInG [ tol::info var Code ]
        }
        foreach f $functionsInG {
          if { [ info exists visitedHash($f) ] } continue
          set visitedHash($f) 1
          if { [ string match $pattern $f  ] } {
            lappend selection \\\"$f\\\"
          }
        }
      }
    } else {
      foreach obj [ tol::info variable $grammar ] {
        if { [ string match $pattern $obj  ] } {
          lappend selection \\\"$obj\\\"
        }
      }
    }
    puts \"selection = $selection\"
    if { [llength $selection] } {
      return \"\\[\\[[ join $selection , ]\\]\\]\"
    } else {
      return \"Copy(Empty)\"
    }
  }
  ";
   Set tclResult = Tcl_Eval( script );
   Real tclResult["status"]
  };
  // evalua a traves de TCL las opciones que se le pasan
  Set tclResult = Tcl_EvalEx( [[ "::getTolObjects", grammar, pattern ]] );
  Set If( tclResult["status"], Eval(tclResult["result"]), {
        Error( "GetTolObjects: " + tclResult["result"] );
        Copy(Empty)
      } )
};

// mis funciones de prueba
Real CodePrueba(Real a){a};
Code CodePrueba2 = CodePrueba;

Set A = GetTolObjects( "Code", "StdLib::M*" );
Set B1 = GetTolObjects( "Code", "CodeP*" );    // no devuelve nada!
Set B2 = GetTolObjects( "Real", "CodeP*" );     // no devuelve nada!

// este ejemplo deberia devolver un montón de Codes, como se ve en
// Gramaticas + Code, o bien con el buscador de funciones
Set C = GetTolObjects( "Code", "ARIMA*" );     // solo devuelve 2 resultados




// Miercoles, 2010/07/28 14:20:00.00
// Función de busqueda
Set GetTolObjects( Text grammar, Text pattern )
{
  // cambio del status tcl
  Real {
  Text script =
  "
  proc ::getTolObjects { grammar pattern } {
    set selection [ list ]
    if { $grammar eq \"Code\" } {
      array set visitedHash {}
      foreach g [ tol::info grammars ] {
        set functionsInG [ tol::info functions $g ]
        if { $g eq \"Code\" } {
          lappend functionsInG [ tol::info var Code ]
        }
        foreach f $functionsInG {
          if { [ info exists visitedHash($f) ] } continue
          set visitedHash($f) 1
          if { [ string match $pattern $f  ] } {
            lappend selection \\\"$f\\\"
          }
        }
      }
    } else {
      foreach obj [ tol::info variable $grammar ] {
        if { [ string match $pattern $obj  ] } {
          lappend selection \\\"$obj\\\"
        }
      }
    }
    puts \"selection = $selection\"
    if { [llength $selection] } {
      return \"\\[\\[[ join $selection , ]\\]\\]\"
    } else {
      return \"Copy(Empty)\"
    }
  }
  ";
   Set tclResult = Tcl_Eval( script );
   Real tclResult["status"]
  };
  // evalua a traves de TCL las opciones que se le pasan
  Set tclResult = Tcl_EvalEx( [[ "::getTolObjects", grammar, pattern ]] );
  Set If( tclResult["status"], Eval(tclResult["result"]), {
        Error( "GetTolObjects: " + tclResult["result"] );
        Copy(Empty)
      } )
};

// mis funciones de prueba
Real CodePrueba(Real a){a};
Code CodePrueba2 = CodePrueba;

Set A = GetTolObjects( "Code", "StdLib::M*" );
Set B1 = GetTolObjects( "Code", "CodeP*" );    // no devuelve nada!
Set B2 = GetTolObjects( "Real", "CodeP*" );     // no devuelve nada!

// este ejemplo deberia devolver un montón de Codes, como se ve en
// Gramaticas + Code, o bien con el buscador de funciones
Set C = GetTolObjects( "Code", "ARIMA*" );     // solo devuelve 2 resultados




// Martes, 2010/07/27 12:03:51.00

Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  set selection [ list ]
  if { $grammar eq \"Code\" } {
    foreach g [ tol::info grammars ] {
      foreach f [ tol::info functions $g ] {
        if { [ string match $pattern $f  ] } {
          lappend selection \\\"$f\\\"
        }
      }
    }
  } else {
    foreach obj [ tol::info variable $grammar ] {
      if { [ string match $pattern $obj  ] } {
        lappend selection \\\"$obj\\\"
      }
    }
  }
  puts \"selection = $selection\"
  if { [llength $selection] } {
    return \"\\[\\[[ join $selection , ]\\]\\]\"
  } else {
    return \"Copy(Empty)\"
  }
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
};

Set GetTolObjects( Text grammar, Text pattern )
{
  Set tclResult = Tcl_EvalEx( [[ "::getTolObjects", grammar, pattern ]] );
  Set If( tclResult["status"], Eval(tclResult["result"]), {
        Error( "GetTolObjects: " + tclResult["result"] );
        Copy(Empty)
      } )
};

Set GetTolObjects( "Code", "StdLib::M*" );
Set GetTolObjects( "Real", "P*" );


// Martes, 2010/07/27 12:03:25.00

Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  set selection [ list ]
  if { $grammar eq \"Code\" } {
    foreach g [ tol::info grammars ] {
      foreach f [ tol::info functions $g ] {
        if { [ string match $pattern $f  ] } {
          lappend selection \\\"$f\\\"
        }
      }
    }
  } else {
    foreach obj [ tol::info variable $grammar ] {
      if { [ string match $pattern $obj  ] } {
        lappend selection \\\"$obj\\\"
      }
    }
  }
  puts \"selection = $selection\"
  if { [llength $selection] } {
    return \"\\[\\[[ join $selection , ]\\]\\]\"
  } else {
    return \"Copy(Empty)\"
  }
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
};

Set GetTolObjects( Text grammar, Text pattern )
{
  Set tclResult = Tcl_EvalEx( [[ "::getTolObjects", grammar, pattern ]] );
  Set If( tclResult["status"], Eval(tclResult["result"]), {
        Error( "GetTolObjects: " + tclResult["result"] );
        Copy(Empty)
      } )
};

Set GetTolObjects( "Code", "StdLib::M*" );
Set GetTolObjects( "Real", "P*o" );


// Martes, 2010/07/27 11:56:58.00
#Require GuiTools;

Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  set selection [ list ]
  if { $grammar eq \"Code\" } {
    foreach g [ tol::info grammars ] {
      foreach f [ tol::info functions $g ] {
        if { [ string match $pattern $f  ] } {
          lappend selection \\\"$f\\\"
        }
      }
    }
  } else {
    foreach obj [ tol::info variable $grammar ] {
      if { [ string match $pattern $obj  ] } {
        lappend selection \\\"$obj\\\"
      }
    }
  }
  puts \"selection = $selection\"
  if { [llength $selection] } {
    return \"\\[\\[[ join $selection , ]\\]\\]\"
  } else {
    return \"Copy(Empty)\"
  }
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
};

Set GetTolObjects( Text grammar, Text pattern )
{
  Set tclResult = Tcl_EvalEx( [[ "::getTolObjects", grammar, pattern ]] );
  Set If( tclResult["status"], Eval(tclResult["result"]), {
        Error( "GetTolObjects: " + tclResult["result"] );
        Copy(Empty)
      } )
};

Set GetTolObjects( "Code", "StdLib::*M" );


// Martes, 2010/07/27 11:56:41.00
#Require GuiTools;

Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  set selection [ list ]
  if { $grammar eq \"Code\" } {
    foreach g [ tol::info grammars ] {
      foreach f [ tol::info functions $g ] {
        if { [ string match $pattern $f  ] } {
          lappend selection \\\"$f\\\"
        }
      }
    }
  } else {
    foreach obj [ tol::info variable $grammar ] {
      if { [ string match $pattern $obj  ] } {
        lappend selection \\\"$obj\\\"
      }
    }
  }
  puts \"selection = $selection\"
  if { [llength $selection] } {
    return \"\\[\\[[ join $selection , ]\\]\\]\"
  } else {
    return \"Copy(Empty)\"
  }
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
};

Set GetTolObjects( Text grammar, Text pattern )
{
  Set tclResult = Tcl_EvalEx( [[ "::getTolObjects", grammar, pattern ]] );
  Set If( tclResult["status"], Eval(tclResult["result"]), {
        Error( "GetTolObjects: " + tclResult["result"] );
        Copy(Empty)
      } )
};

Set GetTolObjects( "Code", "StdLib*M" );


// Martes, 2010/07/27 11:56:27.00
#Require GuiTools;

Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  set selection [ list ]
  if { $grammar eq \"Code\" } {
    foreach g [ tol::info grammars ] {
      foreach f [ tol::info functions $g ] {
        if { [ string match $pattern $f  ] } {
          lappend selection \\\"$f\\\"
        }
      }
    }
  } else {
    foreach obj [ tol::info variable $grammar ] {
      if { [ string match $pattern $obj  ] } {
        lappend selection \\\"$obj\\\"
      }
    }
  }
  puts \"selection = $selection\"
  if { [llength $selection] } {
    return \"\\[\\[[ join $selection , ]\\]\\]\"
  } else {
    return \"Copy(Empty)\"
  }
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
};

Set GetTolObjects( Text grammar, Text pattern )
{
  Set tclResult = Tcl_EvalEx( [[ "::getTolObjects", grammar, pattern ]] );
  Set If( tclResult["status"], Eval(tclResult["result"]), {
        Error( "GetTolObjects: " + tclResult["result"] );
        Copy(Empty)
      } )
};

Set GetTolObjects( "Code", "StdLib*" );


// Martes, 2010/07/27 11:56:18.00
#Require GuiTools;

Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  set selection [ list ]
  if { $grammar eq \"Code\" } {
    foreach g [ tol::info grammars ] {
      foreach f [ tol::info functions $g ] {
        if { [ string match $pattern $f  ] } {
          lappend selection \\\"$f\\\"
        }
      }
    }
  } else {
    foreach obj [ tol::info variable $grammar ] {
      if { [ string match $pattern $obj  ] } {
        lappend selection \\\"$obj\\\"
      }
    }
  }
  puts \"selection = $selection\"
  if { [llength $selection] } {
    return \"\\[\\[[ join $selection , ]\\]\\]\"
  } else {
    return \"Copy(Empty)\"
  }
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
};

Set GetTolObjects( Text grammar, Text pattern )
{
  Set tclResult = Tcl_EvalEx( [[ "::getTolObjects", grammar, pattern ]] );
  Set If( tclResult["status"], Eval(tclResult["result"]), {
        Error( "GetTolObjects: " + tclResult["result"] );
        Copy(Empty)
      } )
};

Set GetTolObjects( "Code", "StdLib*" );


// Martes, 2010/07/27 11:55:56.00
#Require GuiTools;

Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  set selection [ list ]
  if { $grammar eq \"Code\" } {
    foreach g [ tol::info grammars ] {
      foreach f [ tol::info functions $g ] {
        if { [ string match $f $obj  ] } {
          lappend selection \\\"$f\\\"
        }
      }
    }
  } else {
    foreach obj [ tol::info variable $grammar ] {
      if { [ string match $pattern $obj  ] } {
        lappend selection \\\"$obj\\\"
      }
    }
  }
  puts \"selection = $selection\"
  if { [llength $selection] } {
    return \"\\[\\[[ join $selection , ]\\]\\]\"
  } else {
    return \"Copy(Empty)\"
  }
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
};

Set GetTolObjects( Text grammar, Text pattern )
{
  Set tclResult = Tcl_EvalEx( [[ "::getTolObjects", grammar, pattern ]] );
  Set If( tclResult["status"], Eval(tclResult["result"]), {
        Error( "GetTolObjects: " + tclResult["result"] );
        Copy(Empty)
      } )
};

Set GetTolObjects( "Code", "StdLib*" );


// Martes, 2010/07/27 11:54:50.00
#Require GuiTools;

Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  set selection [ list ]
  if { $grammar eq \"Code\" } {
    foreach g [ tol::info grammars ] {
      foreach f [ tol::info functions $g ] {
        lappend selection \\\"$f\\\"
      }
    }
  } else {
    foreach obj [ tol::info variable $grammar ] {
      if { [ string match $pattern $obj  ] } {
        lappend selection \\\"$obj\\\"
      }
    }
  }
  puts \"selection = $selection\"
  if { [llength $selection] } {
    return \"\\[\\[[ join $selection , ]\\]\\]\"
  } else {
    return \"Copy(Empty)\"
  }
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
};

Set GetTolObjects( Text grammar, Text pattern )
{
  Set tclResult = Tcl_EvalEx( [[ "::getTolObjects", grammar, pattern ]] );
  Set If( tclResult["status"], Eval(tclResult["result"]), {
        Error( "GetTolObjects: " + tclResult["result"] );
        Copy(Empty)
      } )
};

Set GetTolObjects( "Code", "StdLib*" );


// Martes, 2010/07/27 11:54:42.00
#Require GuiTools;

Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  set selection [ list ]
  if { $grammar eq \"Code\" } {
    foreach g [ tol::info grammars ] {
      foreach f [ tol::info functions $g ] {
        lappend selection \\\"$f\\\"
      }
    }
  } else {
    foreach obj [ tol::info variable $grammar ] {
      if { [ string match $pattern $obj  ] } {
        lappend selection \\\"$obj\\\"
      }
    }
  }
  puts \"selection = $selection\"
  if { [llength $selection] } {
    return \"\\[\\[[ join $selection , ]\\]\\]\"
  } else {
    return \"Copy(Empty)\"
  }
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
};

Set GetTolObjects( Text grammar, Text pattern )
{
  Set tclResult = Tcl_EvalEx( [[ "::getTolObjects", grammar, pattern ]] );
  Set If( tclResult["status"], Eval(tclResult["result"]), {
        Error( "GetTolObjects: " + tclResult["result"] );
        Copy(Empty)
      } )
};

Set GetTolObjects( "Code", "StdLib*" );


// Martes, 2010/07/27 11:53:19.00
#Require GuiTools;

Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  set selection [ list ]
  if { $grammar eq \"Code\" } {
    foreach g [ tol::info grammars ] {
      eval lappend selection [ tol::info functions $g ]
    }
  } else {
    foreach obj [ tol::info variable $grammar ] {
      if { [ string match $pattern $obj  ] } {
        lappend selection \\\"$obj\\\"
      }
    }
  }
  puts \"selection = $selection\"
  if { [llength $selection] } {
    return \"\\[\\[[ join $selection , ]\\]\\]\"
  } else {
    return \"Copy(Empty)\"
  }
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
};

Set GetTolObjects( Text grammar, Text pattern )
{
  Set tclResult = Tcl_EvalEx( [[ "::getTolObjects", grammar, pattern ]] );
  Set If( tclResult["status"], Eval(tclResult["result"]), {
        Error( "GetTolObjects: " + tclResult["result"] );
        Copy(Empty)
      } )
};

Set GetTolObjects( "Code", "StdLib*" );


// Martes, 2010/07/27 11:52:25.00
#Require GuiTools;

Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  set selection [ list ]
  if { $grammar eq \"Code\" } {
    foreach g [ tol::info grammars ] {
      eval lappend selection [ tol::info functions $g ]
    }
  } else {
    foreach obj [ tol::info variable $grammar ] {
      if { [ string match $pattern $obj  ] } {
        lappend selection \\\"$obj\\\"
      }
    }
  }
  if { [llength $selection] } {
    return \"\\[\\[[ join $selection , ]\\]\\]\"
  } else {
    return \"Copy(Empty)\"
  }
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
};

Set GetTolObjects( Text grammar, Text pattern )
{
  Set tclResult = Tcl_EvalEx( [[ "::getTolObjects", grammar, pattern ]] );
  Set If( tclResult["status"], Eval(tclResult["result"]), {
        Error( "GetTolObjects: " + tclResult["result"] );
        Copy(Empty)
      } )
};

Set GetTolObjects( "Code", "StdLib*" );


// Martes, 2010/07/27 11:48:16.00
#Require GuiTools;

// Martes, 2010/07/27 11:41:35.00
Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  set selection [ list ]
  foreach obj [ tol::info variable $grammar ] {
    if { [ string match $pattern $obj  ] } {
      lappend selection \\\"$obj\\\"
    }
  }
  if { [llength $selection] } {
    return \"\\[\\[[ join $selection , ]\\]\\]\"
  } else {
    return \"Copy(Empty)\"
  }
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
};

Set GetTolObjects( Text grammar, Text pattern )
{
  Set tclResult = Tcl_EvalEx( [[ "::getTolObjects", grammar, pattern ]] );
  Set If( tclResult["status"], Eval(tclResult["result"]), {
        Error( "GetTolObjects: " + tclResult["result"] );
        Copy(Empty)
      } )
};

Set GetTolObjects( "Code", "StdLib*M*" );


// Martes, 2010/07/27 11:41:04.00
Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  set selection [ list ]
  foreach obj [ tol::info variable $grammar ] {
    if { [ string match $pattern $obj  ] } {
      lappend selection \\\"$obj\\\"
    }
  }
  if { [llength $selection] } {
    return \"\\[\\[[ join $selection , ]\\]\\]\"
  } else {
    return \"Copy(Empty)\"
  }
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
};

Set GetTolObjects( Text grammar, Text pattern )
{
  Set tclResult = Tcl_EvalEx( [[ "::getTolObjects", grammar, pattern ]] );
  Set If( tclResult["status"], Eval(tclResult["result"]), {
        Error( "GetTolObjects: " + tclResult["result"] );
        Copy(Empty)
      } )
};

Set GetTolObjects( "Code", "M*" );


// Martes, 2010/07/27 11:40:19.00
Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  set selection [ list ]
  foreach obj [ tol::info variable $grammar ] {
    if { [ string match $pattern $obj  ] } {
      lappend selection \\\"$obj\\\"
    }
  }
  if { [llength $selection] } {
    return \"\\[\\[[ join $selection , ]\\]\\]\"
  } else {
    return \"Copy(Empty)\"
  }
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
};

Set GetTolObjects( Text grammar, Text pattern )
{
  Set tclResult = Tcl_EvalEx( [[ "::getTolObjects", grammar, pattern ]] );
  Set If( tclResult["status"], Eval(tclResult["result"]), {
        Error( "GetTolObjects: " + tclResult["result"] );
        Copy(Empty)
      } )
};



// Martes, 2010/07/27 11:35:56.00
Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  set selection [ list ]
  foreach obj [ tol::info variable $grammar ] {
    if { [ string match $pattern $obj  ] } {
      lappend selection \\\"$obj\\\"
    }
  }
  if { [llength $selection] } {
    return \"\\[\\[[ join $selection , ]\\]\\]\"
  } else {
    return \"Copy(Empty)\"
  }
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
}



// Martes, 2010/07/27 11:35:20.00
Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  set selection [ list ]
  puts \"todas : [ tol::info variable $grammar ]\"
  foreach obj [ tol::info variable $grammar ] {
    if { [ string match $obj $pattern ] } {
      lappend selection \\\"$obj\\\"
    }
  }
  if { [llength $selection] } {
    return \"\\[\\[[ join $selection , ]\\]\\]\"
  } else {
    return \"Copy(Empty)\"
  }
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
}



// Martes, 2010/07/27 11:34:21.00
Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  set selection [ list ]
  foreach obj [ tol::info variable $grammar ] {
    if { [ string match $obj $pattern ] } {
      lappend selection \\\"$obj\\\"
    }
  }
  if { [llength $selection] } {
    return \"\\[\\[[ join $selection , ]\\]\\]\"
  } else {
    return \"Copy(Empty)\"
  }
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
}



// Martes, 2010/07/27 11:33:48.00
Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  foreach obj [ tol::info variable $grammar ] {
    if { [ string match $obj $pattern ] } {
      lappend selection \\\"$obj\\\"
    }
  }
  if { [llength $selection] } {
    return \"\\[\\[[ join $selection , ]\\]\\]\"
  } else {
    return \"Copy(Empty)\"
  }
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
}



// Martes, 2010/07/27 11:32:08.00
Real {
Text script =
"
proc ::getTolObjects { grammar pattern } {
  foreach obj [ tol::info variable $grammar ] {
    if { [ string match $obj $pattern ] } {
      lappend selection \\\"$obj\\\"
    }
  }
  return \"\\[\\[[ join $selection , ]\\]\\]\"
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
}



// Martes, 2010/07/27 11:29:19.00
Text script =
"
proc ::getTolObjects { grammar pattern } {
  foreach obj [ tol::info variable $grammar ] {
    if { [ string match $obj $pattern ] } {
      lappend selection \\\"$obj\\\"
    }
  }
  return \"{[[}[ join $selection , ]{[[}\"
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]


// Martes, 2010/07/27 11:28:04.00
Real {
Text script =
"
proc getTolObjects { grammar pattern } {
  foreach obj [ tol::info variable $grammar ] {
    if { [ string match $obj $pattern ] } {
      lappend selection \\\"$obj\\\"
    }
  }
  return \"{[[}[ join $selection , ]{[[}\"
}
";
 Set tclResult = Tcl_Eval( script );
 Real tclResult["status"]
}



// Martes, 2010/07/27 00:20:38.00
#Require GuiTools.2.3;


// Martes, 2010/07/27 00:17:48.00
#Require GuiTools.2.1


// Martes, 2010/07/27 00:17:04.00
#Require GuiTools.2.3


// Lunes, 2010/07/26 20:56:17.00
#Require GuiTools.2.1;


// Lunes, 2010/07/26 20:56:04.00
#Require GuiTools.2.2;


// Lunes, 2010/07/26 20:46:42.00
#Require GuiTools.2.3;


// Lunes, 2010/07/26 20:46:02.00
#Require GuiTools;


// Lunes, 2010/07/26 20:36:45.00
#Require GuiTools.2.3;


// Lunes, 2010/07/26 20:35:53.00
#Require GuiTools.2.3;


// Lunes, 2010/07/26 20:18:31.00
#Require GuiTools.2.3;


// Lunes, 2010/07/26 20:17:20.00
#Require GuiTools;


// Lunes, 2010/07/26 19:27:03.00
#Require GuiTools.2.3


// Lunes, 2010/07/26 19:26:27.00
#Require GuiTools;


// Lunes, 2010/07/26 18:36:41.00
#Require GuiTools;


// Lunes, 2010/07/26 16:02:43.00
Real TolPackage::Client::DoStartAction("GuiTools", GuiTools::_.cwd)


// Viernes, 2010/07/23 22:39:49.00
Text GuiTools::ImageManager::getImageResourceId( "checkedBox" );


// Viernes, 2010/07/23 22:39:32.00
Text GuiTools::ImageManager::getImageResourceId( "Serie" );


// Viernes, 2010/07/23 22:38:22.00
Text GuiTools::ImageManager::getIconForInstance( instSerie );


// Viernes, 2010/07/23 22:38:01.00
Anything GuiTools::ImageManager::getIconForClass( ClassOf(instSerie) );


// Viernes, 2010/07/23 22:37:52.00
Anything GuiTools::ImageManager::getIconForClass( ClassOf(instSerie) );


// Viernes, 2010/07/23 22:37:35.00
Anything GuiTools::ImageManager::getIconForClass( ClassOf(inst1) );


// Viernes, 2010/07/23 22:36:42.00
Text GuiTools::ImageManager::getIconForInstance( inst1 );


// Viernes, 2010/07/23 22:36:26.00
Text ImageManager::getIconForInstance( inst1 );


// Jueves, 2010/07/22 15:09:41.00
Set cont = [[ 1, 2, 4, 5, 6, 7, 9 ]];

Real GetObj1( Real i ) 
{
  Real cont[ i ]
};

Real GetObj2( Real i ) 
{
  Real a = cont[ i ];
  Real a
};


Text GetAddr1( Real i ) 
{
  GetAddressFromObject( cont [ i ] )
};

Text GetAddr2( Real i ) 
{
  GetAddressFromObject( GetObj1( i ) )
};

Text GetAddr3( Real i ) 
{
  GetAddressFromObject( GetObj2( i ) )
};

Text GetAddressFromObject( cont[ 1 ] );
Text GetAddr1( 1 );
Text GetAddr2( 1 );
Text GetAddr3( 1 );


// Jueves, 2010/07/22 15:09:22.00
Set cont = [[ 1, 2, 4, 5, 6, 7, 9 ]];

Real GetObj1( Real i ) 
{
  Real cont[ i ]
};

Real GetObj2( Real i ) 
{
  Real a = cont[ i ]
  Real a
};


Text GetAddr1( Real i ) 
{
  GetAddressFromObject( cont [ i ] )
};

Text GetAddr2( Real i ) 
{
  GetAddressFromObject( GetObj1( i ) )
};

Text GetAddr3( Real i ) 
{
  GetAddressFromObject( GetObj2( i ) )
};

Text GetAddressFromObject( cont[ 1 ] );
Text GetAddr1( 1 );
Text GetAddr2( 1 );
Text GetAddr3( 1 );


// Jueves, 2010/07/22 15:08:03.00
Set cont = [[ 1, 2, 4, 5, 6, 7, 9 ]];

Real GetObj( Real i ) 
{
  Real cont[ i ]
};

Text GetAddr1( Real i ) 
{
  GetAddressFromObject( cont [ i ] )
};

Text GetAddr2( Real i ) 
{
  GetAddressFromObject( GetObj( i ) )
};

Text GetAddressFromObject( cont[ 1 ] );
Text GetAddr1( 1 );
Text GetAddr2( 1 );


// Jueves, 2010/07/22 15:07:46.00
Set cont = [[ 1, 2, 4, 5, 6, 7, 9 ]];

Real GetObj( i ) 
{
  Real cont[ i ]
};

Text GetAddr1( Real i ) 
{
  GetAddressFromObject( cont [ i ] )
};

Text GetAddr2( Real i ) 
{
  GetAddressFromObject( GetObj( i ) )
};

Text GetAddressFromObject( cont[ 1 ] );
Text GetAddr1( 1 );
Text GetAddr2( 1 );


// Jueves, 2010/07/22 11:35:30.00
#Require GuiTools;


// Jueves, 2010/07/22 11:17:28.00
Real TolPackage::Client::@Repository::DownloadPackageFromUrl( "file:///home/jsperez/.tol/TolPackage/Server/GuiToolsRepository/Linux-x86_32/", "GuiTools.2.2");


// Jueves, 2010/07/22 11:16:41.00
Real TolPackage::Client::@Repository::DownloadPackageFromUrl( "file:///home/jsperez/.tol/TolPackage/Server/GuiToolsRepository/Linux-x86_32/", "GuiTools.2.2");


// Jueves, 2010/07/22 11:16:28.00
Real TolPackage::Client:@Repository::DownloadPackageFromUrl( "file:///home/jsperez/.tol/TolPackage/Server/GuiToolsRepository/Linux-x86_32/", "GuiTools.2.2");


// Jueves, 2010/07/22 11:16:16.00
Real TolPackage::Client:@Repository::DownloadPackageFromUrl( "file:///home/jsperez/.tol/TolPackage/Server/GuiToolsRepository/Linux-x86_32/", "GuiTools.2.2");


// Jueves, 2010/07/22 11:13:18.00
Real TolPackage::Client::InstallFromUrl( "file:///home/jsperez/.tol/TolPackage/Server/GuiToolsRepository/Linux-x86_32/GuiTools.2.2.zip");



// Jueves, 2010/07/22 11:09:54.00
#Require GuiTools.2.2;



// Jueves, 2010/07/22 11:05:48.00
Real TolPackage::Client::@Repository::DownloadPackageFromUrl( "file:///home/jsperez/.tol/TolPackage/Server/GuiToolsRepository/Linux-x86_32/", "GuiTools.2.2");


// Jueves, 2010/07/22 11:05:05.00
Real TolPackage::Client::@Repository::DownloadPackageFromUrl( "file:///home/jsperez/.tol/TolPackage/Server/GuiToolsRepository/Linux-x86_32/", "GuiTools.2.2");


// Jueves, 2010/07/22 11:04:50.00
Real TolPackage::@Repository::DownloadPackageFromUrl( "file:///home/jsperez/.tol/TolPackage/Server/GuiToolsRepository/Linux-x86_32/", "GuiTools.2.2");


// Jueves, 2010/07/22 11:04:17.00
Real TolPackage::@Repository::InstallFromUrl( "file:///home/jsperez/.tol/TolPackage/Server/GuiToolsRepository/Linux-x86_32/", "GuiTools.2.2");


// Jueves, 2010/07/22 10:52:08.00
Real TolPackage::Client::InstallFromUrl( "file:///home/jsperez/.tol/TolPackage/Server/GuiToolsRepository/Linux-x86_32/GuiTools.2.2.zip");


// Miercoles, 2010/07/21 13:19:09.00
GuiTools


// Miercoles, 2010/07/21 11:33:16.00
Text GuiTools::ImageManager::getImageResourceId( "mms_dataset" );


// Miercoles, 2010/07/21 11:31:51.00
Text GuiTools::ImageManager::getImageResourceId( "mms_dataset" );


// Miercoles, 2010/07/21 11:31:40.00
Text GuiTools::getImageResourceId( "mms_dataset" );


// Miercoles, 2010/07/21 11:29:18.00
Real ImageResources::_.init(0);


// Miercoles, 2010/07/21 11:28:53.00
Real ImageResources::_.init(0);


// Miercoles, 2010/07/21 11:24:53.00
Real ImageResources::_.init(0);


// Miercoles, 2010/07/21 09:24:03.00
Real GuiTools::InsideTk(?);


// Lunes, 2010/07/19 13:56:34.00


Set PtswClient::MDimStore


// Lunes, 2010/07/19 13:56:12.00
Real PtswClient::StartActions(PtswClient::_.flagDevel)


// Miercoles, 2010/07/14 13:56:59.00
#Require MMS;


// Miercoles, 2010/07/14 13:48:22.00
#Require MMS; 


// Miercoles, 2010/07/14 13:48:09.00
Real TolPackage::Client::InstallFromUrl("http://packages.localbayes.es/mms/MMS.zip"); 


// Miercoles, 2010/07/14 12:52:40.00
#Require MMS;


// Viernes, 2010/07/09 09:10:09.00
#Require MMS


// Miercoles, 2010/07/07 19:09:58.00
#Require PtswClient;


// Miercoles, 2010/07/07 17:47:08.00
#Require PtswClient;


// Miercoles, 2010/07/07 14:18:59.00
Real PtswClient::StartActions(PtswClient::_.flagDevel);

// Miercoles, 2010/07/07 14:16:10.00
Real PtswClient::StartActions(PtswClient::_.flagDevel);

// Miercoles, 2010/07/07 14:12:55.00
Real PtswClient::StartActions(PtswClient::_.flagDevel);

// Miercoles, 2010/07/07 14:08:23.00
Real PtswClient::StartActions(PtswClient::_.flagDevel);


// Miercoles, 2010/07/07 14:02:36.00
Real PtswClient::StartActions(PtswClient::_.flagDevel);


// Miercoles, 2010/07/07 13:59:05.00
Real PtswClient::StartActions(PtswClient::_.flagDevel);


// Miercoles, 2010/07/07 12:44:42.00
Real PtswClient::StartActions(PtswClient::_.flagDevel);


// Miercoles, 2010/07/07 12:41:05.00
Real PtswClient::StartActions(PtswClient::_.flagDevel);


// Miercoles, 2010/07/07 12:38:57.00
Real PtswClient::StartActions(PtswClient::_.flagDevel);


// Miercoles, 2010/07/07 12:38:48.00
Real PtswClient::StartActions(PtswClient::_.flagDevel


// Miercoles, 2010/07/07 12:16:07.00
NameBlock PtswClient::DBConnection::Ptsw

// Miercoles, 2010/07/07 12:15:58.00
Real PtswClient::StartActions(PtswClient::_.flagDevel);
PtswClient::DBConnection::Ptsw


// Miercoles, 2010/07/07 12:15:34.00
PtswClient::DBConnection::Ptsw


// Miercoles, 2010/07/07 12:07:55.00
Real PtswClient::StartActions(PtswClient::_.flagDevel);


// Miercoles, 2010/07/07 12:02:29.00
Real PtswClient::StartActions(PtswClient::_.flagDevel);


// Miercoles, 2010/07/07 10:21:50.00
Real PtswClient::StartActions(PtswClient::_.flagDevel);


// Martes, 2010/07/06 17:09:56.00
#Require MMS;


// Martes, 2010/07/06 17:08:16.00
#Require MMS;


// Martes, 2010/07/06 12:17:44.00
NameBlock AA = [[
  Real F(Real a ) { _.F(a) };
  Real _.F( Real a ) { a + 1 };
  Text _.autodoc.kk = "..."
]];

Real UsingNameBlock( AA );

Real AA::F(1);
Real AA::_.F(1);
Real F(1);
Real _.F(1);
Text _.autodoc.kk;


// Martes, 2010/07/06 12:17:32.00
NameBlock AA = [[
  Real F(Real a ) { _.F(a) };
  Real _.F( Real a ) { a + 1 };
  Text _.autodoc.kk = "..."
]];

Real UsingNameBlock( AA );

Real AA::F(1);
Real AA::_.F(1);
Real F(1);
Real _.F(1);
Text _.autodoc.kk;


// Martes, 2010/07/06 12:15:07.00
NameBlock AA = [[
  Real F(Real a ) { _.F(a) };
  Real _.F( Real a ) { a + 1 };
  Text _.autodoc.kk = "...";
]];

Real UsingNameBlock( AA );

Real AA::F(1);
Real AA::_.F(1);
Real F(1);
Real _.F(1);
Text _.autodoc.kk;


// Martes, 2010/07/06 12:14:55.00
_.autodoc.kk

// Martes, 2010/07/06 09:44:59.00
Real AA::F(1);
Real AA::_.F(1);
Real F(1);
Real _.F(1);

// Martes, 2010/07/06 09:43:54.00
NameBlock AA = [[
  Real F(Real a ) { _.F(a) };
  Real _.F( Real a ) { a + 1 }
]];

Real UsingNameBlock( AA );


// Martes, 2010/07/06 09:32:51.00
NameBlock N0A = [[
   Real F1(Real void) { 1 };
   NameBlock N2 = [[
     Real F2(Real void) { F1(?) }
   ]]
 ]];

 // F2 no es capaz de localizar a F1
 Real N0A::N2::F2(?);


// Lunes, 2010/07/05 20:02:48.00
#Require MMS;


// Lunes, 2010/07/05 19:12:31.00
Code FindIndexByInfo


// Lunes, 2010/07/05 19:11:06.00
#Require MMS;


// Lunes, 2010/07/05 19:09:29.00
#Require MMS;


// Lunes, 2010/07/05 18:59:28.00
#Require MMS;


// Lunes, 2010/07/05 15:18:40.00
#Require MMS;


// Sabado, 2010/07/03 23:36:21.00
#Require GuiTools;


// Sabado, 2010/07/03 23:14:45.00
#Require BysMcmc;


// Sabado, 2010/07/03 17:36:47.00
#Require BysMcmc;



// Sabado, 2010/07/03 17:36:36.00
NameBlock BysMcmc;



// Sabado, 2010/07/03 16:27:02.00
NameBlock GuiTools;



// Sabado, 2010/07/03 16:11:53.00
#Require GuiTools;



// Sabado, 2010/07/03 14:31:26.00
#Require GuiTools;



// Sabado, 2010/07/03 14:31:14.00
#Require BysMcmc;


// Sabado, 2010/07/03 13:16:08.00
#Require GuiTools;


// Sabado, 2010/07/03 09:53:50.00
#Require GuiTools;


// Viernes, 2010/07/02 15:21:20.00
#Require GuiTools;


// Viernes, 2010/07/02 15:14:47.00
#Require GuiTools;


// Miercoles, 2010/06/23 09:44:58.00
#Require GuiTools;

Real UsingNameBlock( GuiTools );

If( !(ImageManager::initTclCreators(0)), Stop );

// Defino una imagen a partir de los datos codificados en formato ascii.
// Daremos un utilitario que genere esos datos a partir de un archivo imagen.
// Esta forma se suele usar cuando queremos incluir los datos de la imagen en 
// el codigo tol y no cargar con el archivo imagen.
Real ImageManager::defineImageFromData
( "checkedBox",
  "R0lGODdhCwALAJEAAH9/f////wAAAP///ywAAAAACwALAAACLISPRvEPAE8oAMUXCYAgJSEiAYRIQkSCAgTJjgiAoEgSEQGEJIRiA9wdwUcrADs=" );

// Defino la imagen a partir de un archivo. Si el archivo se especifica
// mediante el nombre sin directorio se asume relativo al directorio que
// contiene todas las imagenes de la plataforma GUI de fondo. En el caso de
// tolbase este directorio es lib/toltk/images
Real ImageManager::defineImageFromFile
( "Serie1", "Serie.gif" );

// Si la imagen se da mediante un nombre de archivo sin extension se asume
// que se hace referencia a un archivo contenido en el directorio de imagenes
// de la plataforma GUI de fondo. La plataforma GUI debe saber resolver ese
// nombre de imagen. En el caso de tolbase esa resolucion se hace a traves del
// procedimiento de BWidget Bitmap::get
Real ImageManager::defineImageFromFile
( "Serie2", "Serie" );

Text ImageManager::getImageResourceId( "checkedBox" );
Text ImageManager::getImageResourceId( "Serie1" );
Text ImageManager::getImageResourceId( "Serie2" );

NameBlock MyContextMenuFunctions =
[[
  Real Chart( NameBlock instance, Set extraData )
  {
    ChartGroup( [[instance]], extraData )
  };
  
  Real ChartGroup( Set instances, Set extraData )
  {
    Set all_series = EvalSet(instances, Serie(NameBlock object){
      object::GetData(?)
    });
    Text TclChartSerie(all_series, SetOfSet(
      @TclArgSt("-title", Tcl_Eval("mc \"Serie chart\"")[1])
     ));
    Real 0
  };

  Real writeMsgGroup1( Set instances, Set extraData )
  {
    WriteLn( "writeMsgGroup1 : la seleccion tiene " << Card(instances) << " elementos" );
    0
  };

  Real writeMsgGroup2( Set instances, Set extraData )
  {
    WriteLn( "writeMsgGroup2 : la seleccion tiene " << Card(instances) << " elementos" );
    0
  };

  Real checkOnlyEven( Set instances, Set extraData )
  {
    Real result = Not( Card( instances ) % 2 );
    WriteLn( "result = " << result );
    result
  }
]];

Class @Ejemplo1
{
  Serie _.data;
  Serie GetData(Real void) {
    _.data
  }
};

Class @Ejemplo2
{
  Serie _.data;
  Serie GetData(Real void) {
    _.data
  }
};

// Etiqueta a mostrar en el submenu asociado a la seleccion multiple
// de instancia de las clase @Ejemplo1 y @Ejemplo2, solo se crea el
// submenu en el caso de que en la seleccion aparezcan mas de 1 tipo
// de dato con opciones de menu definidas.
Real MenuManager::defineTypeLabel( "@Ejemplo1", [[ Text label = "Ejemplo1" ]] );
Real MenuManager::defineTypeLabel( "@Ejemplo2", [[ Text label = "Ejemplo2" ]] );

// Chart_Serie es una opcion que se aplica sobre una unica instancia
Real MenuManager::defineMenuCommand
( "@Ejemplo1",
  [[ Text name = "Chart_Serie",
     Text label = "(INDIV) Grafica",
     Text image = "Serie1",
     Real flagGroup = 0,
     Code CmdInvoke = MyContextMenuFunctions::Chart ]]
);

// @Ejemplo2 comparte la opcion Chart_Serie con @Ejemplo1
Real MenuManager::defineMenuCommand
( "@Ejemplo2",
  [[ Text name = "Chart_Serie" ]]
);

// SubMenu/ChartGroup_Serie esta habilitada solo si la seleccion tiene
// un numero par de elementos
Real MenuManager::defineMenuCommand
( "@Ejemplo1",
  [[ Text name = "SubMenu/ChartGroup_Serie",
     Text label = "(MULTI) Grafica Grupo",
     Text image = "Serie2",
     Real flagGroup = 1,
     Code CmdInvoke = MyContextMenuFunctions::ChartGroup,
     Code CmdCheckState = MyContextMenuFunctions::checkOnlyEven ]]
);

// @Ejemplo2 comparte la opcion SubMenu/ChartGroup_Serie con @Ejemplo1
Real MenuManager::defineMenuCommand
( "@Ejemplo2",
  [[ Text name = "SubMenu/ChartGroup_Serie" ]]
);

Real MenuManager::defineMenuCommand
( "@Ejemplo1",
  [[ Text name = "WriteMsgGroup1",
     Text label = "(MULTI) Write Msg 1",
     Text image = "checkedBox",
     Real flagGroup = 1,
     Code CmdInvoke = MyContextMenuFunctions::writeMsgGroup1 ]]
);

Real MenuManager::defineMenuCommand
( "@Ejemplo2",
  [[ Text name = "WriteMsgGroup2",
     Text label = "(MULTI) Write Msg 2",
     Text image = "checkedBox",
     Real flagGroup = 1,
     Code CmdInvoke = MyContextMenuFunctions::writeMsgGroup2 ]]
);

@Ejemplo1 ej11 = [[ Serie _.data = Gaussian(0,1,C) ]];
@Ejemplo1 ej12 = [[ Serie _.data = Gaussian(0,1,C) ]];
@Ejemplo1 ej13 = [[ Serie _.data = Gaussian(0,1,C) ]];
@Ejemplo2 ej21 = [[ Serie _.data = Gaussian(0,1,C) ]];
@Ejemplo2 ej22 = [[ Serie _.data = Gaussian(0,1,C) ]];




// Martes, 2010/06/22 16:41:29.00

Real Get( Text url, Text pathDest, Set args )
{
  // no usamos args por ahora
  Set cmd = [[ "::TolCurl::Get", url, pathDest ]];
  Set View( cmd, "Std" );
  Set result = Tcl_EvalEx( cmd );
  Real If( result::status, result::status, {
      Set resultError =
        Tcl_EvalEx( [[ "::curl::easystrerror", result::result ]] );
      Error( "Curl::Get: " + result::result );
      Real 0
    } )
};

Real Get("ftp://www.gidhome.com/pub/Tools/gidpost1.70.zip", "/tmp/kk_gp.zip", Empty);


// Martes, 2010/06/22 16:40:32.00

Real Get( Text url, Text pathDest, Set args )
{
  // no usamos args por ahora
  Set cmd = [[ "::TolCurl::Get", url, pathDest ]];
  Set View( cmd, "Std" );
  Set result = Tcl_EvalEx( cmd );
  Real If( result::status, result::status, {
      Set resultError =
        Tcl_EvalEx( [[ "::curl::easystrerror", result::result ]] );
      Error( "Curl::Get: " + result::result );
      Real 0
    } )
};

Real Get("ftp://www.gidhome.com/pub/Tools/gidpost1.70.zip", "/tmp/kk_gp.zip", Empty);


// Martes, 2010/06/22 16:39:43.00
/*
Real Get( Text url, Text pathDest, Set args )
{
  // no usamos args por ahora
  Set cmd = [[ "::TolCurl::Get", url, pathDest ]];
  Set result = Tcl_EvalEx( cmd );
  Real If( result::status, result::status, {
      Set resultError =
        TclEvalEx( [[ "::curl::easystrerror", result::result ]] );
      Error( "Curl::Get: " + result::result );
      Real 0
    } )
};
*/

Real Get("ftp://www.gidhome.com/pub/Tools/gidpost1.70.zip", "/tmp/kk_gp.zip", Empty);


// Martes, 2010/06/22 16:39:26.00
/*
Real Get( Text url, Text pathDest, Set args )
{
  // no usamos args por ahora
  Set cmd = [[ "::TolCurl::Get", url, pathDest ]];
  Set result = Tcl_EvalEx( cmd );
  Real If( result::status, result::status, {
      Set resultError =
        TclEvalEx( [[ "::curl::easystrerror", result::result ]] );
      Error( "Curl::Get: " + result::result );
      Real 0
    } )
};
*/

Real Get("ftp://www.gidhome.com/pub/Tools/gidpost1.70.zip", "/tmp/kk_gp.zip");


// Martes, 2010/06/22 16:38:04.00
Real Get( Text url, Text pathDest, Set args )
{
  // no usamos args por ahora
  Set cmd = [[ "::TolCurl::Get", url, pathDest ]];
  Set result = Tcl_EvalEx( cmd );
  Real If( result::status, result::status, {
      Set resultError =
        TclEvalEx( [[ "::curl::easystrerror", result::result ]] );
      Error( "Curl::Get: " + result::result );
      Real 0
    } )
};


// Martes, 2010/06/22 16:35:02.00
Set result = Tcl_EvalEx( [[ "set", "kk" ]] );
Real result::status;
Text result::result;


// Martes, 2010/06/22 14:28:07.00
Text TolPackage::Client::_.localRoot


// Martes, 2010/06/22 14:27:11.00
NameBlock GuiTools;


// Martes, 2010/06/22 14:27:01.00
#Require GuiTools;


// Lunes, 2010/06/21 17:59:51.00
Class @Ejemplo {
  Real a
};
@Ejemplo ej = [[ Real a = 1 ]];


// Lunes, 2010/06/21 14:47:03.00
MMS



// Miercoles, 2010/06/09 22:32:18.00
Text ImageManager::getImageResourceId("Serie1");


// Miercoles, 2010/06/09 22:32:07.00
Text ImageManager::getImageResourceId("Serie");


// Miercoles, 2010/06/09 22:31:01.00
ImageManager::initTclCreators(0)

// Miercoles, 2010/06/09 22:02:06.00
Real GuiTools::ImageManager::initTclCreators(0);


// Miercoles, 2010/06/09 21:45:50.00
Real GuiTools::ImageManager::initTclCreators(0);


// Miercoles, 2010/06/09 21:43:53.00
Real GuiTools::ImageManager::initTclCreators(0);


// Miercoles, 2010/06/09 21:42:25.00
Real GuiTools::ImageManager::initTclCreators(0);


// Miercoles, 2010/06/09 21:40:40.00
Real GuiTools::ImageManager::initTclCreators(0);


// Miercoles, 2010/06/09 21:39:40.00
Real GuiTools::ImageManager::initTclCreators(0);


// Miercoles, 2010/06/09 21:38:45.00
Real ImageManager::initTclCreators(0);


// Miercoles, 2010/06/09 21:26:28.00
    Text script =
      "
namespace eval ImageManager {
  proc createImageFromData { imageName imageData } {
    image create photo $imageData
  }

  proc createImageFromFile { imageName imagePath } {
    set img [ image create photo ]
    set items [ file split $imagePath ]
    if { [ llength $items ] == 1 } {
      set img [ ::Bitmap::get [ file rootname $imagePath ] ]
    } else {
      $img read $imagePath
    }
    return $img
  }

}
      ";
    Set result = Tcl_Eval( script );



// Lunes, 2010/06/07 15:41:11.00
GuiTools


// Lunes, 2010/06/07 15:20:27.00
Real ObjectExist( "NameBlock", "GuiTools" );


// Lunes, 2010/06/07 15:19:46.00
Real ObjectExist( "NameBlock", "GuiTools::MenuManager" );


// Lunes, 2010/06/07 15:19:41.00
Real ObjectExists( "NameBlock", "GuiTools::MenuManager" );


// Lunes, 2010/06/07 00:29:53.00
Set ContextMenuManager::getDefaultEntryInfo( "KK" );


// Lunes, 2010/06/07 00:28:47.00
Set ContextMenuManager::getDefaultEntryInfo( "KK" );


// Domingo, 2010/06/06 02:25:22.00
Real ContextMenuManager::checkStateEntry( "ChartGroup_Serie", [[1,2,3]] )


// Domingo, 2010/06/06 02:25:00.00
Real ContextMenuManager::checkStateEntry( "ChartGroup_Serie", [[1,2,3]] )


// Domingo, 2010/06/06 02:24:45.00
Real ContextMenuManager::checkStateEntry( "ChartGroup_Serie", [[1,2,3]] )


// Domingo, 2010/06/06 01:55:38.00
Real ContextMenuManager::checkStateEntry( "ChartGroup_Serie", [[1,2,3]] );


// Domingo, 2010/06/06 01:54:23.00
Real ContextMenuManager::checkStateEntry( "ChartGroup_Serie", [[1,2]] );


// Viernes, 2010/06/04 09:21:15.00
Set ContextMenuManager::_.options::Chart_Serie::getEntryInfo(0)


// Viernes, 2010/06/04 09:19:39.00
Set ContextMenuManager::_.options::Chart_Serie::getEntryInfo(0)


// Viernes, 2010/06/04 09:18:58.00
Set ContextMenuManager::_.options::Chart_Serie::getEntryInfo(0)


// Viernes, 2010/06/04 09:18:02.00
Set ContextMenuManager::getEntryInfo( "Chart_Serie" )


// Viernes, 2010/06/04 09:17:08.00
Set ContextMenuManager::getEntryInfo( "@Example1" )


// Viernes, 2010/06/04 08:56:45.00
Set ContextMenuManager::getTypeOptionsInfo( "@Ejemplo1" );


// Viernes, 2010/06/04 08:55:38.00
Set ContextMenuManager::getTypeOptionsInfo( "@Ejemplo1" );


// Viernes, 2010/06/04 08:55:28.00
Set ContextMenuManager::getTypeOptionsInfo( "kk" );


// Viernes, 2010/06/04 07:37:36.00

NameBlock MyContextMenuFunctions =
[[
  Real Chart( NameBlock instance, Set extraData )
  {
    ChartGroup( [[instance]] )
  };
  
  Real ChartGroup( Set instances, Set extraData )
  {
    Set all_series = EvalSet(instances, Serie(NameBlock object){
      object::GetData(?)
    });
    Text TclChartSerie(all_series, SetOfSet(
      @TclArgSt("-title", Tcl_Eval("mc \"Serie chart\"")[1])
     ));
    Real 0
  };

  Real checkOnlyEven( Set instances, Set extraData )
  {
    Not( Card( instances ) % 2 )
  }
]];

Class @Ejemplo1
{
  Serie _.data;
  Serie GetData(Real void) {
    _.data
  }
};

Real ContextMenuManager::defineTypeLabel( "@Ejemplo1", "Ejemplo1", 0 );

Real ContextMenuManager::defineMenuCommand
( "@Ejemplo1",
  [[ Text name = "Chart_Serie",
     Text label = "(INDIV) Grafica",
     Real flagGroup = 0,
     Code CmdInvoke = MyContextMenuFunctions::Chart ]]
);

Real ContextMenuManager::defineMenuCommand
( "@Ejemplo1",
  [[ Text name = "ChartGroup_Serie",
     Text label = "(MULTI) Grafica Grupo",
     Real flagGroup = 1,
     Code CmdInvoke = MyContextMenuFunctions::ChartGroup,
     Code CmdCheck = MyContextMenuFunctions::checkOnlyEven ]]
);



// Viernes, 2010/06/04 07:37:16.00
Code CmdInvoke = MyContextMenuFunctions::Chart

// Viernes, 2010/06/04 07:36:27.00
Code CmdInvoke = MyContexMenuFunctions::Chart

// Viernes, 2010/06/04 07:36:21.00
NameBlock MyContextMenuFunctions =
[[
  Real Chart( NameBlock instance, Set extraData )
  {
    ChartGroup( [[instance]] )
  };
  
  Real ChartGroup( Set instances, Set extraData )
  {
    Set all_series = EvalSet(instances, Serie(NameBlock object){
      object::GetData(?)
    });
    Text TclChartSerie(all_series, SetOfSet(
      @TclArgSt("-title", Tcl_Eval("mc \"Serie chart\"")[1])
     ));
    Real 0
  };

  Real checkOnlyEven( Set instances, Set extraData )
  {
    Not( Card( instances ) % 2 )
  }
]];

Class @Ejemplo1
{
  Serie _.data;
  Serie GetData(Real void) {
    _.data
  }
};


// Viernes, 2010/06/04 07:33:00.00
Real ContextMenuManager::defineMenuCommand
( "@Ejemplo1",
  [[ Text name = "Chart_Serie",
     Text label = "(INDIV) Grafica",
     Real flagGroup = 0,
     Code CmdInvoke = MyContexMenuFunctions::Chart ]]
);

Real ContextMenuManager::defineMenuCommand
( "@Ejemplo1",
  [[ Text name = "ChartGroup_Serie",
     Text label = "(MULTI) Grafica Grupo",
     Real flagGroup = 1,
     Code CmdInvoke = MyContexMenuFunctions::ChartGroup,
     Code CmdCheck = MyContexMenuFunctions::checkOnlyEven ]]
);

// Jueves, 2010/06/03 12:32:32.00
Set SS =
{
[[
   Code CmdInvoke = ptrB::F
]]
};

Real FindIndexByName( SS, "CmdInvoke" );
Real FindIndexByName( SS, "CmdCheckState" );

// Jueves, 2010/06/03 12:27:47.00
Class @A {
  Real a;

  Real F( Real void )
  {
    WriteLn( "F de A" );
    0
  }
};

@A anA = [[ Real a = 1 ]];

Class @B : @A {
  Real F( Real void )
  {
    WriteLn( "F de B" );
    0
  };
  Real G( Real void )
  {
    WriteLn( "G solo en B" );
    0
  }
};

@B anB = [[ Real a = 2 ]];

@A ptrA = anA;
@A ptrB = anB;

Real ptrB::F(?);
Real ptrB::G(?);


// Jueves, 2010/06/03 12:05:53.00
Class @A {
  Real a;

  Real F( Real void )
  {
    WriteLn( "F de A" );
    0
  }
};

@A anA = [[ Real a = 1 ]];

Class @B : @A {
  Real F( Real void )
  {
    WriteLn( "F de B" );
    0
  }
};

@B anB = [[ Real a = 2 ]];

@A ptrA = anA;
@A ptrB = anB;

Real ptrB::F(?);


// Jueves, 2010/06/03 12:05:23.00
Class @A {
  Real a;

  Real F( Real void )
  {
    WriteLn( "F de A" );
    0
  }
};

@A anA = [[ Real a = 1 ]];

Class @B : @A {
  Real F( Real void )
  {
    WriteLn( "F de B" );
    0
  }
};

@B anB = [[ Real a = 2 ]];

@A ptrA = anA;
@A ptrB = anB;


// Jueves, 2010/06/03 12:05:13.00
Class @A {
  Real a;

  Real F( Real void )
  {
    WriteLn( "F de A" );
    0
  }
};

@A anA = [[ Real a = 1 ]];

Class @B : @A {
  Real F( Real void )
  {
    WriteLn( "F de B" );
    0
  }
};

@B anB = [[ Real a = 2 ]];

@A ptrA = anA;
@A ptrA = anB;


// Jueves, 2010/06/03 12:04:40.00
Class @A {
  Real a;

  Real F( Real void )
  {
    WriteLn( "F de A" );
    0
  }
};

@A anA = [[ Real a = 1 ]];

Class @B : @A {
  Real F( Real void )
  {
    WriteLn( "F de B" );
    0
  }
};

@B anB = [[ Real a = 2 ]];


// Jueves, 2010/06/03 12:04:35.00
Class @A {
  Real a;

  Real F( Real void )
  {
    WriteLn( "F de A" );
    0
  }
};

@A anA = [[ Real a = 1 ]];

// Jueves, 2010/06/03 12:04:13.00
Class @A {
  Real a;

  Real F( Real void )
  {
    WriteLn( "F de A" );
    0
  }
};

@A anA = [[ a = 1 ]];

// Jueves, 2010/06/03 12:03:09.00
Class @A {
  Real a;

  Real F( Real void )
  {
    WriteLn( "F de A" );
    0
  }
};

Class @B : @A {
  Real F( Real void )
  {
    WriteLn( "F de B" );
    0
  }
};

@A anA = [[ a = 1 ]];

// Jueves, 2010/06/03 12:02:05.00
Class @A {
  Real a = 1;

  Real F( Real void )
  {
    WriteLn( "F de A" );
    0
  }
};

Class @B : @A {
  Real F( Real void )
  {
    WriteLn( "F de B" );
    0
  }
};

@A anA = [[ a = 1 ]];
@B anB = [[ a = 2 ]];


// Martes, 2010/05/25 15:32:27.00
  Real OptionState( Set selection )
  {
    Real 1
  };

  Real OptionCmd( NameBlock obj, Set extraData )
  {
    WriteLn( "OptionCmd invoked" );
    Real 1
  };
  
  @MenuOption submenu1 = @MenuOption::New( [[ Text name = "SubMenu1" ]] );
  @MenuOption submenu2 = @MenuOption::New( [[ Text name = "SubMenu1/SubMenu2" ]] );
  @MenuCommand cmd1 =
    @MenuCommand::New(
      [[ Text name = "SubMenu1/SubMenu2/Option1",
         Text label = "Option 1",
         Set commands = [[ Code CmdInvoke = OptionCmd, Code CmdState = OptionState ]] ]] )


// Lunes, 2010/05/17 18:39:32.00
MMS


// Domingo, 2010/05/16 00:33:46.00
MMS




// Domingo, 2010/05/16 00:33:15.00
MMS


// Sabado, 2010/05/15 18:00:16.00

Real DoBSREstimation( NameBlock model )
{
  Text name = model::GetName(0);
  Text version = model::GetVersion(0);
  Set model_ref = [[ name, version ]];
  Set estimation_ref = model_ref << [[ "BSR" ]];
  Real idx_estim = MMS::FindEstimation( estimation_ref );
  Real If( idx_estim, MMS::RemoveEstimation( idx_estim ) );
  Real MMS::CreateEstimation([[
          Text _.name = "BSR";
          @MMS.Model _.model = MMS::GetModel( model_ref );
          @MMS.SettingsBSR _.settings = [[
               Real mcmc.sampleLength = 2000
          ]]
       ]]);
  @MMS.Estimation estimation = MMS::GetEstimation( estimation_ref  );
  Set Tcl_Eval( "::TolConsole::RaiseInspector; ::TolConsole::ShowWindow output" );
  Real estimation::Execute(?);
  Set Tcl_Eval( "tk_messageBox -message {Estimation Done}" );
  Real 0
};






// Sabado, 2010/05/15 17:59:15.00

Real DoBSREstimation( NameBlock model )
{
  Text name = model::GetName(0);
  Text version = model::GetVersion(0);
  Set model_ref = [[ name, version ]];
  Set estimation_ref = model_ref << [[ "BSR" ]];
  Real idx_estim = MMS::FindEstimation( estimation_ref );
  Real If( idx_estim, MMS::RemoveEstimation( idx_estim ) );
  Real MMS::CreateEstimation([[
          Text _.name = "BSR";
          @MMS.Model _.model = MMS::GetModel( model_ref );
          @MMS.SettingsBSR _.settings = [[
               Real mcmc.sampleLength = 2000
          ]]
       ]]);
  @MMS.Estimation estimation = MMS::GetEstimation( estimation_ref  );
  Set Tcl_Eval( "::TolConsole::RaiseInspector; ::TolConsole::ShowWindow output" );
  Real estimation::Execute(?);
  Tcl_Eval( "tk_messageBox -message {Estimation Done}" );
  Real 0
};






// Sabado, 2010/05/15 17:53:17.00

Real DoBSREstimation( NameBlock model )
{
  Text name = model::GetName(0);
  Text version = model::GetVersion(0);
  Set model_ref = [[ name, version ]];
  Set estimation_ref = model_ref << [[ "BSR" ]];
  Real idx_estim = MMS::FindEstimation( estimation_ref );
  Real If( idx_estim, MMS::RemoveEstimation( idx_estim ) );
  Real MMS::CreateEstimation([[
          Text _.name = "BSR";
          @MMS.Model _.model = MMS::GetModel( model_ref );
          @MMS.SettingsBSR _.settings = [[
               Real mcmc.sampleLength = 2000
          ]]
       ]]);
  @MMS.Estimation estimation = MMS::GetEstimation( estimation_ref  );
  Real estimation::Execute(?);
  Set Tcl_Eval( "tk_messageBox -message {Estimation Done}" );
  Real 0
};





// Sabado, 2010/05/15 17:46:54.00

Real @MMS.Model::AddCustomMenuOption( [[ "BSR Estimate",
                                         "DoBSREstimation" ]] );

// Sabado, 2010/05/15 17:46:37.00
Real DoBSREstimation( NameBlock model )
{
  Text name = model::GetName(0);
  Text version = model::GetVersion(0);
  Set model_ref = [[ name, version ]];
  Set estimation_ref = model_ref << [[ "BSR" ]];
  Real idx_estim = MMS::FindEstimation( estimation_ref );
  Real If( idx_estim, MMS::RemoveEstimation( idx_estim ) );
  Real MMS::CreateEstimation([[
          Text _.name = "BSR";
          @MMS.Model _.model = MMS::GetModel( model_ref );
          @MMS.SettingsBSR _.settings = [[
               Real mcmc.sampleLength = 2000
          ]]
       ]]);
  @MMS.Estimation estimation = MMS::GetEstimation( estimation_ref  );
  Real estimation::Execute(?)
};



// Sabado, 2010/05/15 17:22:45.00
Matrix NL1::cycler::_.x - NL2::cycler::_.x;
Matrix NL1::cycler::_.y - NL2::cycler::_.y;

// Sabado, 2010/05/15 17:22:20.00
Matrix NL1::cycler::_.x

// Sabado, 2010/05/15 17:21:56.00
Matrix NL1[1]::_.x

// Sabado, 2010/05/15 17:21:38.00
Matrix NL1[1]::_x

// Sabado, 2010/05/15 17:21:05.00
VMatrix Y1 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/InstantEffect__1.0/y2010m05d14h20i03s24.00/obs/CokeSales/primary/Output.oza" )[1]
};

VMatrix Y2 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/ModeloSalesInverseDeltaAdStockCoke__1.0/y2010m05d15h17i04s01.00/obs/cokeSales/primary/Output.oza" )[1]
};

VMatrix Y1 - Y2;

VMatrix X1 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/InstantEffect__1.0/y2010m05d14h20i03s24.00/obs/CokeSales/primary/Input.oza" )[1]
};

VMatrix X2 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/ModeloSalesInverseDeltaAdStockCoke__1.0/y2010m05d15h17i04s01.00/obs/cokeSales/primary/Input.oza" )[1]
};

VMatrix X1 - X2;

Set NL1 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/InstantEffect__1.0/y2010m05d14h20i03s24.00/obs/CokeSales/primary/CokeSales.NonLinearFilters.oza" )
};

Set NL2 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/ModeloSalesInverseDeltaAdStockCoke__1.0/y2010m05d15h17i04s01.00/obs/cokeSales/primary/cokeSales.NonLinearFilters.oza" )
};


// Sabado, 2010/05/15 17:20:42.00
VMatrix Y1 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/InstantEffect__1.0/y2010m05d14h20i03s24.00/obs/CokeSales/primary/Output.oza" )[1]
};

VMatrix Y2 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/ModeloSalesInverseDeltaAdStockCoke__1.0/y2010m05d15h17i04s01.00/obs/cokeSales/primary/Output.oza" )[1]
};

VMatrix Y1 - Y2;

VMatrix X1 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/InstantEffect__1.0/y2010m05d14h20i03s24.00/obs/CokeSales/primary/Input.oza" )[1]
};

VMatrix X2 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/ModeloSalesInverseDeltaAdStockCoke__1.0/y2010m05d15h17i04s01.00/obs/cokeSales/primary/Input.oza" )[1]
};

VMatrix X1 - X2;

Set NL1 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/InstantEffect__1.0/y2010m05d14h20i03s24.00/obs/CokeSales/primary/cokeSales.NonLinearFilters.oza" )
};

Set NL2 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/ModeloSalesInverseDeltaAdStockCoke__1.0/y2010m05d15h17i04s01.00/obs/cokeSales/primary/cokeSales.NonLinearFilters.oza" )
};


// Sabado, 2010/05/15 17:20:18.00
VMatrix Y1 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/InstantEffect__1.0/y2010m05d14h20i03s24.00/obs/CokeSales/primary/Output.oza" )[1]
};

VMatrix Y2 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/ModeloSalesInverseDeltaAdStockCoke__1.0/y2010m05d15h17i04s01.00/obs/cokeSales/primary/Output.oza" )[1]
};

VMatrix Y1 - Y2;

VMatrix X1 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/InstantEffect__1.0/y2010m05d14h20i03s24.00/obs/CokeSales/primary/Input.oza" )[1]
};

VMatrix X2 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/ModeloSalesInverseDeltaAdStockCoke__1.0/y2010m05d15h17i04s01.00/obs/cokeSales/primary/Input.oza" )[1]
};

VMatrix X1 - X2;

Set NL1 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/InstantEffect__1.0/y2010m05d14h20i03s24.00/obs/cokeSales/primary/cokeSales.NonLinearFilters.oza" )
};

Set NL2 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/ModeloSalesInverseDeltaAdStockCoke__1.0/y2010m05d15h17i04s01.00/obs/cokeSales/primary/cokeSales.NonLinearFilters.oza" )
};


// Sabado, 2010/05/15 17:18:17.00
VMatrix Y1 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/InstantEffect__1.0/y2010m05d14h20i03s24.00/obs/CokeSales/primary/Output.oza" )[1]
};

VMatrix Y2 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/ModeloSalesInverseDeltaAdStockCoke__1.0/y2010m05d15h17i04s01.00/obs/cokeSales/primary/Output.oza" )[1]
};

VMatrix Y1 - Y2;

VMatrix X1 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/InstantEffect__1.0/y2010m05d14h20i03s24.00/obs/CokeSales/primary/Input.oza" )[1]
};

VMatrix X2 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/ModeloSalesInverseDeltaAdStockCoke__1.0/y2010m05d15h17i04s01.00/obs/cokeSales/primary/Input.oza" )[1]
};

VMatrix X1 - X2;

Set NL1 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/ModeloSalesInverseDeltaAdStockCoke__1.0/y2010m05d15h17i04s01.00/obs/cokeSales/primary/cokeSales.NonLinearFilters.oza" )
};


// Sabado, 2010/05/15 17:16:36.00
VMatrix Y1 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/InstantEffect__1.0/y2010m05d14h20i03s24.00/obs/CokeSales/primary/Output.oza" )[1]
};

VMatrix Y2 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/ModeloSalesInverseDeltaAdStockCoke__1.0/y2010m05d15h17i04s01.00/obs/cokeSales/primary/Output.oza" )[1]
};

VMatrix Y1 - Y2;

VMatrix X1 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/InstantEffect__1.0/y2010m05d14h20i03s24.00/obs/CokeSales/primary/Input.oza" )[1]
};

VMatrix X2 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/ModeloSalesInverseDeltaAdStockCoke__1.0/y2010m05d15h17i04s01.00/obs/cokeSales/primary/Input.oza" )[1]
};

VMatrix X1 - X2;


// Sabado, 2010/05/15 17:15:48.00
VMatrix Y1 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/InstantEffect__1.0/y2010m05d14h20i03s24.00/obs/CokeSales/primary/Output.oza" )[1]
};

VMatrix Y2 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/ModeloSalesInverseDeltaAdStockCoke__1.0/y2010m05d15h17i04s01.00/obs/cokeSales/primary/Output.oza" )[1]
};

VMatrix Y1 - Y2;


// Sabado, 2010/05/15 17:14:17.00
VMatrix Y1 = {
  Include( "/home/jsperez/.tol/tmp/MMS/BSR/InstantEffect__1.0/y2010m05d14h20i03s24.00/obs/CokeSales/primary/Output.oza" )[1]
};

// Sabado, 2010/05/15 17:13:58.00
VMatrix Y1 = {
  Set Include( "/home/jsperez/.tol/tmp/MMS/BSR/InstantEffect__1.0/y2010m05d14h20i03s24.00/obs/CokeSales/primary/Output.oza" )[1]
};

// Sabado, 2010/05/15 17:13:25.00
Set O1 = {
  Set Include( "/home/jsperez/.tol/tmp/MMS/BSR/InstantEffect__1.0/y2010m05d14h20i03s24.00/obs/CokeSales/primary/Output.oza" )
}


// Sabado, 2010/05/15 17:12:21.00
Set O1 = {
  Set Include( "~/.tol/tmp/MMS/BSR/InstantEffect__1.0/y2010m05d14h20i03s24.00/obs/CokeSales/primary/Output.oza" )
}


// Viernes, 2010/05/14 19:23:03.00
Real MMS::FindModel( ModelInfo );


// Viernes, 2010/05/14 19:22:10.00
Code MMS::FindModel



// Viernes, 2010/05/14 19:21:38.00
MMS



// Miercoles, 2010/04/28 07:42:19.00
NameBlock kk = [[
  Real _Destroy( Real void )
  {
    WriteLn( "Me voy" )
  }
]]


// Miercoles, 2010/04/28 06:47:54.00
NameBlock MMS;

// Miercoles, 2010/04/28 06:44:08.00
Class @Ejemplo { Real a };
@Ejemplo ej = [[ Real a = 1 ]];



// Viernes, 2010/04/23 14:35:01.00
 Code If(!ObjectExist("Code", "MultiplicaPorDos"),
          Real MultiplicaPorDos(Real n) { 2*n } );
 Real MultiplicaPorDos(3);



// Viernes, 2010/04/23 14:35:01.00
 Code If(!ObjectExist("Code", "MultiplicaPorDos"),
          Real MultiplicaPorDos(Real n) { 2*n } );
 Real MultiplicaPorDos(3);



// Viernes, 2010/04/23 14:35:01.00
 Code If(!ObjectExist("Code", "MultiplicaPorDos"),
          Real MultiplicaPorDos(Real n) { 2*n } );
 Real MultiplicaPorDos(3);



// Viernes, 2010/04/23 14:35:01.00
 Code If(!ObjectExist("Code", "MultiplicaPorDos"),
          Real MultiplicaPorDos(Real n) { 2*n } );
 Real MultiplicaPorDos(3);



// Viernes, 2010/04/23 14:35:01.00
 Code If(!ObjectExist("Code", "MultiplicaPorDos"),
          Real MultiplicaPorDos(Real n) { 2*n } );
 Real MultiplicaPorDos(3);



// Viernes, 2010/04/23 14:35:01.00
 Code If(!ObjectExist("Code", "MultiplicaPorDos"),
          Real MultiplicaPorDos(Real n) { 2*n } );
 Real MultiplicaPorDos(3);



// Viernes, 2010/04/23 14:35:01.00
 Code If(!ObjectExist("Code", "MultiplicaPorDos"),
          Real MultiplicaPorDos(Real n) { 2*n } );
 Real MultiplicaPorDos(3);



// Viernes, 2010/04/23 14:35:00.00
 Code If(!ObjectExist("Code", "MultiplicaPorDos"),
          Real MultiplicaPorDos(Real n) { 2*n } );
 Real MultiplicaPorDos(3);



// Viernes, 2010/04/23 14:35:00.00
 Code If(!ObjectExist("Code", "MultiplicaPorDos"),
          Real MultiplicaPorDos(Real n) { 2*n } );
 Real MultiplicaPorDos(3);



// Viernes, 2010/04/23 14:35:00.00
 Code If(!ObjectExist("Code", "MultiplicaPorDos"),
          Real MultiplicaPorDos(Real n) { 2*n } );
 Real MultiplicaPorDos(3);



// Viernes, 2010/04/23 14:34:59.00
 Code If(!ObjectExist("Code", "MultiplicaPorDos"),
          Real MultiplicaPorDos(Real n) { 2*n } );
 Real MultiplicaPorDos(3);



// Viernes, 2010/04/23 14:34:58.00
 Code If(!ObjectExist("Code", "MultiplicaPorDos"),
          Real MultiplicaPorDos(Real n) { 2*n } );
 Real MultiplicaPorDos(3);



// Viernes, 2010/04/23 14:26:08.00
Code If(!ObjectExist("Code", "MultiplicaPorDos"), Real
 MultiplicaPorDos(Real n) { 2*n } );
 Real m = MultiplicaPorDos(3);



// Viernes, 2010/04/23 14:25:06.00
Real If(ObjectExist("Code", "MultiplicaPorDos"), ?, Real
 MultiplicaPorDos(Real n) { 2*n }; Real ?);
 Real m = MultiplicaPorDos(3);



// Viernes, 2010/04/23 14:24:41.00
Real If(ObjectExist("Code", "MultiplicaPorDos"), ?, Real
 MultiplicaPorDos(Real n) { 2*n });
 Real m = MultiplicaPorDos(3);



// Jueves, 2010/04/22 18:22:05.00
Class @Ejemplo { Real a };
@Ejemplo ej = [[ Real a = 1 ]];


// Jueves, 2010/04/22 18:20:34.00
MMS


// Lunes, 2010/04/19 19:06:18.00
    Matrix mu_ = Col(2.0, 2.0);
    Matrix COV = ((1.0, 4/5.0),(4/5.0, 1.0));
    Matrix B = ((-1.0, 0.0), (1.0, 0.0));
    Matrix b = Col(0.0, 0.0);
    Matrix MCsample = GibbsConstrainedMNormal(mu_, COV, B, b, 1, 100);


// Lunes, 2010/04/19 19:05:52.00
    Matrix mu = Col(2.0, 2.0);
    Matrix COV = ((1.0, 4/5.0),(4/5.0, 1.0));
    Matrix B = ((-1.0, 0.0), (1.0, 0.0));
    Matrix b = Col(0.0, 0.0);
    Matrix MCsample = GibbsConstrainedMNormal(mu, COV, B, b, 1, 100);


// Miercoles, 2010/04/14 00:05:05.00
Real CustomOption( NameBlock S )
{
  Real 0
};


Real @MMS.Model::AddCustomMenuOption( [["Mi Grafico",
                                           "CustomOption" ]] );



// Martes, 2010/04/13 14:08:36.00
Matrix _Mat1 = Gaussian( 100, 1, 0, 1 );
Matrix _Mat2 = Gaussian( 100, 2, 0, 1 );

Real MMS::CreateVariable( [[ Text _.name = "Mat1",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat1" ]] );

Real MMS::CreateVariable( [[ Text _.name = "Mat2",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat2" ]] );



// Martes, 2010/04/13 14:07:54.00
Real CustomDrawSingle( NameBlock S )
{
  Real S::Chart(0)
};

Real CustomDrawMultiple( Set selection )
{
  Text theClass = ClassOf( selection[ 1 ] );
  Real Eval( theClass + "::ChartGroup(selection)" )
};


Real @MMS.Variable::AddCustomMenuOption( [["Mi Grafico",
                                           "CustomDrawSingle",
                                           "CustomDrawMultiple" ]] );



// Martes, 2010/04/13 14:06:38.00
  Matrix _Mat1 = Gaussian( 100, 1, 0, 1 );
Matrix _Mat2 = Gaussian( 100, 2, 0, 1 );

Real MMS::CreateVariable( [[ Text _.name = "Mat1",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat1" ]] );

Real MMS::CreateVariable( [[ Text _.name = "Mat2",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat2" ]] );



// Martes, 2010/04/13 14:00:50.00
MMS


// Martes, 2010/04/13 11:18:36.00
NameBlock MMS

// Martes, 2010/04/13 11:15:50.00
MMS

// Martes, 2010/04/13 11:15:30.00
  Matrix _Mat1 = Gaussian( 100, 1, 0, 1 );
Matrix _Mat2 = Gaussian( 100, 2, 0, 1 );

Real MMS::CreateVariable( [[ Text _.name = "Mat1",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat1" ]] );

Real MMS::CreateVariable( [[ Text _.name = "Mat2",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat2" ]] );



// Martes, 2010/04/13 11:05:37.00
// Martes, 2010/04/13 11:04:18.00
  Matrix _Mat1 = Gaussian( 100, 1, 0, 1 );
Matrix _Mat2 = Gaussian( 100, 2, 0, 1 );

Real MMS::CreateVariable( [[ Text _.name = "Mat1",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat1" ]] );

Real MMS::CreateVariable( [[ Text _.name = "Mat2",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat2" ]] );


// Martes, 2010/04/13 11:00:22.00
Real CustomDrawSingle( NameBlock S )
{
  Real S::Chart(0)
};

Real CustomDrawMultiple( Set selection )
{
  Text theClass = ClassOf( selection[ 1 ] );
  Real Eval( theClass + "::ChartGroup(selection)" )
};


Real @MMS.Variable::AddCustomMenuOption( [["Mi Grafico",
                                           "CustomDrawSingle",
                                           "CustomDrawMultiple" ]] );



// Martes, 2010/04/13 11:04:18.00
  Matrix _Mat1 = Gaussian( 100, 1, 0, 1 );
Matrix _Mat2 = Gaussian( 100, 2, 0, 1 );

Real MMS::CreateVariable( [[ Text _.name = "Mat1",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat1" ]] );

Real MMS::CreateVariable( [[ Text _.name = "Mat2",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat2" ]] );


// Martes, 2010/04/13 11:00:22.00
Real CustomDrawSingle( NameBlock S )
{
  Real S::Chart(0)
};

Real CustomDrawMultiple( Set selection )
{
  Text theClass = ClassOf( selection[ 1 ] );
  Real Eval( theClass + "::CharGroup(selection)" )
};


Real @MMS.Variable::AddCustomMenuOption( [["Mi Grafico",
                                           "CustomDrawSingle",
                                           "CustomDrawMultiple" ]] );



// Martes, 2010/04/13 11:01:04.00
  Matrix _Mat1 = Gaussian( 100, 1, 0, 1 );
Matrix _Mat2 = Gaussian( 100, 2, 0, 1 );

Real MMS::CreateVariable( [[ Text _.name = "Mat1",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat1" ]] );

Real MMS::CreateVariable( [[ Text _.name = "Mat2",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat2" ]] );


// Martes, 2010/04/13 11:00:22.00
Real CustomDrawSingle( NameBlock S )
{
  Real S::Chart(0)
};

Real CustomDrawMultiple( Set selection )
{
  Text theClass = ClassOf( selection[ 1 ] );
  Real Eval( theClass + "::CharGroup(selection)" )
};


Real @MMS.Variable::AddCustomMenuOption( [["Mi Grafico",
                                           "CustomDrawSingle",
                                           "CustomDrawMultiple" ]] );



// Lunes, 2010/04/12 19:58:29.00
Real CustomDrawSingle( NameBlock S )
{
  Real S::Chart(0)
};

Real CustomDrawMultiple( Set selection )
{
  Text theClass = ClassOf( selection[ 1 ] );
  Real Eval( theClass + "::CharGroup(selection)" )
};


Real @MMS.Variable::AddCustomMenuOption( [["Mi Grafico",
                                           "CustomDrawSingle",
                                           "CustomDrawMultiple" ]] );

Set @MMS.VariableSerie::GetCustomMenuOptions(0);


// Lunes, 2010/04/12 19:56:15.00
Real FunctionExist( "Set", "@MMS.VariableSerie::AddCustomMenuOption" );

// Lunes, 2010/04/12 19:55:00.00
Set @MMS.VariableSerie::GetCustomMenuOptions(0);

// Lunes, 2010/04/12 19:53:06.00
Real FunctionExist( "Set", "@MMS.VariableSerie::GetCustomMenuOptions" );

// Lunes, 2010/04/12 19:48:28.00
Set @MMS.VariableSerie::GetCustomMenuOptions(0);

// Lunes, 2010/04/12 19:48:07.00
Set @MMS.Variable::GetCustomMenuOptions(0);

// Lunes, 2010/04/12 19:47:27.00
Real CustomDrawSingle( NameBlock S )
{
  Real S::Chart(0)
};

Real CustomDrawMultiple( Set selection )
{
  Text theClass = ClassOf( selection[ 1 ] );
  Real Eval( theClass + "::CharGroup(selection)" )
};


Real @MMS.Variable::AddCustomMenuOption( [["Mi Grafico",
                                           "CustomDrawSingle",
                                           "CustomDrawMultiple" ]] );


// Lunes, 2010/04/12 19:45:59.00
Set @MMS.Variable::_.CustomMenu;

// Lunes, 2010/04/12 19:44:04.00
MMS

// Lunes, 2010/04/12 19:43:32.00
Set @MMS.Variable::GetCustomMenuOptions(0);

// Lunes, 2010/04/12 19:42:56.00
Real CustomDrawSingle( NameBlock S )
{
  Real S::Chart(0)
};

Real CustomDrawMultiple( Set selection )
{
  Text theClass = ClassOf( selection[ 1 ] );
  Real Eval( theClass + "::CharGroup(selection)" )
};


Real @MMS.Variable::AddCustomMenuOption( [["Mi Grafico",
                                           "CustomDrawSingle",
                                           "CustomDrawMultiple" ]] );



// Lunes, 2010/04/12 19:42:32.00
Real CustomDrawSingle( NameBlock S )
{
  Real S::Chart(0)
};

Real CustomDrawMultiple( Set selection )
{
  Text theClass = ClassOf( selection[ 1 ] );
  Real Eval( theClass + "::CharGroup(selection)" )
};


Real @MMS.Variable::AddCustomMenuOption( "Mi Grafico",
                                         "CustomDrawSingle",
                                         "CustomDrawMultiple" );



// Lunes, 2010/04/12 19:21:33.00
Real FunctionExist( "Real", "@MMS.Variable::AddCustomMenuOption" );


// Lunes, 2010/04/12 19:20:10.00
Real FunctionExist( "Real", "@MMS.Variable::AddCustomMenu" );


// Lunes, 2010/04/12 19:19:56.00
Real FunctionExists( "Real", "@MMS.Variable::AddCustomMenu" );


// Lunes, 2010/04/12 18:12:18.00
Class @A {
  Static Real KK( Real void ) {
    Real 1
  }
};

Class @B : @A {
  Real r = 2
};

Real @A::KK(3);

Real @B::KK(3);


// Lunes, 2010/04/12 18:10:27.00
Class @A {
  Static Real KK( Real void ) {
    Real 1
  }
};

Class @B : @A {
  Real r = 2
};

Real @B::KK(3);


// Lunes, 2010/04/12 18:10:13.00
Class @A {
  Static KK( Real void ) {
    Real 1
  }
};

Class @B : @A {
  Real r = 2
};

Real @B::KK(3);


// Lunes, 2010/04/12 18:10:01.00
Class @A {
  Static KK( Real void ) {
    Real 1
  }
};

Class @B : @A {
  Real r = 2
};

Real @B::KK(3);


// Lunes, 2010/04/12 18:09:52.00
Class @A {
  Static KK( Real void ) {
    Real 1
  }
};

Class @B : @A {
  Real r = 2;
};

Real @B::KK(3);


// Lunes, 2010/04/12 16:17:19.00
  Matrix _Mat1 = Gaussian( 100, 1, 0, 1 );
Matrix _Mat2 = Gaussian( 100, 2, 0, 1 );

Real MMS::CreateVariable( [[ Text _.name = "Mat1",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat1" ]] );

Real MMS::CreateVariable( [[ Text _.name = "Mat2",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat2" ]] );


// Lunes, 2010/04/12 16:15:46.00
Real CustomDrawSingle( @MMS.VariableSerie S )
{
  Real S::Chart(0)
};

Real CustomDrawMultiple( Set selection )
{
  Real @MMS.VariableSerie::ChartGroup( selection )
};

Real MMS::CustomMenuDesc::AddMenuOption( "@MMS.VariableSerie", "Mi Grafico",
                                         "CustomDrawSingle",
                                         "CustomDrawMultiple" );



// Lunes, 2010/04/12 16:14:17.00
Real CustomDrawSingle( @MMS.VariableSerie S )
{
  Real S::Chart(0)
};

Real CustomDrawMultiple( Set selection )
{
  Real @MMS.VariableSerie::ChartGroup( selection )
};

Real MMS::CustomMenuDesc::AddMenuOption( "@MMS.VariableSerie", "Mi Grafico", "CustomDrawSingle", "CustomDrawMultiple" );



// Lunes, 2010/04/12 16:13:08.00
Real CustomDrawSingle( @MMS.VariableSerie S )
{
  Real S::Chart(0)
};

Real CustomDrawMultiple( Set selection )
{
  Real @MMS.VariableSerie::ChartAll( selection )
};

Real MMS::CustomMenuDesc::AddMenuOption( "@MMS.VariableSerie", "Mi Grafico", "CustomDrawSingle", "CustomDrawMultiple" );



// Lunes, 2010/04/12 16:12:31.00
Real CustomDrawSingle( @MMS.VariableSerie S )
{
  Real S::Chart(0)
};

Real CustomDrawMultiple( Set selection )
{
  Real @MMS.VariableSerie::ChartAll( selection )
};

Real MMS::CustomMenuDesc::AddMenuOption( "@MMS.VariableSerie", "Mi Grafico", CustomDrawSingle, CustomDrawMultiple );



// Lunes, 2010/04/12 16:11:55.00
Real CustomDrawSingle( @MMS.VariableSerie S )
{
  Real S::Chart(0)
};

Real CustomDrawMultiple( Set selection )
{
  Real @MMS.VariableSerie::ChartAll( selection )
};

Real MMS::CustomMenu::AddMenuOption( "@MMS.VariableSerie", "Mi Grafico", CustomDrawSingle, CustomDrawMultiple );



// Lunes, 2010/04/12 16:11:22.00
Real CustomDrawSingle( @MMS.VariableSerie S )
{
  Real S::Chart(0)
};

Real CustomDrawMultiple( Set selection )
{
  Real @MMS.VariableSerie::ChartAll( selection )
}

Real MMS::CustomMenu::AddMenuOption( "@MMS.VariableSerie", "Mi Grafico", CustomDrawSingle, CustomDrawMultiple );



// Lunes, 2010/04/12 15:05:55.00
Set MMS::CustomMenuDesc::GetMenuDescription( "@MMS.Variable" );

Set rr = [[ [[1,2,3]], Empty ]];


// Lunes, 2010/04/12 14:45:47.00
Set MMS::CustomMenuDesc::GetMenuDescription( "@MMS.Variable" );


// Lunes, 2010/04/12 14:40:21.00
NameBlock CustomMenuDesc =
[[
  Set MenuOptions = Copy(Empty);

  Real AddMenuOption( Text Class_,
                      Text Label,
                      Text InstanceMethod,
                      Text GroupMethod )
  {
    Real idx_ = FindObjectByName( MenuOptions, Class_ );
    Real idx = If( idx_, idx, {
        Set aux = Copy( Empty );
        Set Append( MenuOptions, [[ PutName( Class_, aux ) ]], True );
        Real Card( MenuOptions )
      } );
    Set Append( MenuOptions[ idx ],
                [[ [[ Label, InstanceMethod, GroupMethod ]] ]] );
    Real Card( MenuOptions )
  };

  Set GetMenuDescription( Text Class_ )
  {
    Real idx = FindObjectByName( MenuOptions, Class_ );
    Set If( idx, MenuOptions[ Class_ ], Copy( Empty ) )
  }
]];



// Lunes, 2010/04/12 14:40:12.00
NameBlock CustomMenuDesc
[[
  Set MenuOptions = Copy(Empty);

  Real AddMenuOption( Text Class_,
                      Text Label,
                      Text InstanceMethod,
                      Text GroupMethod )
  {
    Real idx_ = FindObjectByName( MenuOptions, Class_ );
    Real idx = If( idx_, idx, {
        Set aux = Copy( Empty );
        Set Append( MenuOptions, [[ PutName( Class_, aux ) ]], True );
        Real Card( MenuOptions )
      } );
    Set Append( MenuOptions[ idx ],
                [[ [[ Label, InstanceMethod, GroupMethod ]] ]] );
    Real Card( MenuOptions )
  };

  Set GetMenuDescription( Text Class_ )
  {
    Real idx = FindObjectByName( MenuOptions, Class_ );
    Set If( idx, MenuOptions[ Class_ ], Copy( Empty ) )
  }
]];



// Lunes, 2010/04/12 14:39:50.00
NameBlock CustomMenuDesc : @MenuDesc
[[
  Set MenuOptions = Copy(Empty);

  Real AddMenuOption( Text Class_,
                      Text Label,
                      Text InstanceMethod,
                      Text GroupMethod )
  {
    Real idx_ = FindObjectByName( MenuOptions, Class_ );
    Real idx = If( idx_, idx, {
        Set aux = Copy( Empty );
        Set Append( MenuOptions, [[ PutName( Class_, aux ) ]], True );
        Real Card( MenuOptions )
      } );
    Set Append( MenuOptions[ idx ],
                [[ [[ Label, InstanceMethod, GroupMethod ]] ]] );
    Real Card( MenuOptions )
  };

  Set GetMenuDescription( Text Class_ )
  {
    Real idx = FindObjectByName( MenuOptions, Class_ );
    Set If( idx, MenuOptions[ Class_ ], Copy( Empty ) )
  }
]];



// Miercoles, 2010/04/07 13:58:26.00
Matrix Quantile( V3G_BTS_TOT, Col(0) );


// Miercoles, 2010/04/07 13:58:16.00
Matrix Quantile( V3G_BTS_TOT, SetCol(0) );


// Miercoles, 2010/04/07 13:37:58.00
Code FindCode( "Real", "Quantile" )


// Miercoles, 2010/04/07 13:29:23.00
Set Range( 0, 1, 0.05 );

// Miercoles, 2010/04/07 13:29:04.00
Set Range( 0, 1, 0.2 );


// Miercoles, 2010/04/07 13:28:54.00
Set Range( 0, 1, 0.1 );


// Miercoles, 2010/04/07 11:44:21.00
Real DBOpen( "tfnesprade3g", "tfnesp", "tfn!116." );
Set sizes = [[ 1000, 5000, 10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000,
               60000, 70000, 80000, 90000, 100000, 150000, 200000, 500000, 10000000, 3000000, 5000000 ]];
Set result = BinGroup( "Concat", EvalSet( sizes, Set( Real k ) {
  Text k_text = FormatReal( k, "%.0f" );
  Set DBTable( "select " + k_text + " as threshold, bts_group, count(*) as cantidad
                from fun_bts_group("+k_text+") group by bts_group" )
} ) );



// Miercoles, 2010/04/07 11:43:51.00
Real DBOpen( "tfnesprade3g", "tfnesp", "tfn!116." );
Set sizes = [[ 1000, 5000, 10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000,
               60000, 70000, 80000, 90000, 100000, 150000, 200000, 500000, 10000000, 3000000, 5000000 ]];
Set result = BinGroup( "Concat", EvalSet( sizes, Set( Real k ) {
  Text k_text = FormatReal( k, "%.0f" );
  Set DBTable( "select " + k_text + " as threshold, bts_group, count(*) as cantidad
                from fun_bts_group("+k_text+") group by bts_group" )
} );



// Miercoles, 2010/04/07 11:42:28.00
Real DBOpen( "tfnesprade3g", "tfnesp", "tfn!116." );
Set sizes = [[ 1000, 5000, 10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000,
               60000, 70000, 80000, 90000, 100000, 150000, 200000, 500000, 10000000, 3000000, 5000000 ]]
Set result = BinGroup( "Concat", EvalSet( sizes, Set( Real k ) {
  Text k_text = FormatReal( k, "%.0f" );
  Set DBTable( "select " + k_text + " as threshold, bts_group, count(*) as cantidad
                from fun_bts_group("+k_text+") group by bts_group" )
} );


// Miercoles, 2010/04/07 00:55:39.00
Real GuiPlotModelVSNoise (GetObjectFromAddress("988BCD0:0:8936C20:0:8712218:0:2:4:5") )

// Martes, 2010/04/06 23:44:12.00
Code FormatReal


// Martes, 2010/04/06 23:44:00.00
Code RealTextS


// Martes, 2010/04/06 23:43:52.00
Code RealText


// Martes, 2010/04/06 23:43:42.00
Code RealFormat


// Martes, 2010/04/06 14:23:36.00
NameBlock estim_args = 
[[
  Text tarifa = "Big Screen";
  Real lower_vol3g = 5 * 1024 * 1024;
  Real lower_duracion_voz = 100 * 60;
  Real is_estim = 1;
  Real rebuild = 1
]];

NameBlock ld = LoaderDataBTSTarifa( RaDe3G.DB::rade3g, estim_args );
Set data = ld::LoadData( 1 );



// Martes, 2010/04/06 14:22:53.00
NameBlock estim_args = 
[[
  Text tarifa = "Big Screen";
  Real lower_vol3g = 5 * 1024 * 1024;
  Real lower_duracion_voz = 100 * 60;
  Real is_estim = 1;
  Real rebuild = 1
]];

NameBlock ld = LoaderDataBTSTarifa( RaDe3G.DB::rade3g, estim_args );
Set data = ld::LoadData( 1 );



// Martes, 2010/04/06 14:21:18.00
NameBlock estim_args = 
[[
  Text tarifa = "Big Screen";
  Real lower_vol3g = 5 * 1024 * 1024;
  Real lower_duracion_voz = 100 * 60;
  Real is_estim = 1;
  Real rebuild = 1
]];

NameBlock ld = LoaderDataBTSTarifa( RaDe3G.DB::rade3g, estim_args );
Set data = ld::LoadData( 1 );



// Martes, 2010/04/06 12:10:27.00
NameBlock estim_args = 
[[
  Real lower_vol3g = 5 * 1024 * 1024;
  Real lower_duracion_voz = 100 * 60;
  Real is_estim = 1;
  Real rebuild = 0
]];
Set BuildDataBtsTotal( estim_args );


// Martes, 2010/04/06 12:09:34.00
NameBlock estim_args = 
[[
  Real lower_vol3g = 5 * 1024 * 1024;
  Real lower_duracion_voz = 100 * 60;
  Real is_estim = 1;
  Real rebuild = 0
]];
Set BuildDataBtsTotal( estim_args );


// Martes, 2010/04/06 12:06:01.00
NameBlock estim_args = 
[[
  Real lower_vol3g = 5 * 1024 * 1024;
  Real lower_duracion_voz = 100 * 60;
  Real is_estim = 1;
  Real rebuild = 0
]];
Set BuildDataBtsTotal( estim_args );


// Martes, 2010/04/06 12:05:07.00
NameBlock estim_args = 
[[
  Real lower_vol3g = 5 * 1024 * 1024;
  Real lower_duracion_voz = 100 * 60;
  Real is_estim = 1;
  Real rebuild = 0
]];
Set BuildDataBtsTotal( estim_args );


// Martes, 2010/04/06 12:04:52.00
NameBlock estim_args = 
[[
  Real lower_vol3g = 5 * 1024 * 1024;
  Real lower_duracion_voz = 100 * 60;
  Real is_estim = 1;
  Real rebuild = 0
]];
Set BuildDataBtsTotal( estim.args );


// Lunes, 2010/04/05 11:43:54.00
Text ClassOf( obj1 );

// Lunes, 2010/04/05 11:43:41.00
@MMS.Variable var = MMS::GetVariable( "VariableA01" );

NameBlock obj = var::Copy(?);

NameBlock obj1 = var::Copy(?);

Text ClassOf( obj );

NameBlock obj1 := obj;


// Lunes, 2010/04/05 11:41:49.00
@MMS.Variable obj1 := obj;

// Lunes, 2010/04/05 11:41:34.00
NameBlock obj1 = var::Copy(?);

// Lunes, 2010/04/05 11:40:19.00
Text ClassOf( obj );

// Lunes, 2010/04/05 11:40:04.00
NameBlock obj = var::Copy(?);

// Lunes, 2010/04/05 11:39:22.00
@MMS.Variable var = MMS::GetVariable( "VariableA01" );


// Lunes, 2010/04/05 11:38:38.00
MMS


// Miercoles, 2010/03/31 21:30:02.00
Set param_references = [[ [[ "nodeobs1", "param1" ]], [[ "nodeobs2", "param1" ]], [[ "nodeobs2", "param1" ]] ]];

Real mean = 1.0;
Real sigma = 0.1;

Set node_child_info = EvalSet( param_references, NameBlock( Set param ) {
  NameBlock [[
     Text _.id_node = param[1],
     Text _.id_parameter = param[2],
     Real _.average = mean,
     Real _.sigma = sigma
  ]]
} );



// Miercoles, 2010/03/31 21:29:54.00
Set param_references = [[ [[ "nodeobs1", "param1" ]], [[ "nodeobs2", "param1" ]], [[ "nodeobs2", "param1" ]] ]];

Real mean = 1.0;
Real sigma = 0.1;

Set node_child_info = EvalSet( param_references, NameBlock( param ) {
  NameBlock [[
     Text _.id_node = param[1],
     Text _.id_parameter = param[2],
     Real _.average = mean,
     Real _.sigma = sigma
  ]]
} );



// Miercoles, 2010/03/31 21:29:48.00
Set param_references = [[ [[ "nodeobs1", "param1" ]], [[ "nodeobs2", "param1" ]], [[ "nodeobs2", "param1" ]] ]];

Real mean = 1.0;
Real sigma = 0.1;

Set node_child_info = EvalSet( param_references, NameBlock( param ) {
  NameBlock [[
     Text _.id_node = param[1],
     Text _.id_parameter = param[2],
     Real _.average = mean,
     Real _.sigma = sigma
  ]]
} );



// Miercoles, 2010/03/31 21:29:23.00
Set param_references = [[ [[ "nodeobs1", "param1" ]], [[ "nodeobs2", "param1" ]], [[ "nodeobs2", "param1" ]] ]];

Real mean = 1.0;
Real sigma = 0.1;

Set node_child_info = EvalSet( param_references, NameBlock( param_references ) {
  NameBlock [[
     Text _.id_node = param_references[1],
     Text _.id_parameter = parame_references[2],
     Real _.average = mean,
     Real _.sigma = sigma
  ]]
} );



// Miercoles, 2010/03/31 13:47:29.00
Set MMS::GetStoredModelsList(0)


// Miercoles, 2010/03/31 13:42:10.00
Set MMS::GetStoredModelsList(0)


// Miercoles, 2010/03/31 13:35:44.00
Set MMS::GetStoredModelsList(0)


// Miercoles, 2010/03/31 13:32:51.00
Text MMS::GetModelsPath(0)


// Miercoles, 2010/03/31 13:32:44.00
Set MMS::GetModelsPath(0)


// Miercoles, 2010/03/31 13:32:39.00
Set MMS::GetModelPath(0)


// Miercoles, 2010/03/31 13:32:18.00
MMS


// Lunes, 2010/03/29 15:20:00.00
Matrix _Mat1 = Gaussian( 100, 1, 0, 1 );
Matrix _Mat2 = Gaussian( 100, 2, 0, 1 );

Real MMS::CreateVariable( [[ Text _.name = "Mat1",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat1" ]] );

Real MMS::CreateVariable( [[ Text _.name = "Mat2",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat2" ]] );





// Lunes, 2010/03/29 15:14:20.00
MMS


// Lunes, 2010/03/29 15:05:43.00
    Text myChartID =
      TclChartSerie( all,
                     SetOfSet (
                              @TclArgSt("-title",    "Serie chart" )
                              //,@TclArgSt("-geometry", "814x692+1+1")
                              ));


// Lunes, 2010/03/29 15:04:19.00
      Set instances = EvalSet( SetOfSet(SetOfText("VariableA11",""),SetOfText("VariableA12",""),SetOfText("VariableA11.M",""),SetOfText("VariableA03","")), NameBlock( Set ref ) {
        NameBlock obj = MMS::GetVariable( ref );
        NameBlock PutLocalName( obj::GetName(0), obj )
      } );


    Set all = EvalSet( instances, Serie( NameBlock var ) {
        Serie aux = var::GetData( 0 );
        Serie PutName( var::GetName( 0 ), aux )
      } );



// Lunes, 2010/03/29 15:01:36.00
      Set all = EvalSet( SetOfSet(SetOfText("VariableA11",""),SetOfText("VariableA12",""),SetOfText("VariableA11.M",""),SetOfText("VariableA03","")), NameBlock( Set ref ) {
        NameBlock obj = MMS::GetVariable( ref );
        NameBlock PutLocalName( obj::GetName(0), obj )
      } );



// Lunes, 2010/03/29 14:55:36.00
      Set all = EvalSet( SetOfSet(SetOfText("VariableA11",""),SetOfText("VariableA12",""),SetOfText("VariableA11.M",""),SetOfText("VariableA03","")), NameBlock( Set ref ) {
        NameBlock obj = MMS::GetVariable( ref );
        NameBlock PutLocalName( obj::GetName(0), obj )
      } );
      // aplico el metodo de grup
      Text theClass = ClassOf(all[1]);



// Lunes, 2010/03/29 14:36:56.00
Anything obj = MMS::GetVariable( [[ "VariableA01", "" ]] );
Real obj::ChartGroup( [[ obj ]] );


// Lunes, 2010/03/29 14:36:27.00
Anything obj = MMS::GetVariable( [[ "VariableA01", "" ]] ); 


// Lunes, 2010/03/29 14:23:50.00
Code SetOfSet


// Lunes, 2010/03/29 11:34:11.00
@MMS.Model mod = MMS::GetModel( [["ModelA", "1" ]]);
Set mod::GetVariables(?);



// Lunes, 2010/03/29 11:32:01.00
MMS

// Lunes, 2010/03/29 11:31:25.00
@MMS.Model mod = MMS.GetModel( [["ModelA", "1" ]]);



// Viernes, 2010/03/26 19:19:52.00
Set __layer_mms_gui_tmp__ = LayerMMSGui::GetStoredModelsList( 0 )


// Viernes, 2010/03/26 19:16:21.00
Set MMS::GetStoredModelsList(0)


// Viernes, 2010/03/26 12:15:57.00
MMS

// Viernes, 2010/03/26 12:15:47.00
Matrix _Mat1 = Gaussian( 100, 1, 0, 1 );
Matrix _Mat2 = Gaussian( 100, 2, 0, 1 );

Real MMS::CreateVariable( [[ Text _.name = "Mat1",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat1" ]] );

Real MMS::CreateVariable( [[ Text _.name = "Mat2",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat2" ]] );




// Viernes, 2010/03/26 12:15:28.00



// Viernes, 2010/03/26 12:09:06.00
MMS


// Jueves, 2010/03/25 18:23:31.00
@MMS.ARIMAModel arima12 = @MMS.ARIMAModel::FromLabel("P1_7DIF0_1AR1_0MA0_7.14", 0);


// Jueves, 2010/03/25 13:08:24.00
MMS

// Jueves, 2010/03/25 13:08:17.00
Matrix _Mat1 = Gaussian( 100, 1, 0, 1 );
Matrix _Mat2 = Gaussian( 100, 2, 0, 1 );

Real MMS::CreateVariable( [[ Text _.name = "Mat1",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat1" ]] );

Real MMS::CreateVariable( [[ Text _.name = "Mat2",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat2" ]] );





// Jueves, 2010/03/25 13:06:25.00
MMS

  Matrix _Mat1 = Gaussian( 100, 1, 0, 1 );
Matrix _Mat2 = Gaussian( 100, 2, 0, 1 );

Real MMS::CreateVariable( [[ Text _.name = "Mat1",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat1" ]] );

Real MMS::CreateVariable( [[ Text _.name = "Mat2",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat2" ]] );



// Jueves, 2010/03/25 13:05:00.00
MMS



// Jueves, 2010/03/25 12:18:01.00
Text Tol_OpenEditor( Text contents ) {
  Set result = Tcl_Eval( "Editor::New" );
  Set Tcl_EvalEx( [[ "Editor::InsertText", result::result, contents ]] );
  Text result::result
};


Text Tol_OpenEditor( "Livan pa'lla" );




// Jueves, 2010/03/25 12:17:39.00
Text Tol_OpenEditor( Text contents ) {
  Set result = Tcl_Eval( "Editor::New" );
  Set Tcl_EvalEx( [[ "Editor::InsertText", result::result, contents ]] );
  Text result::result
};


Text Tol_OpenEditor( "Livan pa'lla" );




// Jueves, 2010/03/25 12:06:58.00
Set result = Tcl_Eval( "Editor::New" );

// Jueves, 2010/03/25 00:28:44.00
  Matrix _Mat1 = Gaussian( 100, 1, 0, 1 );
Matrix _Mat2 = Gaussian( 100, 2, 0, 1 );

Real MMS::CreateVariable( [[ Text _.name = "Mat1",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat1" ]] );

Real MMS::CreateVariable( [[ Text _.name = "Mat2",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat2" ]] );
NameBlock MMS


// Jueves, 2010/03/25 00:27:25.00
MMS

// Jueves, 2010/03/25 00:27:19.00
  Matrix _Mat1 = Gaussian( 100, 1, 0, 1 );
Matrix _Mat2 = Gaussian( 100, 2, 0, 1 );

Real MMS::CreateVariable( [[ Text _.name = "Mat1",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat1" ]] );

Real MMS::CreateVariable( [[ Text _.name = "Mat2",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat2" ]] );

MMS


// Jueves, 2010/03/25 00:25:35.00
MMS



// Jueves, 2010/03/25 00:25:26.00
  Matrix _Mat1 = Gaussian( 100, 1, 0, 1 );
Matrix _Mat2 = Gaussian( 100, 2, 0, 1 );

Real MMS::CreateVariable( [[ Text _.name = "Mat1",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat1" ]] );

Real MMS::CreateVariable( [[ Text _.name = "Mat2",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat2" ]] );



// Miercoles, 2010/03/24 23:47:11.00
MMS


// Miercoles, 2010/03/24 23:28:44.00
MMS


// Miercoles, 2010/03/24 23:23:04.00
MMS


// Miercoles, 2010/03/24 23:21:22.00
MMS


// Miercoles, 2010/03/24 23:15:53.00
/*NameBlock AA = [[
  Class @AA {
    Real aa = 1.0
  }
]];*/

// AA::@AA ee = [[ Real aa = 2.0 ]];

Text ClassOf( ee );



// Miercoles, 2010/03/24 23:15:33.00
/*NameBlock AA = [[
  Class @AA {
    Real aa = 1.0
  }
]];*/

AA::@AA ee = [[ Real aa = 2.0 ]];



// Miercoles, 2010/03/24 23:15:07.00
/*NameBlock AA = [[
  Class @AA {
    Real aa = 1.0
  }
]];*/

AA::@AA ee = [[ 2.0 ]];



// Miercoles, 2010/03/24 23:14:34.00
NameBlock AA = [[
  Class @AA {
    Real aa = 1.0
  }
]];


// Miercoles, 2010/03/24 21:51:30.00
Anything _any = MMS::_.variables[1];
Text ClassOf( _any);
Text Grammar( _any);


// Miercoles, 2010/03/24 21:51:19.00
Anything _any = MMS::_.variables[1];
Text ClassOf( _any);
Text Grammar( _any);


// Miercoles, 2010/03/24 19:07:05.00
Text ClassOf( MMS::_.variables[1]);
Text Grammar( MMS::_.variables[1]);


// Miercoles, 2010/03/24 19:07:02.00
MMS::_.variables[1]);

// Miercoles, 2010/03/24 18:58:58.00
Text ClassOf( MMS::_.variables[1]);



// Miercoles, 2010/03/24 18:58:42.00
MMS::_.variables[1]



// Miercoles, 2010/03/24 18:56:29.00
MMS



// Martes, 2010/03/23 20:53:17.00
MMS


// Martes, 2010/03/23 20:49:27.00
MMS


// Martes, 2010/03/23 20:47:16.00
MMS


// Lunes, 2010/03/01 14:45:16.00
Real MatQuantile( mv3g, 0.015 );

// Lunes, 2010/03/01 14:45:05.00
Real MatQuantile( mv3g, 0.02 );

// Lunes, 2010/03/01 14:44:58.00
Real MatQuantile( mv3g, 0.01 );

// Lunes, 2010/03/01 14:44:51.00
Real MatQuantile( mv3g, 0.05 );

// Lunes, 2010/03/01 14:44:41.00
Real MatQuantile( mv3g, 0.10 );

// Lunes, 2010/03/01 14:44:31.00
Real DBOpen( "tfnesprade3g", "tfnesp", "tfn!116." );
Set v3g = DBTable( "select 
         QT_VOL_DATOS_UMTS/(1024.0 * 1024.0)
  from table_modelo_nucleo_102009
  where QT_VOL_DATOS_UMTS > 0" );

Matrix mv3g = SetMat(v3g);
Real MatMax( mv3g );
Real MatQuantile( mv3g, 0.25 ); // 11



// Lunes, 2010/03/01 14:44:22.00
Real DBOpen( "tfnesprade3g", "tfnesp", "tfn!116." );
Set v3g = DBTable( "select 
         QT_VOL_DATOS_UMTS/(1024.0 * 1024.0)
  from table_modelo_nucleo_102009
  wher QT_VOL_DATOS_UMTS > 0" );

Matrix mv3g = SetMat(v3g);
Real MatMax( mv3g );
Real MatQuantile( mv3g, 0.25 ); // 11



// Lunes, 2010/03/01 14:43:43.00
Real MatQuantile( mv3g, 0.60 );

// Lunes, 2010/03/01 14:43:34.00
Real MatQuantile( mv3g, 0.75 );

// Lunes, 2010/03/01 14:43:26.00
Real MatQuantile( mv3g, 0.95 );

// Lunes, 2010/03/01 14:42:56.00
Matrix mv3g = SetMat(v3g);
Real MatMax( mv3g );
Real MatQuantile( mv3g, 0.50 ); // 11


// Lunes, 2010/03/01 14:42:05.00
Real DBOpen( "tfnesprade3g", "tfnesp", "tfn!116." );
Set v3g = DBTable( "select 
         QT_VOL_DATOS_UMTS/(1024.0 * 1024.0)
  from table_modelo_nucleo_102009" );

Real MatQuantile( SetMat(v3g), 0.50 ); // 11



// Lunes, 2010/03/01 14:41:46.00
Real DBOpen( "tfnesprade3g", "tfnesp", "tfn!116." );
Set v3g = DBTable( "select 
         QT_VOL_DATOS_UMTS/(1024 * 1024)
  from table_modelo_nucleo_102009" );

Real MatQuantile( SetMat(v3g), 0.50 ); // 11



// Lunes, 2010/03/01 14:40:58.00
Real DBOpen( "tfnesprade3g", "tfnesp", "tfn!116." );
Set v3g = DBTable( "select 
         QT_VOL_DATOS_UMTS/(1024 * 1024)
  from table_modelo_nucleo_102009" );

Real MatQuantile( SetMat(v3g), 0.25 ); // 11


// Lunes, 2010/03/01 14:40:50.00
Real DBOpen( "tfnesprade3g", "tfnesp", "tfn!116." );
Set v3g = DBTable( "select 
         QT_VOL_DATOS_UMTS/(1024 * 1024)
  from table_modelo_nucleo_102009" );

Real MatQuantile( SetMat(v3g), 0.25 ); // 11


// Lunes, 2010/03/01 14:40:28.00
Real DBOpen( "tfnesprade3g", "tfnesp", "tfn!116." );
Set v3g = DBTable( "select 
         QT_VOL_DATOS_UMTS_NUCLEO/(1024 * 1024)
  from table_modelo_nucleo_102009" );

Real MatQuantile( SetMat(v3g), 0.25 ); // 11



// Lunes, 2010/03/01 14:39:59.00
Set v3g = DBTable( "select 
         QT_VOL_DATOS_UMTS_NUCLEO/(1024 * 1024)
  from table_modelo_nucleo_102009" );

Real MatQuantile( SetMat(v3g), 0.25 );

// Lunes, 2010/03/01 11:43:10.00
Real MatQuantile( Exp(mm) - 1, 0.10 );

// Lunes, 2010/03/01 11:40:25.00
Real MatQuantile( mm, 0.10 );

// Lunes, 2010/03/01 11:37:30.00
Real MatQuantile( Exp(mm) - 1, 0.01 ); 
Real MatQuantile( Exp(mm) - 1, 0.05 );
Real MatQuantile( Exp(mm) - 1, 0.10 ); 
Real MatQuantile( Exp(mm) - 1, 0.20 ); 
Real MatQuantile( Exp(mm) - 1, 0.25 );

// Lunes, 2010/03/01 11:33:54.00
Real MatQuantile( Exp(mm) - 1, 0.01 ); 
Real MatQuantile( Exp(mm) - 1, 0.05 ); 
Real MatQuantile( Exp(mm) - 1, 0.20 ); 
Real MatQuantile( Exp(mm) - 1, 0.25 );

// Lunes, 2010/03/01 11:33:07.00
Real MatQuantile( Exp(mm) - 1, 0.01 ); 
Real MatQuantile( Exp(mm) - 1, 0.25 );

// Lunes, 2010/03/01 11:32:33.00
Matrix mmm = df_estim::GetColumn( "DENS_VOZ_MARKET" );

Real MatQuantile( mmm, 0.01 ); 
Real MatQuantile( mmm, 0.25 );

// Lunes, 2010/03/01 11:28:57.00
Real MatQuantile( mm, 0.01 );

// Lunes, 2010/03/01 11:28:41.00
Real MatQuantile( mm, 0.05 ); 

// Lunes, 2010/03/01 11:28:24.00
Real MatQuantile( mm, 0.10 ); 

// Lunes, 2010/03/01 11:28:07.00
Real MatQuantile( mm, 0.20 ); 
Real MatQuantile( mm, 0.25 );

// Lunes, 2010/03/01 11:27:42.00
Real MatQuantile( SetMat(mm), 0.20 ); 
Real MatQuantile( SetMat(mm), 0.25 );

// Lunes, 2010/03/01 11:27:17.00
Matrix mm = df_estim::GetColumn( "Log_DENS_VOZ_MARKET" );

Real MatQuantile( SetMat(market), 0.20 );

Real MatQuantile( SetMat(market), 0.25 );

// Lunes, 2010/03/01 11:22:09.00
Real MatQuantile( SetMat(market), 0.25 );

// Lunes, 2010/03/01 11:21:45.00
Real DBOpen( "tfnesprade3g", "tfnesp", "tfn!116." );

Set market = DBTable( "select 
         qt_poblacion+2*qt_rtb_total as market
  from table_modelo_nucleo_102009" );

Real MatQuantile( SetMat(market), 0.2 );

// Domingo, 2010/02/28 23:35:04.00
Code MatSet

// Domingo, 2010/02/28 22:48:16.00
Matrix mm = Diag( 9, 1 );
Set MatSet( mm );

// Domingo, 2010/02/28 22:47:53.00
Matrix Diag( 9, 1 );


// Domingo, 2010/02/28 22:47:21.00
Matrix Diag( 8, 1 );


// Domingo, 2010/02/28 21:45:28.00
Set data_pred = variable_info::build_data_fore( variable_info::fore_args );
Set proxy_predictors = getOptArg( args, "proxy_predictors", Copy( Empty ) );

Real If( Not( Card( data_pred ) ), {
    Error( "No hay datos para predecir" );
    Real Stop
  } );

NameBlock df_pred = data_pred[ 1 ];
Set forecast = ForecastFromEstim( estim[ 1 ], df_pred, proxy_predictors );
Text output_name = (models[ 1 ])::_.output.name;
Text header = JoinTexts( [[ df_pred::GetObsIdColumnName(?),
                            Sub( output_name, 5, TextLength( output_name ) ),
                            output_name ]] <<
                         forecast::predictors, ";" );

Text file_export = TmpDir + "cnuc_fore_" + variable + ".csv";
Set BMTFile([[ forecast::ID | forecast::Yhat1 | forecast::Yhat0 | forecast::X ]],
            file_export,
            header, CIERTO, ";", "\n" );
WriteLn( "La prediccion ha sido exportada a " + file_export );

// Domingo, 2010/02/28 21:45:02.00
Set data_pred = variable_info::build_data_fore( variable_info::fore_args );
Set proxy_predictors = getOptArg( args, "proxy_predictors", Copy( Empty ) );

Real If( Not( Card( data_pred ) ), {
    Error( "No hay datos para predecir" );
    Real Stop
  } );

NameBlock df_pred = data_pred[ 1 ];
Set forecast = ForecastFromEstim( estim[ 1 ], df_pred, proxy_predictors );
Text output_name = (models[ 1 ])::_.output.name;
Text header = JoinTexts( [[ df_pred::GetObsIdColumnName(?),
                            Sub( output_name, 5, TextLength( output_name ) ),
                            output_name ]] <<
                         forecast::predictors, ";" );

Text file_export = TmpDir + "cnuc_fore_" + variable + ".csv";
Set BMTFile([[ forecast::ID | forecast::Yhat1 | forecast::Yhat0 | forecast::X ]],
            file_export,
            header, CIERTO, ";", "\n" );
WriteLn( "La prediccion ha sido exportada a " + file_export );

/

// Domingo, 2010/02/28 20:57:46.00
Set data_pred = variable_info::build_data_fore( variable_info::fore_args );

Real If( Not( Card( data_pred ) ), {
    Error( "No hay datos para predecir" );
    Real Stop
  } );

NameBlock df_pred = data_pred[ 1 ];
Set forecast = ForecastFromEstim( estim[ 1 ], df_pred );
Text output_name = (models[ 1 ])::_.output.name;
Text header = JoinTexts( [[ df_pred::GetObsIdColumnName(?),
                            Sub( output_name, 5, TextLength( output_name ) ),
                            output_name ]] <<
                         forecast::predictors, ";" );

Text file_export = TmpDir + "cnuc_fore_" + variable + ".csv";
Set BMTFile([[ forecast::ID | forecast::Yhat1 | forecast::Yhat0 | forecast::X ]],
            file_export,
            header, CIERTO, ";", "\n" );
WriteLn( "La prediccion ha sido exportada a " + file_export );


// Domingo, 2010/02/28 18:13:39.00
Real Log( 125 );

// Domingo, 2010/02/28 18:13:27.00
Real Log( 413 );

// Domingo, 2010/02/28 18:04:13.00
Real DBOpen( "tfnesprade3g", "tfnesp", "tfn!116." );
Set den_voz_linea = DBTable(
    "select 
         (qt_duracion_voz_gprs + qt_duracion_voz_umts)/(qt_lineas_voz_gprs + qt_lineas_voz_umts) as dens_voz_linea
  from table_modelo_nucleo_102009
  where qt_lineas_voz_gprs + qt_lineas_voz_umts>0
  order by dens_voz_linea" );

Real MatQuantile( SetMat(den_voz_linea), 0.1 ); 

Real Log( 830 );



// Domingo, 2010/02/28 17:59:17.00
Set den_voz = DBTable(
    "select 
         (qt_duracion_voz_gprs + qt_duracion_voz_umts)/(qt_lineas_voz_gprs + qt_lineas_voz_umts) as dens_voz_linea
  from table_modelo_nucleo_102009
  where qt_lineas_voz_gprs + qt_lineas_voz_umts>0
  order by dens_voz_linea" );

Real MatQuantile( SetMat(den_voz), 0.2 ); 

// Domingo, 2010/02/28 17:58:59.00
Set den_voz = DBTable(
    "select 
         (qt_duracion_voz_gprs + qt_duracion_voz_umts)/(qt_lineas_voz_gprs + qt_lineas_voz_umts) as dens_voz_linea
  from table_modelo_nucleo_102009
  where qt_lineas_voz_gprs + qt_lineas_voz_umts>0
  order by dens_voz_linea" );

Real MatQuantile( SetMat(den_voz), 0.2 ); 

// Domingo, 2010/02/28 17:54:21.00
Set den_voz = DBTable( "  select 
         (qt_duracion_voz_gprs + qt_duracion_voz_umts)/(qt_duracion_voz_gprs + qt_duracion_voz_umts) as dens_voz_linea
  from table_modelo_nucleo_102009
  where qt_duracion_voz_gprs + qt_duracion_voz_umts>0
  order by dens_voz_linea" );

Real MatQuantile( SetMat(den_voz), 0.2 ); 

Real Log( 830 );

// Domingo, 2010/02/28 17:54:12.00
Real DBOpen( "tfnesprade3g", "tfnesp", "tfn!116." );

// Domingo, 2010/02/28 17:53:03.00
Set den_voz = DBTable( "  select 
         (qt_duracion_voz_gprs + qt_duracion_voz_umts)/(qt_duracion_voz_gprs + qt_duracion_voz_umts) as dens_voz_linea
  from table_modelo_nucleo_102009
  where qt_duracion_voz_gprs + qt_duracion_voz_umts>0
  order by dens_voz_linea" );

Real MatQuantile( SetMat(den_voz), 0.2 ); 

Real Log( 830 );



// Domingo, 2010/02/28 17:51:51.00
Set den_voz = DBTable( "  select 
         (qt_duracion_voz_gprs + qt_duracion_voz_umts)/(qt_duracion_voz_gprs + qt_duracion_voz_umts) as dens_voz_linea
  from table_modelo_nucleo_102009
  where qt_duracion_voz_gprs + qt_duracion_voz_umts>0
  order by dens_voz_linea" );

Real MatQuantile( SetMat(den_voz), 0.2 ); 

Real Log( 830 );



// Domingo, 2010/02/28 17:51:41.00
qt_duracion_voz_gprs + qt_duracion_voz_umts

// Domingo, 2010/02/28 17:11:53.00
Real Log( 830 );

// Domingo, 2010/02/28 17:08:05.00
Real 56133 * 0.20

// Domingo, 2010/02/28 17:07:21.00
Real MatQuantile( SetMat(den_voz), 0.2 ); 

// Domingo, 2010/02/28 17:06:44.00
Real SetQuantile( den_voz, 0.2 );

// Domingo, 2010/02/28 17:06:37.00
Real SetQuantile( dens_voz, 0.2 ); 


// Domingo, 2010/02/28 17:04:17.00
Set den_voz = DBTable( "  select 
         (qt_duracion_voz_gprs + qt_duracion_voz_umts)/(qt_poblacion+2*qt_rtb_total) as dens_voz
  from table_modelo_nucleo_102009
  where qt_duracion_voz_gprs + qt_duracion_voz_umts>0
  order by dens_voz" );


// Domingo, 2010/02/28 14:32:25.00
Set data_estim::df::ExtractByValueInColumn( "TIPOL_MUNI" );

// Domingo, 2010/02/28 14:31:50.00
Set df::ExtractByValueInColumn( "TIPOL_MUNI" );


// Sabado, 2010/02/27 09:43:05.00
Matrix cc = df_estim::GetColumn( "Log_COMPETENCIA" );
Matrix fcc = Frequency( cc, 100 );


// Viernes, 2010/02/26 12:48:27.00
Text EncodingCheckAll( Text src )
{
  Text cmd = "foreach e [encoding names] { Tol_HciWriter \"$e : [encoding convertfrom $e "+"\""+src+"\"]\n\"};";
  Set result = Tcl_Eval( cmd ); 
  Text result::result
};


Text EncodingCvt( Text src, Text enc )
{
  Set cmd = If( enc == "",
                [[ "encoding", "convertfrom", src ]],
                [[ "encoding", "convertfrom", enc, src ]] );
  Set result = Tcl_EvalEx( cmd ); 
  Text result::result
};

Text EncodingCvt( "Comunidades AutÃ³nomas, PaÃ s Vasco","" );



// Viernes, 2010/02/26 12:48:16.00
Text EncodingCheckAll( Text src )
{
  Text cmd = "foreach e [encoding names] { Tol_HciWriter \"$e : [encoding convertfrom $e "+"\""+src+"\"]\n\"};";
  Set result = Tcl_Eval( cmd ); 
  Text result::result
};


Text EncodingCvt( Text src, Text enc )
{
  Set cmd = If( enc == "",
                [[ "encoding", "convertfrom", src ]],
                [[ "encoding", "convertfrom", enc, src ]] );
  Set result = Tcl_EvalEx( cmd ); 
  Text result::result
};

Text EncodingCvt( "Comunidades AutÃ³nomas, PaÃ s Vasco" );

// Viernes, 2010/02/26 12:41:44.00
Text EncodingCvt( Text src )
{
  Text cmd = "foreach e [encoding names] { Tol_HciWriter \"$e : [encoding convertfrom $e "+"\""+src+"\"]\n\"};";
  Set result = Tcl_Eval( cmd ); 
  Text result::result
};

Text EncodingCvt( "Comunidades AutÃ³nomas, PaÃ s Vasco" );



// Viernes, 2010/02/26 12:41:16.00
Text EncodingCvt( Text src )
{
  Text cmd = "foreach e [encoding names] { Tol_HciWriter \"[encoding convertfrom $e "+"\""+src+"\"]\n\"};";
  Set result = Tcl_Eval( cmd ); 
  Text result::result
};

Text EncodingCvt( "Comunidades AutÃ³nomas, PaÃ s Vasco" );



// Viernes, 2010/02/26 12:40:34.00
Text EncodingCvt( Text src )
{
  Text cmd = "foreach e [encoding names] { Tol_HciWriter [encoding convertfrom $e "+"\""+src+"\"]};";
  Set result = Tcl_Eval( cmd ); 
  Text result::result
};

Text EncodingCvt( "Comunidades AutÃ³nomas, PaÃ s Vasco" );



// Viernes, 2010/02/26 12:40:25.00
Text EncodingCvt( Text src )
{
  Text cmd = "foreach e [encoding names] { Tol_HCiWriter [encoding convertfrom $e "+"\""+src+"\"]};";
  Set result = Tcl_Eval( cmd ); 
  Text result::result
};

Text EncodingCvt( "Comunidades AutÃ³nomas, PaÃ s Vasco" );



// Viernes, 2010/02/26 12:37:41.00
Text EncodingCvt( Text src )
{
  Text cmd = "foreach e [encoding names] { lappend ::result [encoding convertfrom $e "+"\""+src+"\"]}; set ::result";
  Set result = Tcl_Eval( cmd ); 
  Text result::result
};

Text EncodingCvt( "Comunidades AutÃ³nomas, PaÃ s Vasco" );


// Viernes, 2010/02/26 12:37:32.00
Text EncodingCvt( Text src )
{
  Text cmd = "foreach e [encoding names] { lappend ::result [encoding convertfrom $e "+"\""+src+"\"]}; set result";
  Set result = Tcl_Eval( cmd ); 
  Text result::result
};

Text EncodingCvt( "Comunidades AutÃ³nomas, PaÃ s Vasco" );


// Viernes, 2010/02/26 12:37:21.00
Text EncodingCvt( Text src )
{
  Text cmd = "foreach e [encoding names] { lappend ::result [encoding convertfrom $e "+"\""+src+"\"]}";
  Set result = Tcl_Eval( cmd ); 
  Text result::result
};

Text EncodingCvt( "Comunidades AutÃ³nomas, PaÃ s Vasco" );


// Viernes, 2010/02/26 12:35:30.00
Text EncodingCvt( Text src )
{
  Set cmd = [[ "foreach", "e", "[encoding names]", "{ lappend ::result [encoding convertfrom $e "+"\""+src+"\"]}" ]];
  Set result = Tcl_EvalEx( cmd ); 
  Text result::result
};

Text EncodingCvt( "Comunidades AutÃ³nomas, PaÃ s Vasco" );


// Viernes, 2010/02/26 12:34:58.00
Text EncodingCvt( Text src )
{
  Set cmd = [[ "foreach", "e [encoding names] { lappend ::result [encoding convertfrom $e "+"\""+src+"\"]}" ]];
  Set result = Tcl_EvalEx( cmd ); 
  Text result::result
};

Text EncodingCvt( "Comunidades AutÃ³nomas, PaÃ s Vasco" );


// Viernes, 2010/02/26 12:34:48.00
Text EncodingCvt( Text src )
{
  Set cmd = [[ "foreach", "e [encoding names] { lappend ::result [encoding convertfrom $e "+"\""+src"\"]}" ]];
  Set result = Tcl_EvalEx( cmd ); 
  Text result::result
};

Text EncodingCvt( "Comunidades AutÃ³nomas, PaÃ s Vasco" );


// Viernes, 2010/02/26 12:13:05.00
Text EncodingCvt( Text src )
{
  Set cmd = [[ "encoding", "convertfrom", "utf-8", src ]];
  Set result = Tcl_EvalEx( cmd ); 
  Text result::result
};

Text EncodingCvt( "Comunidades AutÃ³nomas, PaÃ s Vasco" );


// Viernes, 2010/02/26 12:12:54.00
Text EncodingCvt( Text src )
{
  Set cmd = [[ "encoding", "convertfrom", "utf-8" src ]];
  Set result = Tcl_EvalEx( cmd ); 
  Text result::result
};

Text EncodingCvt( "Comunidades AutÃ³nomas, PaÃ s Vasco" );


// Viernes, 2010/02/26 12:11:34.00
Text EncodingCvt( "Comunidades AutÃ³nomas, PaÃ s Vasco" );

// Viernes, 2010/02/26 12:10:32.00
Text EncodingCvt( Text src )
{
  Set cmd = [[ "encoding", "convertfrom", src ]];
  Set result = Tcl_EvalEx( cmd ); 
  Text result::result
};

Text EncodingCvt( "Comunidades AutÃ³nomas" );

// Viernes, 2010/02/26 12:09:22.00
Set EncodingCvt( Text src )
{
  Set cmd = [[ "encoding", "convertfrom", src ]];
  Set result = Tcl_EvalEx( cmd ); 
  Set result
};

Set EncodingCvt( "Comunidades AutÃ³nomas" );


// Lunes, 2010/02/15 10:47:26.00
#Require MatQuery;
Matrix KK = Rand(3,1,0,1) << Constant( 2,1,? ) << Rand(2,1,0,1)<< Constant(1,1,?)<<Rand(3,1,0,1);
VMatrix kn = MatQuery::MatchRowsFullKnown( Mat2VMat( KK ) );
Set sel = MatQuery::SelectRowsWithValue( kn, True );


// Lunes, 2010/02/15 10:46:23.00
#Require MatQuery;
Matrix KK = Rand(3,1,0,1) << Constant( 2,1,? ) << Rand(2,1,0,1)<< Constant(1,1,?)<<Rand(3,1,0,1);
VMatrix kn = MatQuery::MatchRowsFullKnown( Mat2VMat( KK ) );


// Lunes, 2010/02/15 10:45:37.00
#Require MatQuery;
Matrix KK = Rand(3,1,0,1) << Constant( 2,1,? ) << Rand(2,1,0,1)<< Constant(1,1,?)<<Rand(3,1,0,1);


// Lunes, 2010/02/15 10:45:12.00
Matrix KK = Rand(3,1,0,1) << Constant( 2,1,? ) << Rand(2,1,0,1)<< Constant(1,1,?)<<Rand(3,1,0,1);


// Jueves, 2010/02/11 18:19:09.00
Set triplet1 = {Set Include( "triplet.oza" )[1]};

Set uniqueTriple = Classify( triplet1, Real( Set a, Set b ) { 
    Real cmp1 = Compare(a[1],b[1]);
    If( cmp1, cmp1, Compare( a[2],b[2] ) )
 } );

Real M = SetMax( EvalSet( triplet1, Real( Set t ) { t[1] } ) );
Real N = SetMax( EvalSet( triplet1, Real( Set t ) { t[2] } ) );

Real ckeck1 = Eq( Card( uniqueTriple ), Card( triplet1 ) );

Real check2 = If( ckeck1, {
    VMatrix A1 = Convert( Triplet( triplet1, M, N ), "Cholmod.R.Sparse" );
    VMatrix A2 = Convert( TripletUnique( SetMat(triplet1), M, N ), "Cholmod.R.Sparse" );
    VMatrix diff = A1 - A2;
    Real VMatMax( diff )
  }, 0 ); 


// Jueves, 2010/02/11 18:18:33.00
Set triplet1 = {Set Include( "triplet.oza" )[1]};

Set uniqueTriple = Classify( triplet1, Real( Set a, Set b ) { 
    Real cmp1 = Compare(a[1],b[1]);
    If( cmp1, cmp1, Compare( a[2],b[2] ) )
 } );

Real M = SetMax( EvalSet( triplet1, Real( Set t ) { t[1] } ) );
Real N = SetMax( EvalSet( triplet1, Real( Set t ) { t[2] } ) );

Real ckeck1 = Eq( Card( uniqueTriple ), Card( triplet1 ) );

Real check2 = If( check1, {
    VMatrix A1 = Convert( Triplet( triplet1, M, N ), "Cholmod.R.Sparse" );
    VMatrix A2 = Convert( TripletUnique( SetMat(triplet1), M, N ), "Cholmod.R.Sparse" );
    VMatrix diff = A1 - A2;
    Real VMatMax( diff )
  }, 0 ); 


// Jueves, 2010/02/11 18:15:03.00
TripletUnique( SetMat(triplet1), M, N )

// Jueves, 2010/02/11 18:14:13.00
TripletUnique( triplet1, M, N )

// Jueves, 2010/02/11 18:11:39.00
Triplet( triplet1, M, N )

// Jueves, 2010/02/11 18:10:44.00
Set triplet1 = {Set Include( "triplet.oza" )[1]};
Set uniqueTriple = Classify( triplet1, Real( Set a, Set b ) { 
    Real cmp1 = Compare(a[1],b[1]);
    If( cmp1, cmp1, Compare( a[2],b[2] ) )
 } );

Real M = SetMax( EvalSet( triplet1, Real( Set t ) { t[1] } ) );
Real N = SetMax( EvalSet( triplet1, Real( Set t ) { t[2] } ) );

// Jueves, 2010/02/11 18:04:03.00
Set tt = {Set Include( "triplet.oza" )[1]};
Set uniqueTriple = Classify( tt, Real( Set a, Set b ) { 
    Real cmp1 = Compare(a[1],b[1]);
    If( cmp1, cmp1, Compare( a[2],b[2] ) )
 } ); 


// Jueves, 2010/02/11 18:02:27.00
Set tt = {Set Include( "triplet.oza" )[1]};
Set uniqueTriple = Classify( tt, Real( Set a, Set b ) { And(Eq(a[1],b[1]),Eq(a[2],b[2])) }, "equivalence" ); 


// Jueves, 2010/02/11 18:01:53.00
Set tt = {Set Include( "triplet.oza" )[1]};
Set uniqueTriple = Classify( tt, Real( Set a, Set b ) { And(Eq(a[1],b[1]),Eq(a[2],b[2])) }, "symmetric" ); 


// Jueves, 2010/02/11 18:00:50.00
Set tt = {Set Include( "triplet.oza" )[1]};
Set uniqueTriple = Classify( tt, Real( Set a, Set b ) { And(Eq(a[1],b[1]),Eq(a[2],b[2])) } ); 


// Jueves, 2010/02/11 17:58:21.00
Set tt = {Set Include( "triplet.oza" )[1]};


// Jueves, 2010/02/11 17:57:22.00
tmp = Include( "triplet.oza" );

// Jueves, 2010/02/11 17:56:58.00
VMatrix tt = {Set tmp = Include( "triplet.oza" ); VMatrix tmp[1]};


// Jueves, 2010/02/11 17:56:30.00
VMatrix tt = {(Set Include( "triplet.oza" ))[1]};


// Jueves, 2010/02/11 17:56:11.00
VMatrix tt = {Set Include( "triplet.oza" )[1]};


// Jueves, 2010/02/11 17:55:54.00
VMatrix tt = {Include( "triplet.oza" )[1]};


// Jueves, 2010/02/11 17:55:06.00
Set TT = Include( "/tmp/triplet1.oza" );
Real Ois.Store( [[ TT[1] ]], "/tmp/triplet.oza" );


// Jueves, 2010/02/11 16:47:28.00
Set TT = Include( "/tmp/triplet.oza" );


// Jueves, 2010/02/11 09:52:36.00
  Matrix _Mat1 = Gaussian( 100, 1, 0, 1 );
Matrix _Mat2 = Gaussian( 100, 2, 0, 1 );

Real MMS::CreateVariable( [[ Text _.name = "Mat1",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat1" ]] );

Real MMS::CreateVariable( [[ Text _.name = "Mat2",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat2" ]] );


// Jueves, 2010/02/11 09:50:26.00
  Matrix _Mat1 = Gaussian( 100, 1, 0, 1 );
Matrix _Mat2 = Gaussian( 100, 2, 0, 1 );

Real MMS::CreateVariable( [[ Text _.name = "Mat1",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat1" ]] );

Real MMS::CreateVariable( [[ Text _.name = "Mat2",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat2" ]] );


// Jueves, 2010/02/11 09:48:03.00
Matrix _Mat1 = Gaussian( 100, 1, 0, 1 );
Matrix _Mat2 = Gaussian( 100, 2, 0, 1 );

Real MMS::CreateVariable( [[ Text _.name = "Mat1",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat1" ]] );

Real MMS::CreateVariable( [[ Text _.name = "Mat2",
                             Text _.grammar = "Matrix",
                             Text _.expression = "Matrix _Mat2" ]] );


// Jueves, 2010/02/11 09:17:38.00
Text ClassOf( vv );

// Jueves, 2010/02/11 09:17:23.00
NameBlock vv = MMS::GetVariable( "VariableA01" );


// Jueves, 2010/02/11 09:16:59.00
NameBlock vv = MMS.GetVariable( "VariableA01" );


// Jueves, 2010/02/11 08:45:53.00
NameBlock MMS;


// Miercoles, 2010/02/10 21:24:01.00
NameBlock MMS


// Martes, 2010/02/09 15:16:41.00
Matrix C = Col( 1,2 ,3,4);
Set MatSet( C );



// Martes, 2010/02/09 15:16:25.00
Matrix C = Col( 1,2 ,3,4);



// Martes, 2010/02/09 15:16:20.00
Matrix C = Column( 1,2 ,3,4);



// Martes, 2010/02/09 14:51:48.00
Set [[ [["a", 1, 2, 3 ]], [["b"]] ]]


// Lunes, 2010/02/08 15:25:20.00
Real Ois.Store( [[ model ]], "/tmp/one_node_Canarias.oza" );


// Lunes, 2010/02/08 14:55:21.00
Real Ois.Store( [[ model ]], "one_node_Canarias.oza" );


// Lunes, 2010/02/08 14:45:40.00
Real Ois.Store( [[ bsr.oneNode.data ]], "one_node_Canarias.oza" );


// Lunes, 2010/02/08 14:45:28.00
Real Ois.Store( [[ bsr.oneNode.data_Canarias ]], "one_node_Canarias.oza" );


// Lunes, 2010/02/08 13:17:34.00
RunEstimation

// Lunes, 2010/02/08 13:15:30.00
Real Ois.Store( [[ dstr3 ]], "/tmp/dstr3_Canarias.oza" );


// Lunes, 2010/02/08 12:23:05.00
Real Ois.Store( [[ bsr.oneNode.data ]], "big_one_node.oza" );


// Lunes, 2010/02/08 12:02:08.00
Set cluster = dstr::Clusters[ 1 ];


// Lunes, 2010/02/08 12:01:55.00
Set cluster = (dstr::Clusters)[ index ];


// Lunes, 2010/02/08 12:01:46.00
Set cluster = dstr::Clusters[ index ];


// Domingo, 2010/02/07 17:24:26.00
Real -Inf


// Domingo, 2010/02/07 17:24:20.00
Real +Inf


// Sabado, 2010/02/06 08:42:25.00

Matrix AvrByColumns( result04::Y_nuc_cmp );
Matrix AvrByColumns( result04::Y_bts_cmp );

// Sabado, 2010/02/06 08:39:32.00
Set kkk = Include( "/tmp/dstr3.oza" );
Set result04 = Test04( dstr3, 1 );


// Sabado, 2010/02/06 01:38:21.00
Real Ois.Store( [[ dstr3 ]], cwd + "dstr3_cluster5.oza" );


// Sabado, 2010/02/06 00:56:44.00
Text file.data = path + "/cluster_infoSpain.ois";
NameBlock tm3 = Timer::Start( "Writing " + file.data );
Real Ois.Store( [[ clusterInfo ]], file.data );
Real tm3::Finish( 0 );



// Sabado, 2010/02/06 00:52:13.00
Text file.data = path + "cluster_infoSpain.ois";
NameBlock tm3 = Timer::Start( "Writing " + file.data );
Real Ois.Store( [[ clusterInfo ]], file.data );
Real tm3::Finish( 0 );



// Sabado, 2010/02/06 00:21:24.00
Set aux = [[1,2]];
Set PutName( "kkk", aux);


// Sabado, 2010/02/06 00:20:07.00
Set PutName( "kkk", [[1,2]]);


// Viernes, 2010/02/05 23:50:46.00
Real DirExist( "/tmp/" );

// Viernes, 2010/02/05 23:50:39.00
Real DirExist( "/tmp/kk.oza" );

// Viernes, 2010/02/05 23:49:06.00
Set aa = Include( "/tmp/kk.oza" );


// Viernes, 2010/02/05 23:45:34.00
Real Ois.Store( [[ clusters ]], "/tmp/kk.oza" ); 


// Miercoles, 2010/02/03 20:25:36.00
Real Ois.Store( [[ ExtractByIndex( result05, [[ 1, 2, 3 ]] ) ]], "/tmp/forefit_cluster2.oza" );

// Miercoles, 2010/02/03 20:20:09.00
Y_nuc  - A*Y_bts;

Matrix sorted_prevs_abs_diff =  {
  Matrix sort = Sort( prevs_abs_diff, [[ 1 ]] );
  Matrix PivotByRows( prevs_abs_diff, sort )
  }; 
Matrix sorted_prevs_rel_diff =  {
  Matrix sort = Sort( prevs_rel_diff, [[ 1 ]] );
  Matrix PivotByRows( prevs_rel_diff, sort )
  };


// Miercoles, 2010/02/03 20:18:43.00
Set result05 = Test05( dstr3, 2 );


// Miercoles, 2010/02/03 20:14:15.00
Set result05 = Test05( dstr3, 2 );


// Miercoles, 2010/02/03 20:10:49.00
Set result05 = Test05( dstr3, 2 );


// Miercoles, 2010/02/03 19:56:43.00
Set result05 = Test05( dstr3, 2 );


// Miercoles, 2010/02/03 19:51:51.00
Set result05 = Test05( dstr3, 2 );


// Miercoles, 2010/02/03 11:25:21.00
Real Ois.Store( [[ ExtractByIndex( result05, [[ 1, 2, 3 ]] ) ]], "/tmp/forefit_cluster2.oza" );

// Miercoles, 2010/02/03 11:24:48.00
Real Ois.Store( [[ Extract( result05, 1, 2, 3 ) ]], "/tmp/forefit_cluster2.oza" );

// Miercoles, 2010/02/03 11:24:28.00
Real Ois.Store( [[ Extract( result05, 1, 2, 3 ) ]], "/tmp/forefit_cluster2.oza" );

// Miercoles, 2010/02/03 11:24:16.00
Set result05 = Test05( dstr3, 2 );

Real Ois.Store( [[ Extract( result05, 1, 2, 3 ) ]], "/tmp/forefit_cluster2.oza" );


// Miercoles, 2010/02/03 11:22:39.00
Real Ois.Store( [[ result05 ]], "/tmp/forefit_cluster2.oza" );

// Miercoles, 2010/02/03 11:13:52.00
Set result05 = Test05( dstr3, 2 );


// Miercoles, 2010/02/03 09:55:22.00
Set result04 = Test04( dstr3, 2 );
Matrix AvrByColumns( result04::Y_nuc_cmp );
Matrix AvrByColumns( result04::Y_bts_cmp );


// Miercoles, 2010/02/03 09:49:46.00
Set result04 = Test05( dstr3, 2 );


// Miercoles, 2010/02/03 09:38:14.00
Real cnuc := 35016002401;
Text id_nuc = FormatReal( cnuc, "%0.f" );

Real idx_nuc = FindIndexByName( Nucleos, id_nuc );


// Miercoles, 2010/02/03 09:38:00.00
Real cnuc = 35016002401;
Text id_nuc = FormatReal( cnuc, "%0.f" );

Real idx_nuc = FindIndexByName( Nucleos, id_nuc );


// Miercoles, 2010/02/03 09:37:44.00
Real cnuc = 35016002401;
Text id_nuc = FormatReal( cnuc, "%0.f" );

Real idx_nuc = FindIndexByName( Nucleos, id_nuc );


// Miercoles, 2010/02/03 09:37:38.00
Real cnuc = 35016002401
Text id_nuc = FormatReal( cnuc, "%0.f" );

Real idx_nuc = FindIndexByName( Nucleos, id_nuc );


// Martes, 2010/02/02 19:57:16.00
Set result04 = Test05( dstr3, 2 );


// Martes, 2010/02/02 19:30:30.00
Set result04 = Test05( dstr3, 2 );


// Martes, 2010/02/02 19:26:07.00
Set result04 = Test05( dstr3, 2 );


// Martes, 2010/02/02 19:22:38.00
Set result04 = Test05( dstr3, 2 );


// Martes, 2010/02/02 19:16:34.00
Set result04 = Test05( dstr3, 2 );


// Martes, 2010/02/02 19:10:25.00
Set result04 = Test05( dstr3, 2 );


// Martes, 2010/02/02 19:01:52.00
Set result04 = Test05( dstr3, 2 );


// Martes, 2010/02/02 18:49:47.00
Set result05 = Test05( dstr3, 2 );


// Martes, 2010/02/02 18:47:49.00
Set result05 = Test05( dstr3, 2 );


// Martes, 2010/02/02 18:46:48.00
Set result05 = Test05( dstr3, 2 );


// Martes, 2010/02/02 18:26:51.00
Set result04 = Test04( dstr3, 2 );
Matrix AvrByColumns( result04::Y_nuc_cmp );
Matrix AvrByColumns( result04::Y_bts_cmp );

// Martes, 2010/02/02 18:26:10.00
Set result04 = Test04( dstr3, 2 );
Matrix AvrByColumns( result04::Y_nuc_cmp );
Matrix AvrByColumns( result04::Y_bts_cmp );

// Martes, 2010/02/02 18:25:50.00
Set result04 = Test04( dstr3, 2 );
Matrix AvrByColumns( result04::Y_nuc_cmp );
Matrix AvrByColumns( result04::Y_bts_cmp );

// Martes, 2010/02/02 18:17:09.00
Set result04 = Test04( dstr3, 2 );
Matrix AvrByColumns( result04::Y_nuc_cmp );
Matrix AvrByColumns( result04::Y_bts_cmp );

// Martes, 2010/02/02 18:11:46.00
Set result04 = Test04( dstr3, 2 );
Matrix AvrByColumns( result04::Y_nuc_cmp );
Matrix AvrByColumns( result04::Y_bts_cmp );


// Martes, 2010/02/02 18:10:29.00
 

// Martes, 2010/02/02 18:10:24.00
 

// Martes, 2010/02/02 18:09:07.00
Set result04 = Test04( dstr3, 2 );


Matrix AvrByColumns( result04::Y_nuc_cmp );
Matrix AvrByColumns( result04::Y_bts_cmp );


// Martes, 2010/02/02 18:06:18.00
Set result04 = Test04( dstr3, 2 );


Matrix AvrByColumns( result04::Y_nuc_cmp );
Matrix AvrByColumns( result04::Y_bts_cmp );


// Martes, 2010/02/02 18:06:07.00
Matrix AvrByColumns( result04::Y_nuc_cmp );
Matrix AvrByColumns( result04::Y_bts_cmp );

// Martes, 2010/02/02 18:04:00.00
Set Test04( dstr3, 2 );





// Martes, 2010/02/02 17:51:40.00
Set result04 = Test04( dstr3, 2 );

Matrix AvrByColumns( result04::Y_nuc_cmp );
Matrix AvrByColumns( result04::Y_bts_cmp );


// Martes, 2010/02/02 17:49:41.00
Set Test04( dstr3, 2 );


// Martes, 2010/02/02 17:47:50.00
Set Test04( dstr3, 2 );


// Martes, 2010/02/02 17:46:53.00
Set Test04( dstr3, 2 );


// Martes, 2010/02/02 17:30:39.00
Set Test04( dstr3, 2 );


// Martes, 2010/02/02 17:30:31.00
Set Test04( dstr3, 2 );


// Martes, 2010/02/02 17:22:49.00
Set Test04( dstr3, 2 );


// Martes, 2010/02/02 17:20:23.00
Set Test04( dstr3, 2 );

// Martes, 2010/02/02 17:16:16.00
Set Test04( dstr3, 2 );


// Martes, 2010/02/02 17:14:30.00
Set Test04( dstr3, 2 );


// Martes, 2010/02/02 17:07:14.00
Set Test04( dstr3, 2 );


// Martes, 2010/02/02 17:07:05.00
Set Test_04( dstr3, 2 );


// Martes, 2010/02/02 17:04:02.00
Set Test04( dstr3, 2 );

// Martes, 2010/02/02 17:03:20.00
Set dstr3::Clusters := Clusters3;

// Martes, 2010/02/02 17:03:09.00
Set dstr3 = Copy( dstr1 );
Set dstr3::Clusters = Clusters3;

// Martes, 2010/02/02 17:00:52.00
Set Test04( Set dstr3, Real idx_cluster )
{
  Real size1 = 500;
  Real size2 = 500;
  NameBlock tm2 = Timer::Start( "SampleCombinationMCMC" );
  //Matrix mcmc = SampleCombinationMCMC( dstr3, size1, size2 );
  Matrix mcmc = SampleCombinationMCMC1( (dstr3::Clusters)[idx_cluster],
                                        dstr3::Sigmas_bts, size1 );
  Real tm2::Finish( 0 );
  Matrix sampleY = Sub( mcmc, 1, 1, Rows( mcmc ), NB );
  Matrix sampleZ = Sub( mcmc, 1, NB + 1, Rows( mcmc ), NN );
  Matrix meanBTS = Tra( AvrByColumns( sampleY ) );
  Matrix meanNucleo = Tra( AvrByColumns( sampleZ ) );
  Matrix Check = VMat2Mat( dstr3::A * Mat2VMat( meanBTS ) ) - meanNucleo;
  Set [[ dstr3, mcmc, sampleY, sampleZ, meanNucleo, meanBTS, Check ]]
};

// Martes, 2010/02/02 16:44:21.00
// Martes, 2010/02/02 15:28:11.00
Set AdjustDataStructure3( Clusters3[1], 0.7, 0.2 ); 


// Martes, 2010/02/02 15:16:43.00
Set AdjustDataStructure3( Clusters3[2], 0.7, 0.2 );




// Martes, 2010/02/02 16:07:18.00
Set Test03( Real 0 );


// Martes, 2010/02/02 15:28:11.00
Set AdjustDataStructure3( Clusters3[1], 0.7, 0.2 ); 


// Martes, 2010/02/02 15:16:43.00
Set AdjustDataStructure3( Clusters3[2], 0.7, 0.2 );


// Martes, 2010/02/02 14:08:16.00


// Construyo los Clusters
Set Clusters = EvalSet( cluster_infoCanarias[1], Set AAA( Set cluster ) {
    Set EvalSet( cluster, Set BBB( Set equs ) {
        Real id_nucleo = (equs[1])::cnuc;
        Set local_bts = Copy( Empty );
        Set terms = EvalSet( equs, Set CCC( Set term ) {
            Text name_bts = FormatReal( term::id_bts, "%0.f" );
            Real idx = FindIndexByName( local_bts, name_bts );
            Real idx_bts = If( idx, idx, {
                Real aux = term::id_bts;
                Set Append( local_bts, [[ PutName( name_bts, aux ) ]], True );
                Real Card( local_bts )
              } );
            Set [[ idx_bts, Real w_3g = term::perc_cob_umts,
                   Real w_2g = term::perc_cob_gprs,
                   Real tipo = term::id_tipo_emp ]]
          } );
        Set [[ id_nucleo, local_bts, terms ]]
      } )
  } );



// Martes, 2010/02/02 14:08:03.00


// Construyo los Clusters
Set Clusters = EvalSet( cluster_infoCanarias[1], Real AAA( Set cluster ) {
    Set EvalSet( cluster, Set BBB( Set equs ) {
        Real id_nucleo = (equs[1])::cnuc;
        Set local_bts = Copy( Empty );
        Set terms = EvalSet( equs, Set CCC( Set term ) {
            Text name_bts = FormatReal( term::id_bts, "%0.f" );
            Real idx = FindIndexByName( local_bts, name_bts );
            Real idx_bts = If( idx, idx, {
                Real aux = term::id_bts;
                Set Append( local_bts, [[ PutName( name_bts, aux ) ]], True );
                Real Card( local_bts )
              } );
            Set [[ idx_bts, Real w_3g = term::perc_cob_umts,
                   Real w_2g = term::perc_cob_gprs,
                   Real tipo = term::id_tipo_emp ]]
          } );
        Set [[ id_nucleo, local_bts, terms ]]
      } )
  } );



// Martes, 2010/02/02 14:07:27.00


// Construyo los Clusters
Set Clusters = EvalSet( cluster_infoCanarias[1], Real( Set cluster ) {
    Set EvalSet( cluster, Set( Set equs ) {
        Real id_nucleo = (equs[1])::cnuc;
        Set local_bts = Copy( Empty );
        Set terms = EvalSet( equs, Set( Set term ) {
            Text name_bts = FormatReal( term::id_bts, "%0.f" );
            Real idx = FindIndexByName( local_bts, name_bts );
            Real idx_bts = If( idx, idx, {
                Real aux = term::id_bts;
                Set Append( local_bts, [[ PutName( name_bts, aux ) ]], True );
                Real Card( local_bts )
              } );
            Set [[ idx_bts, Real w_3g = term::perc_cob_umts,
                   Real w_2g = term::perc_cob_gprs,
                   Real tipo = term::id_tipo_emp ]]
          } );
        Set [[ id_nucleo, local_bts, terms ]]
      } )
  } );



// Martes, 2010/02/02 14:06:58.00


// Construyo los Clusters
Set Clusters = EvalSet( cluster_infoCanarias[1], Real( Set cluster ) {
    Set EvalSet( cluster, Set( Set equs ) {
        Real id_nucleo = (equs[1])::cnuc;
        Set local_bts = Copy( Empty );
        Set terms = EvalSet( equs, Set( Set term ) {
            Text name_bts = FormatReal( term::id_bts, "%0.f" );
            Real idx = FindIndexByName( local_bts, name_bts );
            Real idx_bts = If( idx, idx, {
                Real aux = term::id_bts;
                Set Append( local_bts, [[ PutName( name_bts, aux ) ]], True );
                Real Card( local_bts )
              } );
            Set [[ idx_bts, Real cob_3g = term::cob_3g,
                   Real cob_2g = term::cob_2g,
                   Real tipo = term::id_tipo_emp ]]
          } );
        Set [[ id_nucleo, local_bts, terms ]]
      } )
  } );



// Martes, 2010/02/02 14:06:47.00


// Construyo los Clusters
Set Clusters = EvalSet( cluster_infoCanarias[1], Real( Set cluster ) {
    Set EvalSet( cluster, Set( Set equs ) {
        Real id_nucleo = (equs[1])::cnuc;
        Set local_bts = Copy( Empty );
        Set terms = EvalSet( equs, Set( Set term ) {
            Text name_bts = FormatReal( term::id_bts, "%0.f" );
            Real idx = FindIndexByName( local_bts, name_bts );
            Real idx_bts = If( idx, idx, {
                Real aux = term::id_bts;
                Set Append( local_bts, [[ PutName( name_bts, aux ) ]], True );
                Real Card( local_bts )
              } );
            Set [[ idx_bts, Real cob_3g = term::cob_3g,
                   Real cob_2g = term::cob_2g,
                   Real tipo = term::id_tipo_emp ]]
          } );
        Set [[ id_nucleo, local_bts, terms ]]
      } )
  } );



// Martes, 2010/02/02 14:05:51.00


// Construyo los Clusters
Set Clusters = EvalSet( cluster_infoCanarias[1], Real( Set cluster ) {
    Set EvalSet( cluster, Set( Set equs ) {
        Real id_nucleo = (equs[1])::cnuc;
        Set local_bts = Copy( Empty );
        Set terms = EvalSet( equs, Set( Set term ) {
            Text name_bts = FormatReal( term::id_bts, "%0.f" );
            Real idx = FindIndexByName( local_bts, name_bts );
            Real idx_bts = If( idx, idx, {
                Real aux = term::id_bts;
                Set Append( local_bts, [[ PutName( name_bts, aux ) ]], True );
                Real Card( local_bts )
              } );
            Set [[ idx_bts, Real cob_3g = term::cob_3g,
                   Real cob_2g = term::cob_2g,
                   Real tipo = term::id_tipo_emp ]]
          } );
        Set [[ id_nucleo, local_bts, terms ]]
      } )
  } );



// Martes, 2010/02/02 13:36:16.00
Real UpdateY( Set Names, Matrix DataY, Matrix Y )
{
  Set For( 1, Rows( DataY ), Real( Real r ) {
      Real v = MatDat( Y, r, 1 );
      Text name = FormatReal( v, "%0.f" );
      Real idx = FindIndexByName( Names, name );
      Real If( idx, {
          Real PutMatDat( Y, idx, 1, MatDat( DataY, idx, 2 ) )
        }, 0 )
    } );
  Real 0
};

// Construyo Y_nuc
Matrix Y_nuc := Constant( Card( Nucleos ), 1, 0.0 );
Real UpdateY( Nucleos, l_big_scr.data::l_big_scr_nuc_prev_data, Y_nuc );
Real UpdateY( Nucleos, l_big_scr.data::l_big_scr_nuc_estim_data, Y_nuc );

// Martes, 2010/02/02 13:35:57.00
// Construyo Y_nuc
Matrix Y_nuc := Constant( Card( Nucleos ), 1, 0.0 );
Real UpdateY( Nucleos, l_big_scr.data::l_big_scr_nuc_prev_data, Y_nuc );
Real UpdateY( Nucleos, l_big_scr.data::l_big_scr_nuc_estim_data, Y_nuc );

// Martes, 2010/02/02 13:35:50.00
/ Construyo Y_nuc
Matrix Y_nuc := Constant( Card( Nucleos ), 1, 0.0 );
Real UpdateY( Nucleos, l_big_scr.data::l_big_scr_nuc_prev_data, Y_nuc );
Real UpdateY( Nucleos, l_big_scr.data::l_big_scr_nuc_estim_data, Y_nuc );

// Martes, 2010/02/02 13:35:40.00
Real BuildY( Set Names, Matrix DataY, Matrix Y )
{
  Set For( 1, Rows( DataY ), Real( Real r ) {
      Real v = MatDat( Y, r, 1 );
      Text name = FormatReal( v, "%0.f" );
      Real idx = FindIndexByName( Names, name );
      Real If( idx, {
          Real PutMatDat( Y, idx, 1, MatDat( DataY, idx, 2 ) )
        }, 0 )
    } );
  Real 0
};

// Martes, 2010/02/02 13:09:14.00
// Construyo Y_bts
Matrix Y_bts_prev = l_big_scr.data::l_big_scr_eb_prev_data;
Set Y_bts_prev_idx = Copy( Empty );
Matrix Y_bts = Constant( Card( BTS ), 1, 0.0 );
Set For( 1, Rows( Y_bts_prev ), Real( Real r ) {
    Real v = MatDat( Y_bts_prev, r, 1 );
    Text name = FormatReal( v, "%0.f" );
    Real idx = FindIndexByName( BTS, name );
    Real If( idx, {
        Real PutMatDat( Y_bts, idx, 1, MatDat( Y_bts_prev, idx, 2 ) )
      }, 0 )
  } );


// Martes, 2010/02/02 13:05:37.00
// Construyo Y_nuc
Matrix Y_nuc_prev := l_big_scr.data::l_big_scr_nuc_prev_data;
Set Y_nuc_prev_idx := Copy( Empty );
Matrix Y_nuc := Constant( Card( Nucleos ), 1, 0.0 );
Set For( 1, Rows( Y_nuc_prev ), Real( Real r ) {
    Real v = MatDat( Y_nuc_prev, r, 1 );
    Text name = FormatReal( v, "%0.f" );
    Real idx = FindIndexByName( Nucleos, name );
    Real If( idx, {
        Real PutMatDat( Y_nuc, idx, 1, MatDat( Y_nuc_prev, idx, 2 ) )
      }, 0 )
  } );


// Martes, 2010/02/02 13:03:44.00
// Construyo Y_nuc
Matrix Y_nuc_prev := l_big_scr.data::l_big_scr_nuc_prev_data;
Set Y_nuc_prev_idx := Copy( Empty );
Matrix Y_nuc := Constant( Card( Nucleos ), 1, 0.0 );
Set For( 1, Rows( Y_nuc_prev ), Real( Real r ) {
    Real v = MatDat( Y_nuc_prev, r, 1 );
    Text name = FormatReal( v, "%0.f" );
    Real idx = FindIndexByName( Nucleos, name );
    Real If( idx, {
        Real PutMatDat( Y_nuc, idx, 1, v )
      }, 0 )
  } );


// Martes, 2010/02/02 13:03:00.00
// Construyo Y_nuc
Matrix Y_nuc_prev = l_big_scr.data::l_big_scr_nuc_prev_data;
Set Y_nuc_prev_idx := Copy( Empty );
Matrix Y_nuc := Constant( Card( Nucleos ), 1, 0.0 );
Set For( 1, Rows( Y_nuc_prev ), Real( Real r ) {
    Real v = MatDat( Y_nuc_pre, r, 1 );
    Text name = FormatReal( v, "%0.f" );
    Real idx = FindIndexByName( Nucleos, name );
    Real If( idx, {
        Real PutMatDat( Y_nuc, idx, 1, v )
      }, 0 )
  } );

// Martes, 2010/02/02 13:02:35.00
// Construyo Y_nuc
Matrix Y_nuc_rev = l_big_scr.data::l_big_scr_nuc_prev_data;
Set Y_nuc_prev_idx := Copy( Empty );
Matrix Y_nuc := Constant( Card( Nucleos ), 1, 0.0 );
Set For( 1, Rows( Y_nuc_prev ), Real( Real r ) {
    Real v = MatDat( Y_nuc_pre, r, 1 );
    Text name = FormatReal( v, "%0.f" );
    Real idx = FindIndexByName( Nucleos, name );
    Real If( idx, {
        Real PutMatDat( Y_nuc, idx, 1, v )
      }, 0 )
  } );


// Martes, 2010/02/02 13:01:32.00
// Construyo Y_nuc
Matrix Y_nuc_rev = l_big_scr_data::l_big_scr_nuc_prev_data;
Set Y_nuc_prev_idx = Copy( Empty );
Matrix Y_nuc = Constant( Card( Nucleos ), 1, 0.0 );
Set For( 1, Rows( Y_nuc_prev ), Real( Real r ) {
    Real v = MatDat( Y_nuc_pre, r, 1 );
    Text name = FormatReal( v, "%0.f" );
    Real idx = FindIndexByName( Nucleos, name );
    Real If( idx, {
        Real PutMatDat( Y_nuc, idx, 1, v )
      }, 0 )
  } );


// Martes, 2010/02/02 12:42:47.00
Matrix SubRow( Col( 1,2,3,4,5), [[ 5,2,1 ]] );

// Martes, 2010/02/02 12:42:29.00
Matrix SubRow( SetCol( 1,2,3,4,5), [[ 5,2,1 ]] );

// Martes, 2010/02/02 12:37:58.00
/*
Text cwd = GetAbsolutePath( "." ) + "/";

Set clustersCanarias = Include( cwd + "clustersCanarias.oza" );
Set cluster_infoCanarias = Include( cwd + "cluster_infoCanarias.oza" );
Set l_big_scr.data = Include( "l_big_scr.data.oza" );
Set vol3g.data = Include( "vol3g.data.oza" );
*/

Set Nucleos := Copy( Empty );
Set BTS := Copy( Empty );
Set EvalSet( cluster_infoCanarias[1], Real( Set cluster ) {
    Set Append( Nucleos, EvalSet( cluster, Real( Set equs ) {
          Real aux = (equs[ 1 ])::cnuc;
          Text name = FormatReal( aux, "%0.f" );
          Set EvalSet( equs, Real( Set equ ) {
              Real aux = equ::id_bts;
              Text name_bts = FormatReal( aux, "%0.f" );
              Real idx = FindIndexByName( BTS, name_bts );
              Real If ( Not( idx ), {
                  Real PutName( name_bts, aux );
                  Set Append( BTS, [[ aux ]], True );
                  Real 0
                }, idx )
            } );
          Real PutName( name, aux )
        } ), True );
    Real 0
  } );




// Martes, 2010/02/02 12:36:39.00
/*
Text cwd = GetAbsolutePath( "." ) + "/";

Set clustersCanarias = Include( cwd + "clustersCanarias.oza" );
Set cluster_infoCanarias = Include( cwd + "cluster_infoCanarias.oza" );
Set l_big_scr.data = Include( "l_big_scr.data.oza" );
Set vol3g.data = Include( "vol3g.data.oza" );
*/

Set Nucleos := Copy( Empty );
Set BTS := Copy( Empty );
Set EvalSet( cluster_infoCanarias[1], Real( Set cluster ) {
    Set Append( Nucleos, EvalSet( cluster, Real( Set equs ) {
          Real aux = (equs[ 1 ])::cnuc;
          Text name = FormatReal( aux, "%0.f" );
          Set EvalSet( equs, Real( Set equ ) {
                Real aux = equ::id_bts;
                Text name_bts = FormatReal( aux, "%0.f" );
                Real idx = FindIndexByName( BTS, name_bts );
                Real If ( Not( idx ), {
                    Real PutName( name_bts, aux );
                    Set Append( BTS, [[ aux ]], True )
                  } );
                Real idx
              } );
          Real PutName( name, aux )
        } ), True );
    Real 0
  } );



// Martes, 2010/02/02 12:36:01.00
/*
Text cwd = GetAbsolutePath( "." ) + "/";

Set clustersCanarias = Include( cwd + "clustersCanarias.oza" );
Set cluster_infoCanarias = Include( cwd + "cluster_infoCanarias.oza" );
Set l_big_scr.data = Include( "l_big_scr.data.oza" );
Set vol3g.data = Include( "vol3g.data.oza" );
*/

Set Nucleos := Copy( Empty );
Set BTS := Copy( Empty );
Set EvalSet( cluster_infoCanarias[1], Real( Set cluster ) {
    Set Append( Nucleos, EvalSet( cluster, Real( Set equs ) {
          Real aux = (equs[ 1 ])::cnuc;
          Text name = FormatReal( aux, "%0.f" );
          Set EvalSet( equs, Real( Set equ ) {
                Set View( equ, "Std" );
                Real aux = eq[ 3 ]; // eq::id_bts;
                Real Stop;
                Text name_bts = FormatReal( aux, "%0.f" );
                Real idx = FindIndexByName( BTS, name_bts );
                Real If ( Not( idx ), {
                    Real PutName( name_bts, aux );
                    Set Append( BTS, [[ aux ]], True )
                  } );
                Real idx
              } );
          Real PutName( name, aux )
        } ), True );
    Real 0
  } );



// Martes, 2010/02/02 12:34:59.00
/*
Text cwd = GetAbsolutePath( "." ) + "/";

Set clustersCanarias = Include( cwd + "clustersCanarias.oza" );
Set cluster_infoCanarias = Include( cwd + "cluster_infoCanarias.oza" );
Set l_big_scr.data = Include( "l_big_scr.data.oza" );
Set vol3g.data = Include( "vol3g.data.oza" );
*/

Set Nucleos := Copy( Empty );
Set BTS := Copy( Empty );
Set EvalSet( cluster_infoCanarias[1], Real( Set cluster ) {
    Set Append( Nucleos, EvalSet( cluster, Real( Set equs ) {
          Real aux = (equs[ 1 ])::cnuc;
          Text name = FormatReal( aux, "%0.f" );
          Set EvalSet( equs, Real( Set equ ) {
                Set View( equ, "Std" );
                Real aux = eq::id_bts;
                Real Stop;
                Text name_bts = FormatReal( aux, "%0.f" );
                Real idx = FindIndexByName( BTS, name_bts );
                Real If ( Not( idx ), {
                    Real PutName( name_bts, aux );
                    Set Append( BTS, [[ aux ]], True )
                  } );
                Real idx
              } );
          Real PutName( name, aux )
        } ), True );
    Real 0
  } );



// Martes, 2010/02/02 12:34:17.00
/*
Text cwd = GetAbsolutePath( "." ) + "/";

Set clustersCanarias = Include( cwd + "clustersCanarias.oza" );
Set cluster_infoCanarias = Include( cwd + "cluster_infoCanarias.oza" );
Set l_big_scr.data = Include( "l_big_scr.data.oza" );
Set vol3g.data = Include( "vol3g.data.oza" );
*/

Set Nucleos := Copy( Empty );
Set BTS := Copy( Empty );
Set EvalSet( cluster_infoCanarias[1], Real( Set cluster ) {
    Set Append( Nucleos, EvalSet( cluster, Real( Set equs ) {
          Real aux = (equs[ 1 ])::cnuc;
          Text name = FormatReal( aux, "%0.f" );
          Set EvalSet( equs, Real( Set equ ) {
                Set View( equ, "Std" );
                Real Stop;
                Real aux = eq::id_bts;
                Text name_bts = FormatReal( aux, "%0.f" );
                Real idx = FindIndexByName( BTS, name_bts );
                Real If ( Not( idx ), {
                    Real PutName( name_bts, aux );
                    Set Append( BTS, [[ aux ]], True )
                  } );
                Real idx
              } );
          Real PutName( name, aux )
        } ), True );
    Real 0
  } );



// Martes, 2010/02/02 12:32:29.00
/*
Text cwd = GetAbsolutePath( "." ) + "/";

Set clustersCanarias = Include( cwd + "clustersCanarias.oza" );
Set cluster_infoCanarias = Include( cwd + "cluster_infoCanarias.oza" );
Set l_big_scr.data = Include( "l_big_scr.data.oza" );
Set vol3g.data = Include( "vol3g.data.oza" );
*/

Set Nucleos := Copy( Empty );
Set BTS = Copy( Empty );
Set EvalSet( cluster_infoCanarias[1], Real( Set cluster ) {
    Set Append( Nucleos, EvalSet( cluster, Real( Set equs ) {
          Real aux = (equs[ 1 ])::cnuc;
          Text name = FormatReal( aux, "%0.f" );
          Set EvalSet( equs, Real( Set equ ) {
                Real aux = eq::id_bts;
                Text name_bts = FormatReal( aux, "%0.f" );
                Real idx = FindIndexByName( BTS, name_bts );
                Real If ( Not( idx ), {
                    Real PutName( name_bts, aux );
                    Set Append( BTS, [[ aux ]], True )
                  } );
                Real idx
              } );
          Real PutName( name, aux )
        } ), True );
    Real 0
  } );



// Martes, 2010/02/02 12:23:42.00
/*
Text cwd = GetAbsolutePath( "." ) + "/";

Set clustersCanarias = Include( cwd + "clustersCanarias.oza" );
Set cluster_infoCanarias = Include( cwd + "cluster_infoCanarias.oza" );
Set l_big_scr.data = Include( "l_big_scr.data.oza" );
Set vol3g.data = Include( "vol3g.data.oza" );
*/

Set Nucleos1 = Copy( Empty );
Set EvalSet( cluster_infoCanarias[1], Real( Set cluster ) {
    Set Append( Nucleos1, EvalSet( cluster, Real( Set equ ) {
          Real aux = (equ[ 1 ])::cnuc;
          Text name = FormatReal( aux, "%0.f" );
          Real PutName( name, aux )
        } ), True );
     Real 0
  } );




// Martes, 2010/02/02 12:23:01.00
/*
Text cwd = GetAbsolutePath( "." ) + "/";

Set clustersCanarias = Include( cwd + "clustersCanarias.oza" );
Set cluster_infoCanarias = Include( cwd + "cluster_infoCanarias.oza" );
Set l_big_scr.data = Include( "l_big_scr.data.oza" );
Set vol3g.data = Include( "vol3g.data.oza" );
*/

Set Nucleos = Copy( Empty );
Set EvalSet( cluster_infoCanarias[1], Real( Set cluster ) {
    Set Append( Nucleos, EvalSet( cluster, Real( Set equ ) {
          Real aux = (equ[ 1 ])::cnuc;
          Text name = FormatReal( aux, "%0.f" );
          Real PutName( name, aux )
        } ), True )
  } );




// Martes, 2010/02/02 12:13:05.00
Text cwd = GetAbsolutePath( "." ) + "/";

Set clustersCanarias = Include( cwd + "clustersCanarias.oza" );
Set cluster_infoCanarias = Include( cwd + "cluster_infoCanarias.oza" );
Set l_big_scr.data = Include( "l_big_scr.data.oza" );
Set vol3g.data = Include( "vol3g.data.oza" );


// Martes, 2010/02/02 12:12:40.00

Text cwd = "/tmp/"; //GetAbsolutePath( "." ) + "/";

Set clustersCanarias = Include( cwd + "clustersCanarias.oza" );
Set cluster_infoCanarias = Include( cwd + "cluster_infoCanarias.oza" );
Set l_big_scr.data = Include( "l_big_scr.data.oza" );
Set vol3g.data = Include( "vol3g.data.oza" );


// Martes, 2010/02/02 12:12:24.00

Set cwd = "/tmp/"; //GetAbsolutePath( "." ) + "/";

Set clustersCanarias = Include( cwd + "clustersCanarias.oza" );
Set cluster_infoCanarias = Include( cwd + "cluster_infoCanarias.oza" );
Set l_big_scr.data = Include( "l_big_scr.data.oza" );
Set vol3g.data = Include( "vol3g.data.oza" );


// Martes, 2010/02/02 12:11:57.00

Set cwd = "/tmp/"; //GetAbsolutePath( "." ) + "/";

Set clustersCanarias = Include( cwd + "clustersCanarias.oza" );
Set cluster_infoCanarias = Include( cwd + "cluster_infoCanarias.oza" );
Set l_big_scr.data = Include( "l_big_scr.data.oza" );
Set vol3g.data = Include( "vol3g.data.oza" );


// Martes, 2010/02/02 12:11:40.00

Set cwd = GetAbsolutePath( "." ) + "/";

Set clustersCanarias = Include( cwd + "clustersCanarias.oza" );
Set cluster_infoCanarias = Include( cwd + "cluster_infoCanarias.oza" );
Set l_big_scr.data = Include( "l_big_scr.data.oza" );
Set vol3g.data = Include( "vol3g.data.oza" );


// Martes, 2010/02/02 11:45:43.00
Set Test03(0);


// Martes, 2010/02/02 11:43:11.00
Set Test03(0);


// Martes, 2010/02/02 11:42:28.00
Set Test03(0);


// Martes, 2010/02/02 10:41:30.00
Set Test03(0);


// Martes, 2010/02/02 10:29:57.00

//////////////////////////////////////////////////////////////////////////////
Set AdjustDataStructure3(Set dstr3)
//////////////////////////////////////////////////////////////////////////////
{
  // Restricción
  VMatrix vB = dstr3::A | Diag(Rows(dstr3::Y_nuc), -1);
  VMatrix vC = Zeros(VRows(vB),1);
  // Datos
  Matrix mA_bts = Exp(dstr3::Y_bts + (Sigma_bts^2)/2);
  Matrix mS_bts = mA_bts * Sqrt(Exp(Sigma_bts^2)-1);
  Matrix mA_nuc = Exp(dstr3::Y_nuc + (Sigma_nuc^2)/2);
  Matrix mS_nuc = mA_nuc * Sqrt(Exp(Sigma_nuc^2)-1);
  Matrix mA = mA_bts<<mA_nuc;
  Matrix mS = mS_bts<<mS_nuc;
  // Cálculo
  Real t0 = Copy(Time);
  Matrix mZ = {
    Matrix mB = VMat2Mat(vB);
    Matrix mC = VMat2Mat(vC);
    Matrix mV = SetDiag(MatSet(Tra(mS^2))[1]);
    Matrix mBVB = mB * mV * Tra(mB);
    Matrix mBVBI = GaussInverse(mBVB);
    Matrix mZ = mV*Tra(mB)*mBVBI*(mC-mB*mA)+mA
  };
  Real t1 = Copy(Time);
  WriteLn(" Tiempo: "<<(Real t1-t0)<<" s");
  Matrix X_bts = Sub(mZ, 1, 1, Rows(dstr3::Y_bts), 1);
  Matrix X_nuc = Sub(mZ, Rows(dstr3::Y_bts)+1, 1, Rows(dstr3::Y_nuc), 1);
  // Comprobación
  Matrix mErr = Abs(VMat2Mat(dstr3::A) * X_bts - X_nuc);
  WriteLn(" Error: {máx: "<<MatMax(mErr)<<", med: "<<MatAvr(mErr)<<"}");
  [[ Matrix X_nuc, Matrix X_bts ]]
};

//////////////////////////////////////////////////////////////////////////////

  Real NN = 482;
  Real NB = 350;

  Real Sigma_nuc = 0.8;
  Real Sigma_bts = 0.8;
  Set dstr3 = SimulateDataStructure3( NN, NB, Sigma_nuc, Sigma_bts, 10 );

  Set sol = AdjustDataStructure3(Set dstr3);
  //>  Tiempo: 220.628238 s
  //>  Error: {máx: 0.03284736568616609, med: 0.001323854246641564}



// Martes, 2010/02/02 10:03:01.00
Set Include("/tmp/l_big_scr.data.oza");


// Martes, 2010/02/02 09:59:26.00
Set Include("/tmp/l_big_scr.data.oza");


// Martes, 2010/02/02 01:29:35.00
//Set Test00(0);
Set result = Test01(0);
Set check = CheckSample( result );


// Martes, 2010/02/02 01:27:57.00
//Set Test00(0);
Set result = Test01(0);
Set check = CheckSample( result );


// Martes, 2010/02/02 01:27:17.00
//Set Test00(0);
Set result = Test01(0);
Set check = CheckSample( result );


// Martes, 2010/02/02 01:08:24.00
//Set Test00(0);
Set result = Test01(0);
Set check = CheckSample( result );


// Martes, 2010/02/02 01:02:20.00
//Set Test00(0);
Set result = Test01(0);
Set check = CheckSample( result );


// Martes, 2010/02/02 00:57:27.00
//Set Test00(0);
Set result = Test01(0);
Set check = CheckSample( result );


// Martes, 2010/02/02 00:57:15.00
//Set Test00(0);
Set result = Test01(0);
Set check = CheckSample( result );


// Martes, 2010/02/02 00:57:11.00
 

// Martes, 2010/02/02 00:56:50.00
//Set Test00(0);
Set result = Test01(0);
Set check = CheckSample( result );


// Martes, 2010/02/02 00:52:30.00
//Set Test00(0);
Set result = Test01(0);
Set check = CheckSample( result );


// Martes, 2010/02/02 00:30:26.00
//Set Test00(0);
Set result = Test01(0);
Set check = CheckSample( result );


// Martes, 2010/02/02 00:15:39.00
//Set Test00(0);
Set Test01(0);


// Martes, 2010/02/02 00:15:06.00
//Set Test00(0);
Set Test01(0);


// Martes, 2010/02/02 00:14:25.00
Set Test00(0);
//Set Test01(0);


// Martes, 2010/02/02 00:14:05.00
//Set Test00(0);
Set Test01(0);


// Martes, 2010/02/02 00:02:43.00
//Set Test00(0);
Set Test01(0);


// Lunes, 2010/02/01 23:57:06.00
//Set Test00(0);
Set Test01(0);


// Lunes, 2010/02/01 23:55:32.00
//Set Test00(0);
Set Test01(0);


// Lunes, 2010/02/01 23:52:23.00
//Set Test00(0);
Set Test01(0);


// Lunes, 2010/02/01 23:51:31.00
//Set Test00(0);
Set Test01(0);


// Lunes, 2010/02/01 23:50:27.00
Set Test00(0);
//Set Test01(0);


// Lunes, 2010/02/01 23:49:55.00
Set Test00(0);
//Set Test01(0);


// Lunes, 2010/02/01 23:47:51.00
Set Test01(0)


// Lunes, 2010/02/01 23:47:15.00
Set Test01(0)


// Lunes, 2010/02/01 23:46:31.00
Set Test01(0)


// Lunes, 2010/02/01 23:46:06.00
Set Test01(0)


// Lunes, 2010/02/01 23:45:23.00
Set Test01(0)


// Lunes, 2010/02/01 23:44:32.00
Set Test01(0)


// Lunes, 2010/02/01 23:22:35.00
Set Test01(0)


// Lunes, 2010/02/01 22:07:24.00
Set Test01(0)


// Lunes, 2010/02/01 22:06:42.00
Set Test01(0)


// Lunes, 2010/02/01 22:06:24.00
Set Test01(0)


// Lunes, 2010/02/01 22:05:49.00
Set Test01(0)


// Lunes, 2010/02/01 22:01:36.00
Text FormatReal( 1.2, "%.0f" );


// Lunes, 2010/02/01 21:12:29.00
Matrix LogNormalMCMC( Real mu, Real sigma, Real size )
{
  Matrix N = Gaussian( size, 1, 0, 1 );
  Matrix Exp( N * sigma + mu )
};

Matrix LogNormalMCMC1( Real mu, Real sigma, Real size )
{
  Matrix N = Gaussian( size, 1, mu, sigma );
  Matrix Exp( N )
};

Matrix LogNormalMCMC2( Real mu, Real sigma, Real size )
{
  Matrix SetCol( For( 1, size, Real( Real k ) { RandLogNormal( mu, sigma ) } ) )
};

Matrix M1 = LogNormalMCMC1( 0, 2, 10000 );

Matrix H1 = Frequency( M1, 100 );


// Lunes, 2010/02/01 21:03:37.00
Matrix LogNormalMCMC( Real mu, Real sigma, Real size )
{
  Matrix N = Gaussian( size, 1, 0, 1 );
  Matrix Exp( N * sigma + mu )
};

Matrix LogNormalMCMC1( Real mu, Real sigma, Real size )
{
  Matrix SetCol( For( 1, size, Real( Real k ) { RandLogNormal( mu, sigma ) } ) )
};

Matrix M1 = LogNormalMCMC( 0, 2, 10000 );

Matrix H1 = Frequency( M1, 100 );


// Lunes, 2010/02/01 21:00:48.00
Matrix LogNormalMCMC( Real mu, Real sigma, Real size )
{
  Matrix N = Gaussian( size, 1, 0, 1 );
  Matrix Exp( N * sigma + mu )
};

Matrix LogNormalMCMC1( Real mu, Real sigma, Real size )
{
  Matrix SetCol( For( 1, size, Real( Real k ) { RandLogNormal( mu, sigma ) } ) )
};

Matrix M1 = LogNormalMCMC1( 0, 2, 10000 );

Matrix H1 = Frequency( M1, 100 );


// Lunes, 2010/02/01 21:00:23.00
Matrix LogNormalMCMC( Real mu, Real sigma, Real size )
{
  Matrix N = Gaussian( size, 1, 0, 1 );
  Matrix Exp( N * sigma + mu )
};

Matrix LogNormalMCMC1( Real mu, Real sigma, Real size )
{
  Matrix SetCol( For( 1, size, Real( Real k ) { RandLogNormal( mu, sigma ) } ) )
};

Matrix M1 = LogNormalMCMC1( 0, 2, 10000 );

Matrix H1 = Frequency( M1, 20 );


// Lunes, 2010/02/01 20:59:08.00
Matrix LogNormalMCMC( Real mu, Real sigma, Real size )
{
  Matrix N = Gaussian( size, 1, 0, 1 );
  Matrix Exp( N * sigma + mu )
};

Matrix LogNormalMCMC1( Real mu, Real sigma, Real size )
{
  Matrix SetCol( For( 1, size, Real( Real k ) { RandLogNormal( mu, sigma ) } ) )
};

Matrix M1 = LogNormalMCMC1( 0, 2, 1000 );

Matrix H1 = Frequency( M1, 20 );


// Lunes, 2010/02/01 20:55:18.00
Matrix LogNormalMCMC( Real mu, Real sigma, Real size )
{
  Matrix N = Gaussian( size, 1, 0, 1 );
  Matrix Exp( N * sigma + mu )
};

Matrix M1 = LogNormalMCMC( 0, 2, 1000 );

Matrix H1 = Frequency( M1, 20 );


// Lunes, 2010/02/01 20:53:58.00
Matrix LogNormalMCMC( Real mu, Real sigma, Real size )
{
  Matrix N = Gaussian( size, 1, 0, 1 );
  Matrix Exp( N * sigma + mu )
};

Matrix M1 = LogNormalMCMC( 0, 10, 1000 );

Matrix H1 = Frequency( M1, 20 );


// Lunes, 2010/02/01 20:53:14.00
Matrix LogNormalMCMC( Real mu, Real sigma, Real size )
{
  Matrix N = Gaussian( size, 1, 0, 1 );
  Matrix Exp( N * sigma + mu )
};

Matrix M1 = LogNormalMCMC( 0, 10, 1000 );


// Lunes, 2010/02/01 20:52:51.00
Matrix LogNormalMCMC( Real mu, Real sigma, Real size )
{
  Matrix N = Gaussian( size, 1, 0, 1 );
  Matrix Exp( sigma * N + mu )
};

Matrix M1 = LogNormalMCMC( 0, 10, 1000 );


// Lunes, 2010/02/01 20:52:22.00
Matrix LogNormalMCMC( Real mu, Real sigma, Real size )
{
  Matrix N = Gaussian( 0, 1 );
  Matrix Exp( size, 1, sigma * N + mu )
};

Matrix M1 = LogNormalMCMC( 0, 10, 1000 );


// Martes, 2010/01/19 17:44:29.00

  Matrix obj = ((0,0,0)); 
 
  Matrix mat = ((3,4,2),
                (2,1,1),
                (1,3,2));
  Matrix rhs = ((60,-1,80));

  Set bounds = [[ Set lower=[[ [[1, -Inf]], [[2, -Inf]], [[3, -Inf]] ]]  ]];

  Set sol=Rglpk::solveLP(obj, mat, rhs,
                         {[[Set dir=[["<","<","<"]], Set bounds,
                          Real verbose=TRUE, Real max=FALSE]]});
  Matrix check1 = mat*Tra(sol["solution"]) - Tra(rhs);


// Domingo, 2010/01/17 15:33:12.00
Set select_regions = [[ "16", "17" ]];
Real needs_where = 1;

               Text rr = If( needs_where,
                 { Real needs_where:=0; Text " WHERE " },
                 Text " AND " ) +
                 "sab.codautonomia in " + 
                 BinGroup( "+",
                           [[ "('" + select_regions[1] + "'" ]] <<
                           Set For( 2, Card( select_regions), Text( Real k ) {
                               Text ",'" + select_regions[ k ] + "'"
                                 } ) << [[ ")" ]] )



// Domingo, 2010/01/17 15:33:01.00
Set select_regions = [[ "16", "17" ]];
Real needs_where = 0;

               Text rr = If( needs_where,
                 { Real needs_where:=0; Text " WHERE " },
                 Text " AND " ) +
                 "sab.codautonomia in " + 
                 BinGroup( "+",
                           [[ "('" + select_regions[1] + "'" ]] <<
                           Set For( 2, Card( select_regions), Text( Real k ) {
                               Text ",'" + select_regions[ k ] + "'"
                                 } ) << [[ ")" ]] )



// Domingo, 2010/01/17 15:30:45.00
Set select_regions = [[ "16", "17" ]];

Set args = [[ Text "('" + select_regions[1] + "'" ]] <<
     For( 2, Card( select_regions), Text( Real k ) {
       Text ",'" + select_regions[ k ] + "'" } ) << [[ ")" ]];

Text rr = "aaa in " + BinGroup( "+", args );

// Domingo, 2010/01/17 15:30:22.00
Text "aaa in " + BinGroup( "+", args )

// Domingo, 2010/01/17 15:30:08.00
Set select_regions = [[ "16", "17" ]];

Set args = [[ Text "('" + select_regions[1] + "'" ]] <<
     For( 2, Card( select_regions), Text( Real k ) {
       Text ",'" + select_regions[ k ] + "'" } ) << [[ ")" ]];

Text "aaa in " + BinGroup( "+", args )

// Domingo, 2010/01/17 15:29:36.00
Text BinGroup( "+", args )

// Domingo, 2010/01/17 15:28:27.00
Set select_regions = [[ "16", "17" ]];

Set args = [[ Text "('" + select_regions[1] + "'" ]] <<
     For( 2, Card( select_regions), Text( Real k ) {
       Text ",'" + select_regions[ k ] + "'" } ) << [[ ")" ]];

Text "sab.codautonomia in " + (Text BinGroup( "+", args ))

// Domingo, 2010/01/17 15:27:05.00
Set select_regions = [[ "16", "17" ]];

Set args = [[ Text "('" + select_regions[1] + "'" ]] <<
     For( 2, Card( select_regions), Text( Real k ) {
       Text ",'" + select_regions[ k ] + "'" } ) << [[ ")" ]];

Text "sab.codautonomia in " + 
     BinGroup( "+", args )

// Domingo, 2010/01/17 15:24:07.00
Set select_regions = [[ "16", "17" ]];


Text            "sab.codautonomia in " + 
                 BinGroup( "+",
                           [[ "('" + select_regions[1] + "'" ]] <<
                           Set EvalSet( select_regions, Text( Text id ) {
                               Text ",'" + id + "'"
                                 } ) << [[ ")" ]] )


// Domingo, 2010/01/17 14:48:47.00
Matrix histY = Frequency( (estim[1])::Y, 20 );


// Domingo, 2010/01/17 14:41:41.00
Matrix Frequency( estim::Nucleos.V3G::Y, 20 );


// Sabado, 2010/01/16 16:25:31.00
Matrix Frequency( spain.estim::SPAIN.MDL.LINESBIGSCR::Y, 20 );


// Sabado, 2010/01/16 16:17:44.00
Matrix Frequency( spain.estim::SPAIN.MDL.VOL::Y, 20 );


// Sabado, 2010/01/16 16:17:29.00
Matrix Frequency( SPAIN.MDL.VOL::Y, 20 );


// Viernes, 2010/01/15 16:14:00.00
Real GuiPlotModelVSNoise (GetObjectFromAddress("9FB4B60:0:8D3F5A0:0:8B8B1D8:0:2:4:4") )

// Miercoles, 2010/01/13 12:46:23.00
Real UsingNameBlock(GuiTools);

// Miercoles, 2010/01/13 11:45:17.00
Real UsingNameBlock(GuiTools);

// Miercoles, 2010/01/13 11:38:07.00
NameBlock GetObjectFromAddress( "A24D3DC:0:8F44868:0:8A837A0:0:2:4:2" );

// Miercoles, 2010/01/13 11:37:00.00
Text GetAddressFromObject( guidim_test )


// Miercoles, 2010/01/13 11:35:38.00
Real UsingNameBlock(GuiTools);

// Miercoles, 2010/01/13 11:30:57.00
Real UsingNameBlock(GuiTools);

// Miercoles, 2010/01/13 11:21:31.00
Real UsingNameBlock(GuiTools);

// Martes, 2010/01/12 23:08:20.00
Set aaa = SetOfSet( SetOfText("Dim1.Name1"), SetOfText("Dim2.Name1") )


// Martes, 2010/01/12 23:07:49.00
Set aaa = SetOfText( SetOfText("Dim1.Name1"), SetOfText("Dim2.Name1") )


// Martes, 2010/01/12 23:06:49.00
Set aaa = SetOfText(SetOfText("Dim1.Name1"), SetOfText("Dim2.Name1"))


// Martes, 2010/01/12 20:32:51.00
Real UsingNameBlock(GuiTools);

// Martes, 2010/01/12 19:23:04.00
NameBlock __aux_dsel__ = [[ Real a = 1 ]];


// Lunes, 2010/01/11 22:57:14.00
#Require GuiTools;
Real UsingNameBlock(GuiTools);

Class @GuiTest_Hello : @MenuDesc
{
 Real showMessage( Real void )
 {
   Set Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
   Real 0
 };

 Set getMenuEntries(Real void) {
   Set [[ [[ "Hola ...", "showMessage" ]] ]]
 }
  };

@GuiTest_Hello gui_obj;



// Lunes, 2010/01/11 22:23:27.00
//Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/Gui/Gui.tol");

//#Require "Gui";

Real UsingNameBlock(Gui);

Class @GuiTest_Hello : @MenuDesc
{
  Real a = 0;

  Real showMessage( Real void )
  {
    Set Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj = [[ Real a = 1 ]];
Real gui_obj::showMessage(?);

Real IsInstanceOf( gui_obj, "@MenuDesc" );


// Lunes, 2010/01/11 22:23:15.00
/Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/Gui/Gui.tol");

//#Require "Gui";

Real UsingNameBlock(Gui);

Class @GuiTest_Hello : @MenuDesc
{
  Real a = 0;

  Real showMessage( Real void )
  {
    Set Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj = [[ Real a = 1 ]];
Real gui_obj::showMessage(?);

Real IsInstanceOf( gui_obj, "@MenuDesc" );


// Lunes, 2010/01/11 22:00:30.00
Class @GuiTest_Hello
{
  Real a = 0;

  Real showMessage( Real void )
  {
    Set Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj = [[ Real a = 1 ]];
Real gui_obj::showMessage(?);


// Lunes, 2010/01/11 21:57:36.00
Set gui_obj::getMenuEntries(?);

// Lunes, 2010/01/11 21:57:25.00
Set getMenuEntries(?);

// Lunes, 2010/01/11 21:56:41.00
Class @GuiTest_Hello : Gui::@MenuDesc
{
  Real a = 0;

  Real showMessage( Real void )
  {
    Set Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj = [[ Real a = 1 ]];
Text ClassOf( gui_obj );
Real gui_obj::showMessage(?);


// Lunes, 2010/01/11 21:50:15.00
Class @GuiTest_Hello : Gui::@MenuDesc
{
  Real a = 0;

  Real showMessage( Real void )
  {
    Set Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj = [[ Real a = 1 ]];
Real gui_obj::showMessage(?);


// Lunes, 2010/01/11 21:48:34.00
//Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/Gui/Gui.tol");

//#Require "Gui";

Class @GuiTest_Hello : Gui::@MenuDesc
{
  Real a = 0;

  Real showMessage( Real void )
  {
    Set Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj = [[ Real a = 1 ]];

Real gui_obj::showMessage(?);

NameBlock aux = gui_obj;

Real IsInstanceOf( gui_obj, "Gui::@MenuDesc" );
Real IsInstanceOf( aux, "Gui::@MenuDesc" );


// Lunes, 2010/01/11 21:48:07.00
//Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/Gui/Gui.tol");

//#Require "Gui";

Class @GuiTest_Hello : Gui::@MenuDesc
{
  Real a = 0;

  Real showMessage( Real void )
  {
    Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj = [[ Real a = 1 ]];

Real gui_obj::showMessage(?);

NameBlock aux = gui_obj;

Real IsInstanceOf( gui_obj, "Gui::@MenuDesc" );
Real IsInstanceOf( aux, "Gui::@MenuDesc" );


// Lunes, 2010/01/11 21:06:07.00
Real gui_obj::showMessage(?);

// Lunes, 2010/01/11 21:03:03.00
Real IsInstanceOf( gui_obj, "Gui::@MenuDesc" );
Real IsInstanceOf( aux, "Gui::@MenuDesc" );

// Lunes, 2010/01/11 21:02:49.00
NameBlock aux = gui_obj;

Real IsInstanceOf( gui_obj, "@MenuDesc" );
Real IsInstanceOf( aux, "@MenuDesc" );

// Lunes, 2010/01/11 21:02:24.00
Real IsInstanceOf( gui_obj, "@MenuDesc" );
Real IsInstanceOf( aux, "@MenuDesc" );

// Lunes, 2010/01/11 21:00:53.00
Real IsInstanceOff( gui_obj, "@MenuDesc" );
Real IsInstanceOff( aux, "@MenuDesc" );

// Lunes, 2010/01/11 20:39:10.00
Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/Gui/Gui.tol");

//#Require "Gui";

Class @GuiTest_Hello : Gui::@MenuDesc
{
  Real a = 0;

  Real showMessage( Real void )
  {
    Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj = [[ Real a = 1 ]];


// Lunes, 2010/01/11 20:38:13.00
#Embed "/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/Gui/Gui.tol";

//#Require "Gui";

Class @GuiTest_Hello : Gui::@MenuDesc
{
  Real a = 0;

  Real showMessage( Real void )
  {
    Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj = [[ Real a = 1 ]];


// Lunes, 2010/01/11 20:37:03.00
Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/Gui/Gui.tol");

//#Require "Gui";

Class @GuiTest_Hello : Gui::@MenuDesc
{
  Real a = 0;

  Real showMessage( Real void )
  {
    Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj = [[ Real a = 1 ]];


// Lunes, 2010/01/11 20:36:04.00
#Embed "/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/Gui/Gui.tol"

//#Require "Gui";

Class @GuiTest_Hello : Gui::@MenuDesc
{
  Real a = 0;

  Real showMessage( Real void )
  {
    Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj = [[ Real a = 1 ]];




// Lunes, 2010/01/11 20:35:23.00
Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/Gui/Gui.tol");

//#Require "Gui";

Class @GuiTest_Hello : Gui::@MenuDesc
{
  Real a = 0;

  Real showMessage( Real void )
  {
    Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj = [[ Real a = 1 ]];



// Lunes, 2010/01/11 20:34:54.00
Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/Gui/Gui.tol");

//#Require "Gui";

Class @GuiTest_Hello : Gui::@MenuDesc
{
  Real a = 0;

  Real showMessage( Real void )
  {
    Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj;



// Lunes, 2010/01/11 20:34:39.00
Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/Gui/Gui.tol");

//#Require "Gui";

Class @GuiTest_Hello : Gui::@MenuDesc
{
  Real a = 0;

  Real showMessage( Real void )
  {
    Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj = [[ Real a = 1 ]];



// Lunes, 2010/01/11 20:34:23.00
Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/Gui/Gui.tol");

//#Require "Gui";

Class @GuiTest_Hello : Gui::@MenuDesc
{
  Real a = 0;

  Real showMessage( Real void )
  {
    Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj = [[ Real a = 1 ]];



// Lunes, 2010/01/11 20:32:59.00
Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/Gui/Gui.tol");

//#Require "Gui";

Class @GuiTest_Hello : Gui::@MenuDesc
{
  Real a = 0;

  Real showMessage( Real void )
  {
    Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj;



// Lunes, 2010/01/11 20:31:49.00
Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/Gui/Gui.tol");

//#Require "Gui";

Class @GuiTest_Hello : Gui::@MenuDesc
{
  Real showMessage( Real void )
  {
    Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj;



// Lunes, 2010/01/11 20:21:37.00
#Embed "/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/Gui/Gui.tol";

//#Require "Gui";

Class @GuiTest_Hello : Gui::@MenuDesc
{
  Real showMessage( Real void )
  {
    Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj;



// Lunes, 2010/01/11 20:18:11.00
#Embed "/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/Gui/Gui.tol";

//#Require "Gui";

Class @GuiTest_Hello : Gui::@MenuDesc
{
  Real showMessage( Real void )
  {
    Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj;



// Lunes, 2010/01/11 20:16:20.00
Set Include( "/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/Gui/Gui.tol" );

//#Require "Gui";

Class @GuiTest_Hello : Gui::@MenuDesc
{
  Real showMessage( Real void )
  {
    Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj;



// Lunes, 2010/01/11 20:13:06.00
Set Include( "/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/Gui/Gui.tol" );

#Require "Gui";

Class @GuiTest_Hello : Gui::@MenuDesc
{
  Real showMessage( Real void )
  {
    Tcl_Eval( "tk_messageBox -message {Hola Mundo} -icon info" );
    Real 0
  };
  
  Set getMenuEntries(Real void) {
    Set [[ [[ "Hola ...", "showMessage" ]] ]]
  }
};

@GuiTest_Hello gui_obj;



// Viernes, 2010/01/08 14:07:25.00
Text host = "192.168.191.252";
Real port = 6668;
Text project = "";

Set tolargs = [[ [[ Text expr = "WriteLn(\"Hola mundo\")" ]] ]];

Set remote_args = [[ project, tolargs ]];

Real pid = RemoteTOL( host, port, remote_args );

WriteLn( "RemoteTOL = " << FormatReal( pid, "%.0f" ) );


// Viernes, 2010/01/08 13:11:22.00
Text host = "192.168.191.252";
Real port = 6668;
Text project = "";

Set tolargs = [[ [[ Text expr = "WriteLn(\"Hola mundo\")" ]] ]];

Set remote_args = [[ project, tolargs ]];

Real pid = RemoteTOL( host, port, remote_args );

WriteLn( "RemoteTOL = " << FormatReal( pid, "%.0f" ) );



// Jueves, 2010/01/07 19:05:29.00
Set Tcl_Eval(
"
  bind Text <Shift-Control-slash> {
    set start [ %W index sel.first ]
    set end [ %W index sel.last ]
    set selection [ %W get $start $end ]
    if { [ regsub -all {\\\\} $selection {/} changed ] } {
      %W delete $start $end
      %W insert $start $changed
    }
    break
  }
");


// Jueves, 2010/01/07 19:05:10.00
Set Tcl_Eval(
"
  bind Text <Shift-Control-slash> {
    set start [ %W index sel.first ]
    set end [ %W index sel.last ]
    set selection [ %W get $start $end ]
    if { [ regsub -all \"\\\\\" $selection {/} changed ] } {
      %W delete $start $end
      %W insert $start $changed
    }
    break
  }
");


// Jueves, 2010/01/07 19:04:40.00
Set Tcl_Eval(
"
  bind Text <Shift-Control-slash> {
    set start [ %W index sel.first ]
    set end [ %W index sel.last ]
    set selection [ %W get $start $end ]
    if { [ regsub -all \"\\\\\" $selection {/} changed ] } {
      %W delete $start $end
      %W insert $start $changed
    }
    break
  }
 }
");

// Jueves, 2010/01/07 19:03:33.00
Set Tcl_Eval(
"
  bind Text <Shift-Control-slash> {
    set start [ %W index sel.first ]
    set end [ %W index sel.last ]
    set selection [ %W get $start $end ]
    if { [ regsub -all {\\\\} $selection {/} changed ] } {
      %W delete $start $end
      %W insert $start $changed
    }
    break
  }
 }
");


// Jueves, 2010/01/07 19:03:06.00
Set Tcl_Eval(
"
  bind Text <Shift-Control-slash> {
    set start [ %W index sel.first ]
    set end [ %W index sel.last ]
    set selection [ %W get $start $end ]
    if { [ regsub -all {\\} $selection {/} changed ] } {
      %W delete $start $end
      %W insert $start $changed
    }
    break
  }
 }
");


// Jueves, 2010/01/07 19:02:48.00
Set Tcl_Eval(
"
  bind Text <Shift-Control-slash> {
    set start [ %W index sel.first ]
    set end [ %W index sel.last ]
    set selection [ %W get $start $end ]
    if { [ regsub -all {\\\} $selection {/} changed ] } {
      %W delete $start $end
      %W insert $start $changed
    }
    break
  }
 }
");


// Jueves, 2010/01/07 19:02:38.00
"
  bind Text <Shift-Control-slash> {
    set start [ %W index sel.first ]
    set end [ %W index sel.last ]
    set selection [ %W get $start $end ]
    if { [ regsub -all {\\\} $selection {/} changed ] } {
      %W delete $start $end
      %W insert $start $changed
    }
    break
  }
 }
");


// Jueves, 2010/01/07 19:02:03.00
Set Tcl_Eval(
"
  bind Text <Shift-Control-slash> {
    set start [ %W index sel.first ]
    set end [ %W index sel.last ]
    set selection [ %W get $start $end ]
    if { [ regsub -all {\\\\} $selection {/} changed ] } {
      %W delete $start $end
      %W insert $start $changed
    }
    break
  }
 }
");


// Jueves, 2010/01/07 19:01:05.00
Set Tcl_Eval(
"
  bind Text <Shift-Control-slash> {
    set start [ %W index sel.first ]
    set end [ %W index sel.last ]
    set selection [ %W get $start $end ]
    if { [ regsub -all {\\} $selection {/} changed ] } {
      %W delete $start $end
      %W insert $start $changed
    }
    break
  }
 }
");


// Jueves, 2010/01/07 18:59:38.00
Set Tcl_EvalEx([[
"
  bind Text <Shift-Control-slash> {
    set start [ %W index sel.first ]
    set end [ %W index sel.last ]
    set selection [ %W get $start $end ]
    if { [ regsub -all {\\} $selection {/} changed ] } {
      %W delete $start $end
      %W insert $start $changed
    }
    break
  }
"]]);


// Jueves, 2010/01/07 18:58:57.00
Set Tcl_Eval(
"
  bind Text <Shift-Control-slash> {
    set start [ %W index sel.first ]
    set end [ %W index sel.last ]
    set selection [ %W get $start $end ]
    if { [ regsub -all {\\} $selection {/} changed ] } {
      %W delete $start $end
      %W insert $start $changed
    }
    break
  }
");


// Martes, 2009/12/22 11:08:52.00
Real dim = 2;
Matrix XY = Rand( 20000, dim, 0, 1 );
Real id = ANN.KDTree.New( XY );
Real k = 10;
Set ANN.KDTree.KSearch( id, Rand( 100000, dim, 0, 1 ), k );
Real ANN.KDTree.Delete( id );



// Martes, 2009/12/22 00:51:33.00
Real dim = 2;
Matrix XY = Rand( 100000, dim, 0, 1 );
Real id = KDTree.New( XY );
Real k = 10;
Set KDTree.KSearch( id, Rand( 10000, dim, 0, 1 ), k );
Real KDTree.Delete( id );


// Martes, 2009/12/22 00:51:01.00
Real dim = 2;
Matrix XY = Rand( 100000, dim, 0, 1 );
Real id = KDTree.New( XY );
Reak k = 10;
Set KDTree.KSearch( id, Rand( 10000, dim, 0, 1 ), 10 );
Real KDTree.Delete( id );


// Martes, 2009/12/22 00:49:30.00
Matrix XY = Rand( 1000, 2, 0, 1 );
Real id = KDTree.New( XY );
Set KDTree.KSearch( id, Row(0.5,0.5), 10 );
Set KDTree.KSearch( id, Rand( 1000, 2, 0, 1 ), 10 );
Real KDTree.Delete( id );


// Martes, 2009/12/22 00:48:04.00
Matrix XY = Rand( 1000, 2, 0, 1 );
Real id = KDTree.New( XY );
Set KDTree.KSearch( id, Row(0.5,0.5), 10 );
Real KDTree.Delete( id );


// Martes, 2009/12/22 00:45:14.00
Matrix XY = Rand( 1000, 2, 0, 1 );
Real id = KDTree.New( XY );
Set KDTree.KSearch( id, Row(0.5,0.5), 10 );
Real KDTree.Delete( id );


// Martes, 2009/12/22 00:42:40.00
Matrix XY = Rand( 1000, 2, 0, 1 );
Real id = KDTree.New( XY );
Set KDTree.KSearch( id, Row(0.5,0.5), 10 );
Real KDTree.Delete( id );


// Martes, 2009/12/22 00:41:26.00
Real KDTree.Delete( id );

// Martes, 2009/12/22 00:40:59.00
Matrix XY = Rand( 1000, 2, 0, 1 );
Real id = KDTree.New( XY );


// Viernes, 2009/12/11 20:32:10.00
Set ss = [[ mySerT, mySerT1 ]];
Text TclTabulateSerie(ss, SetOfSet(
  @TclArgSt("-title","Tabulando una Serie")
));

// Viernes, 2009/12/11 20:31:33.00
Serie mySerT1 = Rand(-10, 10, Diario);

// Viernes, 2009/12/11 20:30:44.00
Text myTable3 = TclTabulateSerie(mySerT, SetOfSet(
  @TclArgSt("-title","Tabulando una Serie")
));


// Viernes, 2009/12/11 20:21:04.00
Text myTable3 = TclTabulateSerie(mySerT, SetOfSet(
  @TclArgSt("-title","Tabulando una Serie")
));

// Viernes, 2009/12/11 20:20:31.00
Text myTable2 = TclTabulateMatrix(myMatT, SetOfSet(
  @TclArgSt("-title","Tabulando una Matrix"),
  @TclArgSt("-geometry", "814x692+15+15")
));

// Viernes, 2009/12/11 20:19:53.00
Set mySetT = 
  SetOfSet(
    SetOfReal(1,2,3,4,5,6),
    SetOfReal(12,34,35,65,76,43),
    SetOfReal(3,7,4,2,9,6),
    SetOfReal(2,4,5,5,6,3)
  );

Matrix myMatT  = Rand(100,   10, -10, 10);
Serie mySerT = Rand(-10, 10, Diario);

Text myTable1 = TclTabulateSet(mySetT, SetOfSet(
    @TclArgSt("-title", "Tabulando un Set"),
    @TclArgSt("-geometry", "400x400+1+1")
));


// Viernes, 2009/12/11 19:42:53.00
Set mySetT = 
  SetOfSet(
    SetOfReal(1,2,3,4,5,6),
    SetOfReal(12,34,35,65,76,43),
    SetOfReal(3,7,4,2,9,6),
    SetOfReal(2,4,5,5,6,3)
  );
Text myTable1 = TclTabulateSet(mySetT, SetOfSet(
    @TclArgSt("-title", "Tabulando un Set"),
    @TclArgSt("-geometry", "400x400+1+1")
));


// Viernes, 2009/12/11 19:41:59.00
Matrix myMatT  = Rand(100,   10, -10, 10);
WriteLn("Tabulate Matrix ...");
Text myTable2 = TclTabulateMatrix(myMatT, SetOfSet(
  @TclArgSt("-title","Tabulando una Matrix"),
  @TclArgSt("-geometry", "814x692+15+15")
));


// Miercoles, 2009/12/09 19:25:56.00
Real TextToReal("456,34");


// Miercoles, 2009/12/09 11:36:51.00
Real TMX_Gestor = SqlEngine::GesRed;


// Miercoles, 2009/12/09 11:34:33.00
Real TMX_Gestor = StdLib::GesRed;

// Miercoles, 2009/12/09 11:34:12.00
Real TMX_Gestor = GesRed;


// Viernes, 2009/11/27 09:47:47.00
#Require "MatQuery";


// Viernes, 2009/11/27 09:44:41.00
#Requery MatQuery;


// Viernes, 2009/11/27 09:44:32.00
#Requery("MatQuery");


// Viernes, 2009/11/27 09:44:21.00
#Requery "MatQuery";

// Jueves, 2009/11/26 15:41:22.00
Set data_pred = variable_info::build_data_fore( variable_info::fore_args );

Real If( Not( Card( data_pred ) ), {
    Error( "No hay datos para predecir" );
    Real Stop
  } );

NameBlock df_pred = data_pred[ 1 ];
Set forecast = ForecastFromEstim( estim[ 1 ], df_pred );
Text output_name = (models[ 1 ])::_.output.name;
Text header = JoinTexts( [[ df_pred::GetObsIdColumnName(?),
                            Sub( output_name, 5, TextLength( output_name ) ),
                            output_name ]] <<
                         forecast::predictors, ";" );

Text file_export = TmpDir + "cnuc_fore_" + variable + ".csv";
Set BMTFile([[ forecast::ID | forecast::Yhat1 | forecast::Yhat0 | forecast::X ]],
            file_export,
            header, CIERTO, ";", "\n" );
WriteLn( "La prediccion ha sido exportada a " + file_export );

// Jueves, 2009/11/26 15:40:49.00
Set data_pred = variable_info::build_data_fore( variable_info::fore_args );

Real If( Not( Card( data_pred ) ), {
    Error( "No hay datos para predecir" );
    Real Stop
  } );

NameBlock df_pred = data_pred[ 1 ];
Set forecast = ForecastFromEstim( estim[ 1 ], df_pred );
Text output_name = (models[ 1 ])::_.output.name;
Text header = JoinTexts( [[ df_pred::GetObsIdColumnName(?),
                            Sub( output_name, 5, TextLength( output_name ) ),
                            output_name ]] <<
                         forecast::predictors, ";" );

Text file_export = TmpDir + "cnuc_fore_" + variable + ".csv";
Set BMTFile([[ forecast::ID | forecast::Yhat1 | forecast::Yhat0 | forecast::X ]],
            file_export,
            header, CIERTO, ";", "\n" );
WriteLn( "La prediccion ha sido exportada a " + file_export );



// Jueves, 2009/11/26 15:33:28.00
Set data_pred = variable_info::build_data_fore( variable_info::fore_args );

Real If( Not( Card( data_pred ) ), {
    Error( "No hay datos para predecir" );
    Real Stop
  } );

NameBlock df_pred = data_pred[ 1 ];
Set forecast = ForecastFromEstim( estim[ 1 ], df_pred );
Text output_name = (models[ 1 ])::_.output.name;
Text header = JoinTexts( [[ df_pred::GetObsIdColumnName(?),
                            Sub( output_name, 5, TextLength( output_name ) ),
                            output_name ]] <<
                         forecast::predictors, ";" );

Text file_export = TmpDir + "cnuc_fore_" + variable + ".csv";
Set BMTFile([[ forecast::ID | forecast::Yhat1 | forecast::Yhat0 | forecast::X ]],
            file_export,
            header, CIERTO, ";", "\n" );
WriteLn( "La prediccion ha sido exportada a " + file_export );

// Jueves, 2009/11/26 15:18:24.00
Set data_pred = variable_info::build_data_fore( variable_info::fore_args );

Real If( Not( Card( data_pred ) ), {
    Error( "No hay datos para predecir" );
    Real Stop
  } );

NameBlock df_pred = data_pred[ 1 ];
Set forecast = ForecastFromEstim( estim[ 1 ], df_pred );
Text output_name = (models[ 1 ])::_.output.name;
Text header = JoinTexts( [[ df_pred::GetObsIdColumnName(?),
                            Sub( output_name, 5, TextLength( output_name ) ),
                            output_name ]] <<
                         forecast::predictors, ";" );

Text file_export = TmpDir + "cnuc_fore_" + variable + ".csv";
Set BMTFile([[ forecast::ID | forecast::Yhat1 | forecast::Yhat0 | forecast::X ]],
            file_export,
            header, CIERTO, ";", "\n" );
WriteLn( "La prediccion ha sido exportada a " + file_export );

// Jueves, 2009/11/26 15:12:15.00
Set data_pred = variable_info::build_data_fore( variable_info::fore_args );

Real If( Not( Card( data_pred ) ), {
    Error( "No hay datos para predecir" );
    Real Stop
  } );

NameBlock df_pred = data_pred[ 1 ];
Set forecast = ForecastFromEstim( estim[ 1 ], df_pred );
Text output_name = (models[ 1 ])::_.output.name;
Text header = JoinTexts( [[ df_pred::GetObsIdColumnName(?),
                            Sub( output_name, 5, TextLength( output_name ) ),
                            output_name ]] <<
                         forecast::predictors, ";" );

Text file_export = TmpDir + "cnuc_fore_" + variable + ".csv";
Set BMTFile([[ forecast::ID | forecast::Yhat1 | forecast::Yhat0 | forecast::X ]],
            file_export,
            header, CIERTO, ";", "\n" );
WriteLn( "La prediccion ha sido exportada a " + file_export );

// Jueves, 2009/11/26 14:35:28.00
FindCode( "NameBlock", "BuildModelNucleosL3GTarifa" )


// Jueves, 2009/11/26 13:25:28.00
NameBlock forecast_args = 
[[
  Real lower_vol3g = -1;
  Real lower_duracion_voz = -1;
  Real lower_cob_ba = -1;
  Real lower_cob_3g = 0.2;
  Real is_estim = 0;
  Real rebuild = 1
]];

NameBlock ld = LoaderDataNucleo( RaDe3G.DB::rade3g, forecast_args );
Set data = ld::LoadData( 1 );

// Jueves, 2009/11/26 13:21:55.00
NameBlock estim_args = 
[[
  Real lower_vol3g = -1;
  Real lower_duracion_voz = 1000;
  Real lower_cob_ba = 0.05;
  Real lower_cob_3g = 0.2;
  Real is_estim = 1;
  Real rebuild = 1
]];

NameBlock ld = LoaderDataNucleo( RaDe3G.DB::rade3g, estim_args );
Set data = ld::LoadData( 1 );

// Jueves, 2009/11/26 13:21:08.00
NameBlock estim_args = 
[[
  Real lower_vol3g = -1;
  Real lower_duracion_voz = 1000;
  Real lower_cob_ba = 0.05;
  Real lower_cob_3g = 0.2;
  Real is_estim = 1;
  Real rebuild = 1
]];

NameBlock ld = LoaderDataNucleo( RaDe3G.DB::rade3g, estim_args );
Set data = ld::LoadData( 0 );

// Jueves, 2009/11/26 13:20:10.00
NameBlock estim_args = 
[[
  Real lower_vol3g = -1;
  Real lower_duracion_voz = 1000;
  Real lower_cob_ba = 0.05;
  Real lower_cob_3g = 0.2;
  Real is_estim = 1;
  Real rebuild = 1
]];

NameBlock ld = LoaderDataNucleo( RaDe3G.DB::rade3g, estim_args );
Set data = ld::LoadData( 0 );

// Jueves, 2009/11/26 13:19:43.00
NameBlock estim_args = 
[[
  Real lower_vol3g = -1;
  Real lower_duracion_voz = 1000;
  Real lower_cob_ba = 0.05;
  Real lower_cob_3g = 0.2;
  Real is_estim = 1;
  Real rebuild = 1
]];

NameBlock ld = LoaderDataNucleo( RaDe3G.DB::rade3g, estim_args );
Set data = ld::LoadData( 0 );

// Jueves, 2009/11/26 13:19:29.00
NameBlock estim_args = 
[[
  Real lower_vol3g = -1;
  Real lower_duracion_voz = 1000;
  Real lower_cob_ba = 0.05;
  Real lower_cob_3g = 0.2;
  Real is_estim = 1;
  Real rebuild = 1
]];

NameBlock ld = LoaderDataNucleo( RaDe3G.DB::rade3g, estim_args );
Set data = ld::LoadData( 0 );

// Jueves, 2009/11/26 13:16:04.00
NameBlock estim_args = 
[[
  Real lower_vol3g = -1;
  Real lower_duracion_voz = 1000;
  Real lower_cob_ba = 0.05;
  Real lower_cob_3g = 0.2;
  Real is_estim = 1;
  Real rebuild = 1
]];

NameBlock ld = LoaderDataNucleo( RaDe3G.DB::rade3g, estim_args );
Set data = ld::LoadData( 0 );

// Jueves, 2009/11/26 13:14:49.00
NameBlock estim_args = 
[[
  Real lower_vol3g = -1;
  Real lower_duracion_voz = 1000;
  Real lower_cob_ba = 0.05;
  Real lower_cob_3g = 0.2;
  Real is_estim = 1;
  Real rebuild = 1
]];

NameBlock LoaderDataNucleo( RaDe3G.DB::rade3g, estim_args );

// Miercoles, 2009/11/25 19:06:54.00

/*

// Miercoles, 2009/11/25 09:48:13.00
Real TMX_Gestor = GesRed;
Real estudio::TblFillAllVariables    (0);


// Miercoles, 2009/11/25 09:40:51.00
Real estudio::TblFillAllVariables    (0);


// Miercoles, 2009/11/25 09:40:12.00
Real UsingNameBlock( StdLib::SqlEngine );

// Miercoles, 2009/11/25 09:36:04.00
Real estudio::TblFillAllVariables    (0);

// Miercoles, 2009/11/25 09:35:22.00
Real UsingNameBlock( StdLib::SqlEngine );

// Miercoles, 2009/11/25 09:31:23.00
Real estudio::TblFillAllVariables    (0);


// Miercoles, 2009/11/18 20:19:55.00
Text output_name = (models[ 1 ])::_.output.name

// Miercoles, 2009/11/18 20:12:04.00
Text header = JoinTexts( [[ df_pred::GetObsIdColumnName(?) ]] <<
                         forecast::predictors, ";" );


Set BMTFile([[ forecast::ID | forecast::Yhat1 | forecast::X1 ]],
            "/tmp/cnuc_fore_big_screen.csv",
            header, CIERTO, ";", "\n" );



// Miercoles, 2009/11/18 20:10:35.00
Text header = JoinTexts( [[ df_pred::GetObsIdColumnName(?) ]] <<
                         forecast::predictors, ";" );


Set BMTFile([[ forecast.output ]], "/tmp/cnuc_fore_big_screen.csv",
            header, CIERTO, ";", "\n" );



// Miercoles, 2009/11/18 20:10:16.00
Text header = JoinTexts( [[ df_pred::GetObsIdColumnName(?) ]] <<
                         forecast::predictos, ";" );

// Miercoles, 2009/11/18 13:21:58.00
Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/MatQuery/MatQuery.tol" );
Set names = [[ "A", "B", "C" ]];
Text JoinTexts( Set items, Text joiner )
{
  Real card = Card( items );
  Text
    SetSum( For( 1, card - 1, Text( Real k ) { items[k] + joiner } ) ) <<
    items[ card ]
};

Text JoinTexts( names, ";" );


// Miercoles, 2009/11/18 13:05:54.00
Set forecast = ForecastFromEstim( estim[ 1 ], data_pred[ 1 ] );

// Miercoles, 2009/11/18 12:08:55.00
NameBlock estim[1][nn];

// Miercoles, 2009/11/18 12:08:41.00
Text nn = Name(estim[ 1 ]);
NameBlock estim[nn];

// Miercoles, 2009/11/18 12:07:22.00
Text Name(estim[ 1 ]);

// Miercoles, 2009/11/18 11:13:44.00
Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/MatQuery/MatQuery.tol" );

 Set predictors = 
    [[ 
       "Log_V3G",
       "Log_PERC_COB_2G",
       "Log_PERC_COB_3G",
       "Log_PERC_COB_BA",
       "Log_POB",
       "Log_POB_NO_COB_BA",
       "Log_LINEAS_RTB"
    ]];
Matrix X = df::GetMatrix( predictors );
VMatrix M = Mat2VMat( X );
VMatrix M.known = Not(IsUnknown(M)*Rand(VColumns(M),1,1,1));

VMatrix unk.match_ = MatQuery::MatchRowsWithValue(M.known,0);

Set sel.known = MatQuery::SelectMatch(Not(unk.match_));
Set sel.unknown = MatQuery::SelectMatch(unk.match_);

VMatrix extract.unknown = SubRow(M, sel.unknown);
VMatrix extract.known = SubRow(M, sel.known);




// Miercoles, 2009/11/18 11:12:43.00
Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/MatQuery/MatQuery.tol" );

 Set predictors = 
    [[ 
       "Log_V3G",
       "Log_PERC_COB_2G",
       "Log_PERC_COB_3G",
       "Log_PERC_COB_BA",
       "Log_POB",
       "Log_POB_NO_COB_BA",
       "Log_LINEAS_RTB"
    ]];
Matrix X = df::GetMatrix( predictors );
VMatrix M = Mat2VMat( X );
VMatrix M.known = Not(IsUnknown(M)*Rand(VRows(M),1,1,1));

VMatrix unk.match_ = MatQuery::MatchRowsWithValue(M.known,0);

Set sel.known = MatQuery::SelectMatch(Not(unk.match_));
Set sel.unknown = MatQuery::SelectMatch(unk.match_);

VMatrix extract.unknown = SubRow(M, sel.unknown);
VMatrix extract.known = SubRow(M, sel.known);




// Miercoles, 2009/11/18 11:11:01.00
Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/MatQuery/MatQuery.tol" );

 Set predictors = 
    [[ 
       "Log_V3G",
       "Log_PERC_COB_2G",
       "Log_PERC_COB_3G",
       "Log_PERC_COB_BA",
       "Log_POB",
       "Log_POB_NO_COB_BA",
       "Log_LINEAS_RTB"
    ]];
Matrix X = df::GetMatrix( predictors );
VMatrix M = Mat2VMat( X );
VMatrix M.known = Not(IsUnknown(M)*Rand(Rows(M),1,1,1));

VMatrix unk.match_ = MatQuery::MatchRowsWithValue(M.known,0);

Set sel.known = MatQuery::SelectMatch(Not(unk.match_));
Set sel.unknown = MatQuery::SelectMatch(unk.match_);

VMatrix extract.unknown = SubRow(M, sel.unknown);
VMatrix extract.known = SubRow(M, sel.known);




// Miercoles, 2009/11/18 11:10:15.00
Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/MatQuery/MatQuery.tol" );

 Set predictors = 
    [[ 
       "Log_V3G",
       "Log_PERC_COB_2G",
       "Log_PERC_COB_3G",
       "Log_PERC_COB_BA",
       "Log_POB",
       "Log_POB_NO_COB_BA",
       "Log_LINEAS_RTB"
    ]];
Matrix X = df::GetMatrix( predictors );
VMatrix M = Mat2VMat( X );
VMatrix M.known = Not(IsUnknown(M)*Rand(n,1,1,1));

VMatrix unk.match_ = MatQuery::MatchRowsWithValue(M.known,0);

Set sel.known = MatQuery::SelectMatch(Not(unk.match_));
Set sel.unknown = MatQuery::SelectMatch(unk.match_);

VMatrix extract.unknown = SubRow(M, sel.unknown);
VMatrix extract.known = SubRow(M, sel.known);




// Miercoles, 2009/11/18 11:07:29.00
Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/MatQuery/MatQuery.tol" );

 Set predictors = 
    [[ 
       "Log_V3G",
       "Log_PERC_COB_2G",
       "Log_PERC_COB_3G",
       "Log_PERC_COB_BA",
       "Log_POB",
       "Log_POB_NO_COB_BA",
       "Log_LINEAS_RTB"
    ]];
Matrix X = df::GetMatrix( [["Log_V3G"]] );
VMatrix M = Mat2VMat( X );

VMatrix unk.match_ = MatQuery::MatchRowsWithValue(M,?);

Set sel.known = MatQuery::SelectMatch(Not(unk.match_));
Set sel.unknown = MatQuery::SelectMatch(unk.match_);

VMatrix extract.unknown = SubRow(M, sel.unknown);
VMatrix extract.known = SubRow(M, sel.known);




// Miercoles, 2009/11/18 10:33:32.00
Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/MatQuery/MatQuery.tol" );

 Set predictors = 
    [[ 
       "Log_V3G",
       "Log_PERC_COB_2G",
       "Log_PERC_COB_3G",
       "Log_PERC_COB_BA",
       "Log_POB",
       "Log_POB_NO_COB_BA",
       "Log_LINEAS_RTB"
    ]];
Matrix X = df::GetMatrix( predictors );
VMatrix M = Mat2VMat( X );

VMatrix unk.match_ = MatQuery::MatchRowsWithValue(M,?);

Set sel.known = MatQuery::SelectMatch(Not(unk.match_));
Set sel.unknown = MatQuery::SelectMatch(unk.match_);

VMatrix extract.unknown = SubRow(M, sel.unknown);
VMatrix extract.known = SubRow(M, sel.known);




// Miercoles, 2009/11/18 10:30:35.00
Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/MatQuery/MatQuery.tol" );

 Set predictors = 
    [[ 
       "Log_V3G",
       "Log_PERC_COB_2G",
       "Log_PERC_COB_3G",
       "Log_PERC_COB_BA",
       "Log_POB",
       "Log_POB_NO_COB_BA",
       "Log_LINEAS_RTB"
    ]];
Matrix X = df::GetMatrix( predictors );
VMatrix M = Mat2VMat( X );

VMatrix unk.match_ = MatQuery::MatchRowsWithValue(M,?);

Set sel.known = MatQuery::SelectMatch(Not(unk.match_));




// Miercoles, 2009/11/18 10:29:50.00
Set Include("/home/jsperez/TOL/FROM_SVN/tolp/trunk/tol_pkg/MatQuery/MatQuery.tol" );

 Set predictors = 
    [[ 
       "Log_V3G",
       "Log_PERC_COB_2G",
       "Log_PERC_COB_3G",
       "Log_PERC_COB_BA",
       "Log_POB",
       "Log_POB_NO_COB_BA",
       "Log_LINEAS_RTB"
    ]];
Matrix X = data.frame::GetMatrix( predictors );
VMatrix M = Mat2VMat( X );

VMatrix unk.match_ = MatQuery::MatchRowsWithValue(M,?);

Set sel.known = MatQuery::SelectMatch(Not(unk.match_));




// Miercoles, 2009/11/18 00:56:04.00
Real GuiPlotModelVSNoise (GetObjectFromAddress("9A77120:0:8A1B1E0:0:884B280:0:2:4:4") )

// Lunes, 2009/11/16 14:21:23.00
Set BMTFile([[ forecast.output ]], "/tmp/cnuc_fore.csv",
            "CNUC;Y_DURACION_VOZ;CTE;Log_POB;Log_RTB;Log_STATUSMUN;Log_VOL3GPOT",CIERTO,";","\n");



// Lunes, 2009/11/16 14:18:33.00
Set BMTFile([[ forecast.output ]], "/tmp/cnuc_fore.csv",
            "CNUC;Y;CTE;Log_POB;Log_RTB;Log_STATUSMUN;Log_VOL3GPOT",CIERTO,";","\n");



// Lunes, 2009/11/16 14:09:31.00
NameBlock BysMcmc::@Config::Default(?);

// Lunes, 2009/11/16 14:08:52.00
NameBlock BysMcmc::Config::Default(?);

// Lunes, 2009/11/16 14:05:59.00
Real Compare( "v2.0", Text Sub(Version, 1, 4) );


// Lunes, 2009/11/16 14:05:40.00
Real Compare( "v2.0", Sub(Version, 1, 4) );


// Lunes, 2009/11/16 14:05:16.00
Real Compare( "v2.0", Version );


// Lunes, 2009/11/16 13:59:28.00
Real Compare( "v2.0", Version );


// Viernes, 2009/11/13 13:27:27.00
Text measure = "VOL_3G_DENS";
Set corrFunct = spDiscrete::GetCorrelationFunction( measure );
Real x = 450114.0; Real y = 4496747.0;

Set nbr_info =  spDiscrete::_.bin2d::GetNearestSet( x, y, spDiscrete::_.radius );

    Set psi_values = Copy( Empty );

    Set nbr_id = EvalSet( nbr_info, Real( Set info ) {
        Real rank = spDiscrete::_.edge_ranker::GetRankDistanceSquare( info[ 2 ] );
        Set Append( psi_values, [[ corrFunct[ rank ] ]] );
        Real spDiscrete::_.subgraph::get.vertex.index( spDiscrete::_.spatial_info::GetUnitIdFromIndex( info[ 1 ] ) )
      } );
    VMatrix Psi = Mat2VMat( SetCol( psi_values ) );

    Set triplet = Copy( Empty );
    Real N = Card( nbr_id );

    Set For( 1, N - 1, Real( Real I ) {
        // indice en el grafo de la unidad de observacion de la fila
        // I-esima
        Real idx_I = nbr_id[ I ];
        // este for excluye la diagonal
        Set Append( triplet, For( I + 1, N, Set( Real J ) {
              // indice en el grafo de la unidad de observacion de la
              // columna J-esima
              Real idx_J = nbr_id[ J ];
              // la arista (idx_I,idx_J) ya tiene el rank calculado
              Real eidx = spDiscrete::_.subgraph::get.edge.index( idx_I, idx_J );
WriteLn( "("<<idx_I<<","<<idx_J<<") = "<<eidx );
              Real ro = If( eidx, {
                  Real rank = spDiscrete::_.subgraph::get.edge.feature( eidx, "Rank" );
WriteLn( "Rank = "<<rank );
                  Real corrFunct[ rank ]
                }, 0.0 );
              [[ I, J, ro ]]
            } ) );
        Real 0
      } );



// Viernes, 2009/11/13 13:20:34.00
    Set triplet = Copy( Empty );
    Real N = Card( nbr_id );

    Set For( 1, N - 1, Real( Real I ) {
        // indice en el grafo de la unidad de observacion de la fila
        // I-esima
        Real idx_I = nbr_id[ I ];
        // este for excluye la diagonal
        Set Append( triplet, For( I + 1, N, Set( Real J ) {
              // indice en el grafo de la unidad de observacion de la
              // columna J-esima
              Real idx_J = nbr_id[ J ];
              // la arista (idx_I,idx_J) ya tiene el rank calculado
              Real eidx = spDiscrete::_.subgraph::get.edge.index( idx_I, idx_J );
              Real ro = If( eidx, {
                  Real rank = spDiscrete::_.subgraph::get.edge.feature( eidx, "Rank" );
                  Real corrFunct[ rank ]
                }, 0.0 );
              [[ I, J, ro ]]
            } ) );
        Real 0
      } );


// Viernes, 2009/11/13 13:17:13.00
Text measure = "VOL_3G_DENS";
Set corrFunct = spDiscrete::GetCorrelationFunction( measure );
Real x = 450114.0; Real y = 4496747.0;

Set nbr_info =  spDiscrete::_.bin2d::GetNearestSet( x, y, spDiscrete::_.radius );

    Set psi_values = Copy( Empty );

    Set nbr_id = EvalSet( nbr_info, Real( Set info ) {
        Real rank = spDiscrete::_.edge_ranker::GetRankDistanceSquare( info[ 2 ] );
        Set Append( psi_values, [[ corrFunct[ rank ] ]] );
        Real spDiscrete::_.subgraph::get.vertex.index( spDiscrete::_.spatial_info::GetUnitIdFromIndex( info[ 1 ] ) )
      } );
    VMatrix Psi = Mat2VMat( SetCol( psi_values ) );



// Viernes, 2009/11/13 13:14:44.00
Text measure = "VOL_3G_DENS";
Set corrFunct = spDiscrete::GetCorrelationFunction( measure );
Real x = 450114.0; Real y = 4496747.0;

Set nbr_info =  spDiscrete::_.bin2d::GetNearestSet( x, y, spDiscrete::_.radius );


// Viernes, 2009/11/13 13:14:29.00
Text measure = "VOL_3G_DENS"
Set corrFunct = spDiscrete::GetCorrelationFunction( measure );
Real x = 450114.0; Real y = 4496747.0;

Set nbr_info =  spDiscrete::_.bin2d::GetNearestSet( x, y, spDiscrete::_.radius );


// Viernes, 2009/11/13 13:09:58.00
Matrix VMat2Mat( corrXY::Sigma );

// Viernes, 2009/11/13 11:15:01.00
NameBlock tm1 = Timer::Start( "ComputeCorrelation" );
Real spDiscrete::ComputeCorrelation( "VOL_3G_DENS" );
Real tm1::Finish(?);

// Viernes, 2009/11/13 10:59:33.00
Matrix spDiscrete::_.spatial_info::GetMeasureForObsSet(name, "VOL_3G_DENS");

// Viernes, 2009/11/13 10:55:08.00
Set name = spDiscrete::_.subgraph::get.vertex.names(?);


// Jueves, 2009/11/12 10:10:25.00
#Require GraphTools;


// Martes, 2009/11/10 10:49:48.00
Matrix MM = Rand( 3,1,1,1) << Rand( 3, 1, 2, 2 );
Set GisTools::SelectRowsWithValue(Matrix MM, Real 2)


// Martes, 2009/11/10 10:49:06.00
Matrix MM = Rand( 3,1,1,1);
Set GisTools::SelectRowsWithValue(Matrix MM, Real 1)


// Martes, 2009/11/10 10:48:59.00
Matrix MM = Rand( 3,1,1,1);
Set GisTools::SelectRowsWithValue(Matrix MM, Real 3)


// Martes, 2009/11/10 10:48:31.00
Matrix MM = Rand( 3,3,1,1);
Set GisTools::SelectRowsWithValue(Matrix MM, Real 3)

// Martes, 2009/11/10 10:48:20.00
Matrix MM = Rand( 3,3,1,1);
Set SelectRowsWithValue(Matrix MM, Real 3)


// Lunes, 2009/11/09 09:01:42.00
NameBlock tm3 = Timer::Start( "GetCorrelationStructureForXY" );
Set P_2800577 = [[ 450114.0, 4496747.0 ]];
Set corrXY =
  spDiscrete::GetCorrelationStructureForXY( P_2800577[ 1 ], P_2800577[ 2 ],
                                            "VOL_3G_DENS" );
Real tm3::Finish(?);

// Lunes, 2009/11/09 08:58:46.00
NameBlock tm2 = Timer::Start( "Difference" );
Real spDiscrete::Difference( "VOL_3G_DENS" );
Real tm2::Finish(?);


// Lunes, 2009/11/09 00:04:44.00
NameBlock df = LoadDensificationData( "dens_data", 2, 28 );

// Lunes, 2009/11/09 00:03:24.00
 NameBlock df = LoadDensificationData( "dens_data", 2, 28 );

// Domingo, 2009/11/08 18:26:36.00
  Real RaDe3G.DB::rade3g::Activate(?);
  Set LoadGraphInfo( "dens_graph_single", 28, 800 );


// Domingo, 2009/11/08 18:18:14.00
 Real RaDe3G.DB::rade3g::Activate(?);
  Set LoadGraphInfo( "dens_graph_single", 28, 800 );

// Domingo, 2009/11/08 16:57:03.00
Set edge_data1 := Copy( Empty );


// Viernes, 2009/11/06 16:33:49.00
@DiscreteDistance dd1 = spDiscrete::GetEdgesBin(?)::GetDiscreteDistance(?);

// Viernes, 2009/11/06 16:33:10.00
@DiscreteDistance dd = eb::GetDiscreteDistance(?);

// Viernes, 2009/11/06 16:32:06.00
@EdgesBin eb = spDiscrete::GetEdgesBin(?);


// Viernes, 2009/11/06 15:29:23.00
Set spDiscrete::GetSpatialInfo(?)::GetPointCoords(3880); 
Real spDiscrete::GetSpatialInfo(?)::GetUnitIdFromIndex(3880); 

// Viernes, 2009/11/06 15:27:46.00
Set spDiscrete::GetSpatialInfo(?)::GetPointCoords(3880); 


// Viernes, 2009/11/06 00:23:27.00
Real spDiscrete::_.spatial_info::GetMeasureForUnit( 100139, "VOL_3G" );

// Viernes, 2009/11/06 00:23:16.00
Real spDiscrete::_.spatial_info::GetMeasureForUnit( 100139, "VOL_3G" );

// Viernes, 2009/11/06 00:08:37.00
NameBlock tm2 = Timer::Start( "Difference" );
Real spDiscrete::Difference( "VOL_3G_DENS" );
Real tm2::Finish(?);


// Viernes, 2009/11/06 00:08:12.00
Real spDiscrete::_.spatial_info::GetMeasureForUnit( 100002, "VOL_3G" );

// Viernes, 2009/11/06 00:05:38.00
Real spDiscrete::_.spatial_info::GetMeasureForUnit( 100002, "VOL_3G" );

// Viernes, 2009/11/06 00:03:55.00
Real spDiscrete::_.spatial_info::GetMeasureForUnit( 100002, "VOL_3G" );


// Viernes, 2009/11/06 00:03:46.00
Real spDiscrete::_.spatial_info::GetMeasureForUnit( 100002, "VOL_3G" );


// Jueves, 2009/11/05 23:50:37.00
NameBlock tm2 = Timer::Start( "Difference" );
Real spDiscrete::Difference( "VOL_3G_DENS" );
Real tm2::Finish(?);

// Jueves, 2009/11/05 23:50:09.00
NameBlock tm2 = Timer::Start( "Difference" );
Real spDiscrete::ComputeCorrelation( "Difference" );
Real tm2::Finish(?);


// Jueves, 2009/11/05 23:43:03.00
Real Ois.Store( Set For( 1, 100000, @SpatialEdge( Real k ) { spDiscrete::_.subgraph::._edges_info[k] } ), "/tmp/kk" );


// Jueves, 2009/11/05 22:00:03.00
Set Include( "/home/jsperez/TOL/projects/bsd/entity/PrjTfnEspRaDe3g/data/densification/dens_spdiscrete_old" );


// Jueves, 2009/11/05 19:09:51.00
Text Ois.PutDefaultSerialEngine("_ZZ_")


// Jueves, 2009/11/05 19:09:41.00
Text Ois.PutDefaultSerialEngine("_BZIP2_")


// Jueves, 2009/11/05 19:06:13.00
Text Ois.PutDefaultSerialEngine("_NONE_")


// Jueves, 2009/11/05 19:05:39.00
Text PutDefaultSerialEngine("_NONE_")


// Jueves, 2009/11/05 17:29:35.00
Real Ois.Store( [[ spDiscrete ]], /tmp/spkk );


// Jueves, 2009/11/05 10:21:20.00
Set Include( "/home/jsperez/TOL/projects/bsd/entity/PrjTfnEspRaDe3g/data/densification/dens_spdiscrete_old.oza" );


// Jueves, 2009/11/05 10:13:01.00
Set Include( "../../../data/densification/dens_spdiscrete_new.oza" );


// Miercoles, 2009/11/04 18:38:35.00
Matrix m = Col( 1, 2);
Matrix MtMSqr( m );


// Miercoles, 2009/11/04 18:35:42.00
Real spDiscrete::ComputeCorrelation( "L_3G_DENS_UNSAT_I_WEIGHTED" );

// Miercoles, 2009/11/04 18:32:17.00
Real spDiscrete::ComputeCorrelation( "L_3G_DENS_UNSAT_I_WEIGHTED" );

// Miercoles, 2009/11/04 18:28:32.00
Real spDiscrete::ComputeCorrelation( "L_3G_DENS_UNSAT_I_WEIGHTED" );

// Miercoles, 2009/11/04 18:15:47.00
Real spDiscrete::ComputeCorrelation( "L_3G_DENS_UNSAT_I_WEIGHTED" );

// Miercoles, 2009/11/04 18:13:21.00
Real spDiscrete::ComputeCorrelation( "L_3G_DENS_UNSAT_I_WEIGHTED" );

// Miercoles, 2009/11/04 18:09:22.00
Real spDiscrete::ComputeCorrelation( "L_3G_DENS_UNSAT_I_WEIGHTED" );

// Miercoles, 2009/11/04 18:06:48.00
Real spDiscrete::ComputeCorrelation( "L_3G_DENS_UNSAT_I_WEIGHTED" );

// Miercoles, 2009/11/04 18:06:24.00
Real spDiscrete::ComputeCorrelation( L_3G_DENS_UNSAT_I_WEIGHTED );

// Miercoles, 2009/11/04 14:10:22.00
Real searchSpacing = 1000;

@SpatialDiscrete spDiscrete =
  @SpatialDiscrete::NewSG( spInfo, searchSpacing,
                           subgraph, partition );



// Miercoles, 2009/11/04 13:42:09.00
@DiscreteDistance partition = 
  @DiscreteDistance::New( Range( 300, 1000, 100 ) ); 

// Miercoles, 2009/11/04 10:01:50.00
Real 2^2

// Miercoles, 2009/11/04 09:23:30.00
Class @A {
  Real a = 1
};

@A a;

@A b = a;

Real b::a := 2;


// Miercoles, 2009/11/04 09:17:18.00
NameBlock df = LoadDensificationData( 0 );
  Set df::GetVectorForObsId( "5001084", [[ "X_30", "Y_30" ]] );

// Miercoles, 2009/11/04 09:10:31.00
Set df::GetVectorForObsId( "5001084", [[ "X_30", "Y_30" ]] );

// Miercoles, 2009/11/04 09:09:58.00
NameBlock df = LoadDensificationData( 0 );
  Set df::GetVariablesForObs( "5001084", [[ "X_30", "Y_30" ]] );

// Martes, 2009/11/03 18:54:11.00
Class @A;

Class @B : @A
{
  Real F(Real a ) { a }
};

// Martes, 2009/11/03 18:01:34.00
/*
  @DiscreteDistance -- discretiza un intervalo segun un conjunto de puntos
 */
Class @DiscreteDistance
{
  Set _.knots;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfIntervals( Real void ) { Real Card( _.knots ) - 1 };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetRankDistance( Real dist )
///////////////////////////////////////////////////////////////////////////////
  {
    Real _bin_search( dist, 1, Card( _.knots ) )
  };

///////////////////////////////////////////////////////////////////////////////
  Real _bin_search( Real dist, Real low, Real high )
///////////////////////////////////////////////////////////////////////////////
  {
    Real If( EQ( high - low, 1 ), low, {
        Real mid = Floor( ( low + high ) / 2 );
        Real knot = _.knots[ mid ];
        If( dist < knot,
            _bin_search( dist, low, mid ),
            _bin_search( dist, mid, high ) )
      } )
  };
  
  Static @DiscreteDistance New( Set knots )
  {
    @DiscreteDistance obj =
      [[
        Set _.knots = [[ 0 ]] << knots
      ]]  
  }
};

Class @SpatialSubGraph
{
  Set _.nodes_info;
  Set _.edges_info;
  Real _.radius = 3000;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfNodes( Real void ) { Real Card( _.nodes_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfEdges( Real void ) { Real Card( _.edges_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetNodeId( Real index )
///////////////////////////////////////////////////////////////////////////////
  {
    Real _.nodes_info[ index ]
  };
  
///////////////////////////////////////////////////////////////////////////////
  Real GetNodeIndex( Real id )
///////////////////////////////////////////////////////////////////////////////
  {
    Text key = @SpatialSubGraph::hashNode( id );
    Real idx = FindIndexByName( _.nodes_info, key )
  };

///////////////////////////////////////////////////////////////////////////////
  Set GetEdgeInfo( Real k )
///////////////////////////////////////////////////////////////////////////////
  {
    Text name = Name( _.edges_info[ k ] );
    Set ids = @SpatialSubGraph::invertHashEdge( name );
    Set [[ ids, Set info = _.edges_info[ k ] ]]
  };
  
///////////////////////////////////////////////////////////////////////////////
  Real GetDistance( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::hashEdge( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

///////////////////////////////////////////////////////////////////////////////
  Real GetEdgeLabel( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::hashEdge( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.

    Ahora mismo es dependiente de la tabla dens_graph_single.
   */
///////////////////////////////////////////////////////////////////////////////
  Static @SpatialSubGraph NewSQL( NameBlock dbconn, Real EdgeThreshold )
///////////////////////////////////////////////////////////////////////////////
  {
    Real dbconn::Activate( ? );

    WriteLn( "Consultando aristas de la base de datos ..." );
    Text query_edges =
      "SELECT * FROM dens_graph_single_new WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query_edges );
    WriteLn( "Indexando aristas ..." );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::hashEdge( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );

    WriteLn( "Consultando nodos de la base de datos" );
    Text query_nodes =
      "SELECT ID_EMP_1 FROM dens_graph_new WHERE dist < " <<
      EdgeThreshold + " GROUP BY id_emp_1";
    Set nodes = DBTable( query_nodes );
    Set nodes_info = EvalSet( nodes, Real( Set node ) {
        Real id = node[ 1 ];
        Text name = FormatReal( id, "%.0f" );
        Real PutName( name, id )
      } );
    Real SetIndexByName( nodes_info );
   

    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.nodes_info = nodes_info;
      Set _.edges_info = edges_info
    ]]
  };

///////////////////////////////////////////////////////////////////////////////
  Static Text hashNode(  Real id )
///////////////////////////////////////////////////////////////////////////////
  {
    Text FormatReal( id, "%.0f")
  };

///////////////////////////////////////////////////////////////////////////////
  Static Text hashEdge(  Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  };

///////////////////////////////////////////////////////////////////////////////
  Static Set invertHashEdge(  Text hash  )
///////////////////////////////////////////////////////////////////////////////
  {
    Set Eval( "SetOfReal(" + hash + ")" )
  }

};

Class @EdgesBin
{
  Set _.edges_bin;
  @DiscreteDistance _.partition;
  
  Set _.rank1;                    // Contiene para cada nodo el
                                  // conjunto de vecinos de primer
                                  // rango.
  
///////////////////////////////////////////////////////////////////////////////
  @DiscreteDistance GetPartition( Real void ) { _.partition };
///////////////////////////////////////////////////////////////////////////////
  
///////////////////////////////////////////////////////////////////////////////
  Set GetEdgesInBin( Real bin )
///////////////////////////////////////////////////////////////////////////////
  {
    Set _.edges_bin[ bin ]
  };

///////////////////////////////////////////////////////////////////////////////
  Static @EdgesBin New( @SpatialSubGraph subgraph, @DiscreteDistance partition )
///////////////////////////////////////////////////////////////////////////////
  {
    // inicializo vecinos de primer orden de los nodos
    Set rank1 = For( 1, subgraph::GetNumberOfNodes(?), Set( Real k ) {
        Copy( Empty )
      } );
    
    // inicializo particionamiento de las aristas segun longitud
    Set edges_bin =
      For( 1, partition::GetNumberOfIntervals(?), Set( Real k ) {
          Set Copy( Empty )
        } );
    // recorro las aristas del grafo particionandolas y creando los
    // vecinos de primer orden.
    Set For( 1, subgraph::GetNumberOfEdges(?), Real( Real k ) {
        If( Not( (k-1) % 1000 ), WriteLn( "Visitando arista " << k ) );
        // [[ [[ n1, n2 ]], [[ dist, rank ]] ]]
        Set edge_info = subgraph::GetEdgeInfo( k );
        Set edge_nodes = edge_info[ 1 ];
        Set info = edge_info[ 2 ];
        Real rank = partition::GetRankDistance( info[ 1 ] );
        // actualizo el rank de la arista.
        Real info[ 2 ] := rank;
        // inserto la arista k-esima en el bin de rango 'rank'
        Set Append( edges_bin[ rank ], [[ k ]] );
        // si el rank es 1 guardo tambien la arista vecina de los
        // nodos, necesario para el aplicar el operador Difference
        Set If( EQ( rank, 1 ), {
            Real n1 = subgraph::GetNodeIndex( edge_nodes[ 1 ] );
            Real n2 = subgraph::GetNodeIndex( edge_nodes[ 2 ] );
            // k = (n1,n2) es arista de primer orden de n1
            Set Append( rank1[ n1 ], [[ k ]] );
            // k = (n2,n1) es arista de primer orden de n2
            Set Append( rank1[ n2 ], [[ k ]] )
          } );
        Real 0
      } );
    @EdgesBin obj =
    [[
      Set _.rank1 = rank1;
      Set _.edges_bin = edges_bin;
      @DiscreteDistance _.partition = partition 
    ]]
  }
};

  @DiscreteDistance partition = @DiscreteDistance::New( Range( 300, 1000, 100 ) ); 
  @SpatialSubGraph subgraph = @SpatialSubGraph::NewSQL( RaDe3G.DB::rade3g, 1000 );
  @EdgesBin edges_bin = @EdgesBin::New( subgraph, partition );



// Martes, 2009/11/03 17:58:07.00
/*
  @DiscreteDistance -- discretiza un intervalo segun un conjunto de puntos
 */
Class @DiscreteDistance
{
  Set _.knots;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfIntervals( Real void ) { Real Card( _.knots ) - 1 };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetRankDistance( Real dist )
///////////////////////////////////////////////////////////////////////////////
  {
    Real _bin_search( dist, 1, Card( _.knots ) )
  };

///////////////////////////////////////////////////////////////////////////////
  Real _bin_search( Real dist, Real low, Real high )
///////////////////////////////////////////////////////////////////////////////
  {
    Real If( EQ( high - low, 1 ), low, {
        Real mid = Floor( ( low + high ) / 2 );
        Real knot = _.knots[ mid ];
        If( dist < knot,
            _bin_search( dist, low, mid ),
            _bin_search( dist, mid, high ) )
      } )
  };
  
  Static @DiscreteDistance New( Set knots )
  {
    @DiscreteDistance obj =
      [[
        Set _.knots = [[ 0 ]] << knots
      ]]  
  }
};

Class @SpatialSubGraph
{
  Set _.nodes_info;
  Set _.edges_info;
  Real _.radius = 3000;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfNodes( Real void ) { Real Card( _.nodes_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfEdges( Real void ) { Real Card( _.edges_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetNodeId( Real index )
///////////////////////////////////////////////////////////////////////////////
  {
    Real _.nodes_info[ index ]
  };
  
///////////////////////////////////////////////////////////////////////////////
  Real GetNodeIndex( Real id )
///////////////////////////////////////////////////////////////////////////////
  {
    Text key = @SpatialSubGraph::hashNode( id );
    Real idx = FindIndexByName( _.nodes_info, key )
  };

///////////////////////////////////////////////////////////////////////////////
  Set GetEdgeInfo( Real k )
///////////////////////////////////////////////////////////////////////////////
  {
    Text name = Name( _.edges_info[ k ] );
    Set ids = @SpatialSubGraph::invertHashEdge( name );
    Set [[ ids, Set info = _.edges_info[ k ] ]]
  };
  
///////////////////////////////////////////////////////////////////////////////
  Real GetDistance( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::hashEdge( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

///////////////////////////////////////////////////////////////////////////////
  Real GetEdgeLabel( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::hashEdge( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.

    Ahora mismo es dependiente de la tabla dens_graph_single.
   */
///////////////////////////////////////////////////////////////////////////////
  Static @SpatialSubGraph NewSQL( NameBlock dbconn, Real EdgeThreshold )
///////////////////////////////////////////////////////////////////////////////
  {
    Real dbconn::Activate( ? );

    WriteLn( "Consultando aristas de la base de datos ..." );
    Text query_edges =
      "SELECT * FROM dens_graph_single_new WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query_edges );
    WriteLn( "Indexando aristas ..." );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::hashEdge( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );

    WriteLn( "Consultando nodos de la base de datos" );
    Text query_nodes =
      "SELECT ID_EMP_1 FROM dens_graph_new WHERE dist < " <<
      EdgeThreshold + " GROUP BY id_emp_1";
    Set nodes = DBTable( query_nodes );
    Set nodes_info = EvalSet( nodes, Real( Set node ) {
        Real id = node[ 1 ];
        Text name = FormatReal( id, "%.0f" );
        Real PutName( name, id )
      } );
    Real SetIndexByName( nodes_info );
   

    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.nodes_info = nodes_info;
      Set _.edges_info = edges_info
    ]]
  };

///////////////////////////////////////////////////////////////////////////////
  Static Text hashNode(  Real id )
///////////////////////////////////////////////////////////////////////////////
  {
    Text FormatReal( id, "%.0f")
  };

///////////////////////////////////////////////////////////////////////////////
  Static Text hashEdge(  Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  };

///////////////////////////////////////////////////////////////////////////////
  Static Set invertHashEdge(  Text hash  )
///////////////////////////////////////////////////////////////////////////////
  {
    Set Eval( "SetOfReal(" + hash + ")" )
  }

};

Class @EdgesBin
{
  Set _.edges_bin;
  @DiscreteDistance _.partition;
  
  Set _.rank1;                    // Contiene para cada nodo el
                                  // conjunto de vecinos de primer
                                  // rango.
  
///////////////////////////////////////////////////////////////////////////////
  @DiscreteDistance GetPartition( Real void ) { _.partition };
///////////////////////////////////////////////////////////////////////////////
  
///////////////////////////////////////////////////////////////////////////////
  Set GetEdgesInBin( Real bin )
///////////////////////////////////////////////////////////////////////////////
  {
    Set _.edges_bin[ bin ]
  };

///////////////////////////////////////////////////////////////////////////////
  Static @EdgesBin New( @SpatialSubGraph subgraph, @DiscreteDistance partition )
///////////////////////////////////////////////////////////////////////////////
  {
    // inicializo vecinos de primer orden de los nodos
    Set rank1 = For( 1, subgraph::GetNumberOfNodes(?), Set( Real k ) {
        Copy( Empty )
      } );
    
    // inicializo particionamiento de las aristas segun longitud
    Set edges_bin =
      For( 1, partition::GetNumberOfIntervals(?), Set( Real k ) {
          Set Copy( Empty )
        } );
    // recorro las aristas del grafo particionandolas y creando los
    // vecinos de primer orden.
    Set For( 1, subgraph::GetNumberOfEdges(?), Real( Real k ) {
        // [[ [[ n1, n2 ]], [[ dist, rank ]] ]]
        Set edge_info = subgraph::GetEdgeInfo( k );
        Set edge_nodes = edge_info[ 1 ];
        Set info = edge_info[ 2 ];
        Real rank = partition::GetRankDistance( info[ 1 ] );
        // actualizo el rank de la arista.
        Real info[ 2 ] := rank;
        // inserto la arista k-esima en el bin de rango 'rank'
        Set Append( edges_bin[ rank ], [[ k ]] );
        // si el rank es 1 guardo tambien la arista vecina de los
        // nodos, necesario para el aplicar el operador Difference
        Set If( EQ( rank, 1 ), {
            Real n1 = subgraph::GetNodeIndex( edge_nodes[ 1 ] );
            Real n2 = subgraph::GetNodeIndex( edge_nodes[ 2 ] );
            // k = (n1,n2) es arista de primer orden de n1
            Set Append( rank1[ n1 ], [[ k ]] );
            // k = (n2,n1) es arista de primer orden de n2
            Set Append( rank1[ n2 ], [[ k ]] )
          } );
        Real 0
      } );
    @EdgesBin obj =
    [[
      Set _.rank1 = rank1;
      Set _.edges_bin = edges_bin;
      @DiscreteDistance _.partition = partition 
    ]]
  }
};

  @DiscreteDistance partition = @DiscreteDistance::New( Range( 300, 1000, 100 ) ); 
  @SpatialSubGraph subgraph = @SpatialSubGraph::NewSQL( RaDe3G.DB::rade3g, 1000 );
  @EdgesBin edges_bin = @EdgesBin::New( subgraph, partition );



// Martes, 2009/11/03 17:56:29.00
/*
  @DiscreteDistance -- discretiza un intervalo segun un conjunto de puntos
 */
Class @DiscreteDistance
{
  Set _.knots;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfIntervals( Real void ) { Real Card( _.knots ) - 1 };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetRankDistance( Real dist )
///////////////////////////////////////////////////////////////////////////////
  {
    Real _bin_search( dist, 1, Card( _.knots ) )
  };

///////////////////////////////////////////////////////////////////////////////
  Real _bin_search( Real dist, Real low, Real high )
///////////////////////////////////////////////////////////////////////////////
  {
    Real If( EQ( high - low, 1 ), low, {
        Real mid = Floor( ( low + high ) / 2 );
        Real knot = _.knots[ mid ];
        If( dist < knot,
            _bin_search( dist, low, mid ),
            _bin_search( dist, mid, high ) )
      } )
  };
  
  Static @DiscreteDistance New( Set knots )
  {
    @DiscreteDistance obj =
      [[
        Set _.knots = [[ 0 ]] << knots
      ]]  
  }
};

Class @SpatialSubGraph
{
  Set _.nodes_info;
  Set _.edges_info;
  Real _.radius = 3000;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfNodes( Real void ) { Real Card( _.nodes_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfEdges( Real void ) { Real Card( _.edges_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetNodeId( Real index )
///////////////////////////////////////////////////////////////////////////////
  {
    Real _.nodes_info[ index ]
  };
  
///////////////////////////////////////////////////////////////////////////////
  Real GetNodeIndex( Real id )
///////////////////////////////////////////////////////////////////////////////
  {
    Text key = @SpatialSubGraph::hashNode( id );
    Real idx = FindIndexByName( _.nodes_info, key )
  };

///////////////////////////////////////////////////////////////////////////////
  Set GetEdgeInfo( Real k )
///////////////////////////////////////////////////////////////////////////////
  {
    Text name = Name( _.edges_info[ k ] );
    Set ids = @SpatialSubGraph::invertHashEdge( name );
    Set [[ ids, Set info = _.edges_info[ k ] ]]
  };
  
///////////////////////////////////////////////////////////////////////////////
  Real GetDistance( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::hashEdge( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

///////////////////////////////////////////////////////////////////////////////
  Real GetEdgeLabel( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::hashEdge( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.

    Ahora mismo es dependiente de la tabla dens_graph_single.
   */
///////////////////////////////////////////////////////////////////////////////
  Static @SpatialSubGraph NewSQL( NameBlock dbconn, Real EdgeThreshold )
///////////////////////////////////////////////////////////////////////////////
  {
    Real dbconn::Activate( ? );

    WriteLn( "Consultando aristas de la base de datos ..." );
    Text query_edges =
      "SELECT * FROM dens_graph_single_new WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query_edges );
    WriteLn( "Indexando aristas ..." );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::hashEdge( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );

    WriteLn( "Consultando nodos de la base de datos" );
    Text query_nodes =
      "SELECT ID_EMP_1 FROM dens_graph_new WHERE dist < " <<
      EdgeThreshold + " GROUP BY id_emp_1";
    Set nodes = DBTable( query_nodes );
    Set nodes_info = EvalSet( nodes, Real( Set node ) {
        Real id = node[ 1 ];
        Text name = FormatReal( id, "%.0f" );
        Real PutName( name, id )
      } );
    Real SetIndexByName( nodes_info );
   

    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.nodes_info = nodes_info;
      Set _.edges_info = edges_info
    ]]
  };

///////////////////////////////////////////////////////////////////////////////
  Static Text hashNode(  Real id )
///////////////////////////////////////////////////////////////////////////////
  {
    Text FormatReal( id, "%.0f")
  };

///////////////////////////////////////////////////////////////////////////////
  Static Text hashEdge(  Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  };

///////////////////////////////////////////////////////////////////////////////
  Static Set invertHashEdge(  Text hash  )
///////////////////////////////////////////////////////////////////////////////
  {
    Set Eval( "SetOfReal(" + hash + ")" )
  }

};

Class @EdgesBin
{
  Set _.edges_bin;
  @DiscreteDistance _.partition;
  
  Set _.rank1;                    // Contiene para cada nodo el
                                  // conjunto de vecinos de primer
                                  // rango.
  
///////////////////////////////////////////////////////////////////////////////
  @DiscreteDistance GetPartition( Real void ) { _.partition };
///////////////////////////////////////////////////////////////////////////////
  
///////////////////////////////////////////////////////////////////////////////
  Set GetEdgesInBin( Real bin )
///////////////////////////////////////////////////////////////////////////////
  {
    Set _.edges_bin[ bin ]
  };

///////////////////////////////////////////////////////////////////////////////
  Static @EdgesBin New( @SpatialSubGraph subgraph, @DiscreteDistance partition )
///////////////////////////////////////////////////////////////////////////////
  {
    // inicializo vecinos de primer orden de los nodos
    Set rank1 = For( 1, subgraph::GetNumberOfNodes(?), Set( Real k ) {
        Copy( Empty )
      } );
    
    // inicializo particionamiento de las aristas segun longitud
    Set edges_bin =
      For( 1, partition::GetNumberOfIntervals(?), Set( Real k ) {
          Set Copy( Empty )
        } );

WriteLn ( "Setp 1" );
    // recorro las aristas del grafo particionandolas y creando los
    // vecinos de primer orden.
    Set For( 1, subgraph::GetNumberOfEdges(?), Real( Real k ) {
        // [[ [[ n1, n2 ]], [[ dist, rank ]] ]]
        Set edge_info = subgraph::GetEdgeInfo( k );
        Set edge_nodes = edge_info[ 1 ];
        Set info = edge_info[ 2 ];
        Real rank = partition::GetRankDistance( info[ 1 ] );
        // actualizo el rank de la arista.
        Real info[ 2 ] := rank;

WriteLn ( "Setp 2" );

        // inserto la arista k-esima en el bin de rango 'rank'
        Set Append( edges_bin[ rank ], [[ k ]] );
        // si el rank es 1 guardo tambien la arista vecina de los
        // nodos, necesario para el aplicar el operador Difference
        Set If( EQ( rank, 1 ), {
            Real n1 = subgraph::GetNodeIndex( edge_nodes[ 1 ] );
            Real n2 = subgraph::GetNodeIndex( edge_nodes[ 2 ] );
            // k = (n1,n2) es arista de primer orden de n1
            Set Append( rank1[ n1 ], [[ k ]] );
            // k = (n2,n1) es arista de primer orden de n2
            Set Append( rank1[ n2 ], [[ k ]] )
          } );
        Real 0
      } );
    @EdgesBin obj =
    [[
      Set _.rank1 = rank1;
      Set _.edges_bin = edges_bin;
      @DiscreteDistance _.partition = partition 
    ]]
  }
};

  @DiscreteDistance partition = @DiscreteDistance::New( Range( 300, 1000, 100 ) ); 
  @SpatialSubGraph subgraph = @SpatialSubGraph::NewSQL( RaDe3G.DB::rade3g, 1000 );
  @EdgesBin edges_bin = @EdgesBin::New( subgraph, partition );



// Martes, 2009/11/03 17:53:28.00
/*
  @DiscreteDistance -- discretiza un intervalo segun un conjunto de puntos
 */
Class @DiscreteDistance
{
  Set _.knots;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfIntervals( Real void ) { Real Card( _.knots ) - 1 };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetRankDistance( Real dist )
///////////////////////////////////////////////////////////////////////////////
  {
    Real _bin_search( dist, 1, Card( _.knots ) )
  };

///////////////////////////////////////////////////////////////////////////////
  Real _bin_search( Real dist, Real low, Real high )
///////////////////////////////////////////////////////////////////////////////
  {
    Real If( EQ( high - low, 1 ), low, {
        Real mid = Floor( ( low + high ) / 2 );
        Real knot = _.knots[ mid ];
        If( dist < knot,
            _bin_search( dist, low, mid ),
            _bin_search( dist, mid, high ) )
      } )
  };
  
  Static @DiscreteDistance New( Set knots )
  {
    @DiscreteDistance obj =
      [[
        Set _.knots = [[ 0 ]] << knots
      ]]  
  }
};

Class @SpatialSubGraph
{
  Set _.nodes_info;
  Set _.edges_info;
  Real _.radius = 3000;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfNodes( Real void ) { Real Card( _.nodes_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfEdges( Real void ) { Real Card( _.edges_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetNodeId( Real index )
///////////////////////////////////////////////////////////////////////////////
  {
    Real _.nodes_info[ index ]
  };
  
///////////////////////////////////////////////////////////////////////////////
  Real GetNodeIndex( Real id )
///////////////////////////////////////////////////////////////////////////////
  {
    Text key = @SpatialSubGraph::hashNode( id );
    Real idx = FindIndexByName( _.nodes_info, key )
  };

///////////////////////////////////////////////////////////////////////////////
  Set GetEdgeInfo( Real k )
///////////////////////////////////////////////////////////////////////////////
  {
    Text name = Name( _.edges_info[ k ] );
    Set ids = @SpatialSubGraph::invertHashEdge( name );
    Set [[ ids, Set info = _.edges_info[ k ] ]]
  };
  
///////////////////////////////////////////////////////////////////////////////
  Real GetDistance( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::hashEdge( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

///////////////////////////////////////////////////////////////////////////////
  Real GetEdgeLabel( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::hashEdge( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.

    Ahora mismo es dependiente de la tabla dens_graph_single.
   */
///////////////////////////////////////////////////////////////////////////////
  Static @SpatialSubGraph NewSQL( NameBlock dbconn, Real EdgeThreshold )
///////////////////////////////////////////////////////////////////////////////
  {
    Real dbconn::Activate( ? );

    WriteLn( "Consultando aristas de la base de datos ..." );
    Text query_edges =
      "SELECT * FROM dens_graph_single_new WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query_edges );
    WriteLn( "Indexando aristas ..." );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::hashEdge( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );

    WriteLn( "Consultando nodos de la base de datos" );
    Text query_nodes =
      "SELECT ID_EMP_1 FROM dens_graph_new WHERE dist < " <<
      EdgeThreshold + " GROUP BY id_emp_1";
    Set nodes = DBTable( query_nodes );
    Set nodes_info = EvalSet( nodes, Real( Set node ) {
        Real id = node[ 1 ];
        Text name = FormatReal( id, "%.0f" );
        Real PutName( name, id )
      } );
    Real SetIndexByName( nodes_info );
   

    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.nodes_info = nodes_info;
      Set _.edges_info = edges_info
    ]]
  };

///////////////////////////////////////////////////////////////////////////////
  Static Text hashNode(  Real id )
///////////////////////////////////////////////////////////////////////////////
  {
    Text FormatReal( id, "%.0f")
  };

///////////////////////////////////////////////////////////////////////////////
  Static Text hashEdge(  Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  };

///////////////////////////////////////////////////////////////////////////////
  Static Set invertHashEdge(  Text hash  )
///////////////////////////////////////////////////////////////////////////////
  {
    Set Eval( "SetOfReal(" + hash + ")" )
  }

};

Class @EdgesBin
{
  Set _.edges_bin;
  @DiscreteDistance _.partition;
  
  Set _.rank1;                    // Contiene para cada nodo el
                                  // conjunto de vecinos de primer
                                  // rango.
  
///////////////////////////////////////////////////////////////////////////////
  @DiscreteDistance GetPartition( Real void ) { _.partition };
///////////////////////////////////////////////////////////////////////////////
  
///////////////////////////////////////////////////////////////////////////////
  Set GetEdgesInBin( Real bin )
///////////////////////////////////////////////////////////////////////////////
  {
    Set _.edges_bin[ bin ]
  };

///////////////////////////////////////////////////////////////////////////////
  Static @EdgesBin New( @SpatialSubGraph subgraph, @DiscreteDistance partition )
///////////////////////////////////////////////////////////////////////////////
  {
    // inicializo vecinos de primer orden de los nodos
    Set rank1 = For( 1, subgraph::GetNumberOfNodes(?), Set( Real k ) {
        Copy( Empty )
      } );
    
    // inicializo particionamiento de las aristas segun longitud
    Set edges_bin =
      For( 1, partition::GetNumberOfIntervals(?), Set( Real k ) {
          Set Copy( Empty )
        } );

    // recorro las aristas del grafo particionandolas y creando los
    // vecinos de primer orden.
    Set For( 1, subgraph::GetNumberOfEdges(?), Real( Real k ) {
        // [[ [[ n1, n2 ]], [[ dist, rank ]] ]]
        Set edge_info = subgraph::GetEdgeInfo( k );
        Set edge_nodes = edge_info[ 1 ];
        Set info = edge_info[ 2 ];
        Real rank = partition::GetRankDistance( info[ 1 ] );
        // actualizo el rank de la arista.
        Real info[ 2 ] := rank;
        // inserto la arista k-esima en el bin de rango 'rank'
        Set Append( edges_bin[ rank ], [[ k ]] );
        // si el rank es 1 guardo tambien la arista vecina de los
        // nodos, necesario para el aplicar el operador Difference
        If( EQ( rank, 1 ), {
            Real n1 = subgraph::GetNodeIndex( edge_nodes[ 1 ] );
            Real n2 = subgraph::GetNodeIndex( edge_nodes[ 2 ] );
            // k = (n1,n2) es arista de primer orden de n1
            Set Append( rank1[ n1 ], [[ k ]] );
            // k = (n2,n1) es arista de primer orden de n2
            Set Append( rank1[ n2 ], [[ k ]] )
          } );
        Real 0
      } );
    @EdgesBin obj =
    [[
      Set _.rank1 = rank1;
      Set _.edges_bin = edges_bin;
      @DiscreteDistance _.partition = partition 
    ]]
  }
};

  @DiscreteDistance partition = @DiscreteDistance::New( Range( 300, 1000, 100 ) ); 
  @SpatialSubGraph subgraph = @SpatialSubGraph::NewSQL( RaDe3G.DB::rade3g, 1000 );
  @EdgesBin edges_bin = @EdgesBin::New( subgraph, partition );



// Martes, 2009/11/03 17:52:28.00
/*
  @DiscreteDistance -- discretiza un intervalo segun un conjunto de puntos
 */
Class @DiscreteDistance
{
  Set _.knots;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfIntervals( Real void ) { Real Card( _.knots ) - 1 };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetRankDistance( Real dist )
///////////////////////////////////////////////////////////////////////////////
  {
    Real _bin_search( dist, 1, Card( _.knots ) )
  };

///////////////////////////////////////////////////////////////////////////////
  Real _bin_search( Real dist, Real low, Real high )
///////////////////////////////////////////////////////////////////////////////
  {
    Real If( EQ( high - low, 1 ), low, {
        Real mid = Floor( ( low + high ) / 2 );
        Real knot = _.knots[ mid ];
        If( dist < knot,
            _bin_search( dist, low, mid ),
            _bin_search( dist, mid, high ) )
      } )
  };
  
  Static @DiscreteDistance New( Set knots )
  {
    @DiscreteDistance obj =
      [[
        Set _.knots = [[ 0 ]] << knots
      ]]  
  }
};

Class @SpatialSubGraph
{
  Set _.nodes_info;
  Set _.edges_info;
  Real _.radius = 3000;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfNodes( Real void ) { Real Card( _.nodes_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfEdges( Real void ) { Real Card( _.edges_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetNodeId( Real index )
///////////////////////////////////////////////////////////////////////////////
  {
    Real _.nodes_info[ index ]
  };
  
///////////////////////////////////////////////////////////////////////////////
  Real GetNodeIndex( Real id )
///////////////////////////////////////////////////////////////////////////////
  {
    Text key = @SpatialSubGraph::hashNode( id );
    Real idx = FindIndexByName( _.nodes_info, key )
  };

///////////////////////////////////////////////////////////////////////////////
  Set GetEdgeInfo( Real k )
///////////////////////////////////////////////////////////////////////////////
  {
    Text name = Name( _.edges_info[ k ] );
    Set ids = @SpatialSubGraph::invertHashEdge( name );
    Set [[ ids, Set info = _.edges_info[ k ] ]]
  };
  
///////////////////////////////////////////////////////////////////////////////
  Real GetDistance( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::hashEdge( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

///////////////////////////////////////////////////////////////////////////////
  Real GetEdgeLabel( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::hashEdge( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.

    Ahora mismo es dependiente de la tabla dens_graph_single.
   */
///////////////////////////////////////////////////////////////////////////////
  Static @SpatialSubGraph NewSQL( NameBlock dbconn, Real EdgeThreshold )
///////////////////////////////////////////////////////////////////////////////
  {
    Real dbconn::Activate( ? );

    WriteLn( "Consultando aristas de la base de datos ..." );
    Text query_edges =
      "SELECT * FROM dens_graph_single_new WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query_edges );
    WriteLn( "Indexando aristas ..." );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::hashEdge( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );

    WriteLn( "Consultando nodos de la base de datos" );
    Text query_nodes =
      "SELECT ID_EMP_1 FROM dens_graph_new WHERE dist < " <<
      EdgeThreshold + " GROUP BY id_emp_1";
    Set nodes = DBTable( query_nodes );
    Set nodes_info = EvalSet( nodes, Real( Set node ) {
        Real id = node[ 1 ];
        Text name = FormatReal( id, "%.0f" );
        Real PutName( name, id )
      } );
    Real SetIndexByName( nodes_info );
   

    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.nodes_info = nodes_info;
      Set _.edges_info = edges_info
    ]]
  };

///////////////////////////////////////////////////////////////////////////////
  Static Text hashNode(  Real id )
///////////////////////////////////////////////////////////////////////////////
  {
    Text FormatReal( id, "%.0f")
  };

///////////////////////////////////////////////////////////////////////////////
  Static Text hashEdge(  Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  };

///////////////////////////////////////////////////////////////////////////////
  Static Set invertHashEdge(  Text hash  )
///////////////////////////////////////////////////////////////////////////////
  {
    Set Eval( "SetOfReal(" + hash + ")" )
  }

};

Class @EdgesBin
{
  Set _.edges_bin;
  @DiscreteDistance _.partition;
  
  Set _.rank1;                    // Contiene para cada nodo el
                                  // conjunto de vecinos de primer
                                  // rango.
  
///////////////////////////////////////////////////////////////////////////////
  @DiscreteDistance GetPartition( Real void ) { _.partition };
///////////////////////////////////////////////////////////////////////////////
  
///////////////////////////////////////////////////////////////////////////////
  Set GetEdgesInBin( Real bin )
///////////////////////////////////////////////////////////////////////////////
  {
    Set _.edges_bin[ bin ]
  };

///////////////////////////////////////////////////////////////////////////////
  Static @EdgesBin New( @SpatialSubGraph subgraph, @DiscreteDistance partition )
///////////////////////////////////////////////////////////////////////////////
  {
    // inicializo vecinos de primer orden de los nodos
    Set rank1 = For( 1, subgraph::GetNumberOfNodes(?), Set( Real k ) {
        Copy( Empty )
      } );
    
    // inicializo particionamiento de las aristas segun longitud
    Set edges_bin =
      For( 1, partition::GetNumberOfIntervals(?), Set( Real k ) {
          Set Copy( Empty )
        } );

    // recorro las aristas del grafo particionandolas y creando los
    // vecinos de primer orden.
    Set For( 1, subgraph::GetNumberOfEdges(?), Real( Real k ) {
        // [[ [[ n1, n2 ]], [[ dist, rank ]] ]]
        Set edge_info = subgraph::GetEdgeInfo( k );
        Set edge_nodes = edge_info[ 1 ];
        Set info = edge_info[ 2 ];
        Real rank = partition::FindRankDistance( info[ 1 ] );
        // actualizo el rank de la arista.
        Real info[ 2 ] := rank;
        // inserto la arista k-esima en el bin de rango 'rank'
        Set Append( edges_bin[ rank ], [[ k ]] );
        // si el rank es 1 guardo tambien la arista vecina de los
        // nodos, necesario para el aplicar el operador Difference
        If( EQ( rank, 1 ), {
            Real n1 = subgraph::GetNodeIndex( edge_nodes[ 1 ] );
            Real n2 = subgraph::GetNodeIndex( edge_nodes[ 2 ] );
            // k = (n1,n2) es arista de primer orden de n1
            Set Append( rank1[ n1 ], [[ k ]] );
            // k = (n2,n1) es arista de primer orden de n2
            Set Append( rank1[ n2 ], [[ k ]] )
          } );
        Real 0
      } );
    @EdgesBin obj =
    [[
      Set _.rank1 = rank1;
      Set _.edges_bin = edges_bin;
      @DiscreteDistance _.partition = partition 
    ]]
  }
};

  @DiscreteDistance partition = @DiscreteDistance::New( Range( 300, 1000, 100 ) ); 
  @SpatialSubGraph subgraph = @SpatialSubGraph::NewSQL( RaDe3G.DB::rade3g, 1000 );
  @EdgesBin edges_bin = @EdgesBin::New( subgraph, partition );



// Martes, 2009/11/03 17:51:13.00
/*
  @DiscreteDistance -- discretiza un intervalo segun un conjunto de puntos
 */
Class @DiscreteDistance
{
  Set _.knots;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfIntervals( Real void ) { Real Card( _.knots ) - 1 };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetRankDistance( Real dist )
///////////////////////////////////////////////////////////////////////////////
  {
    Real _bin_search( dist, 1, Card( _.knots ) )
  };

///////////////////////////////////////////////////////////////////////////////
  Real _bin_search( Real dist, Real low, Real high )
///////////////////////////////////////////////////////////////////////////////
  {
    Real If( EQ( high - low, 1 ), low, {
        Real mid = Floor( ( low + high ) / 2 );
        Real knot = _.knots[ mid ];
        If( dist < knot,
            _bin_search( dist, low, mid ),
            _bin_search( dist, mid, high ) )
      } )
  };
  
  Static @DiscreteDistance New( Set knots )
  {
    @DiscreteDistance obj =
      [[
        Set _.knots = [[ 0 ]] << knots
      ]]  
  }
};

Class @SpatialSubGraph
{
  Set _.nodes_info;
  Set _.edges_info;
  Real _.radius = 3000;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfNodes( Real void ) { Real Card( _.nodes_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfEdges( Real void ) { Real Card( _.edges_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetNodeId( Real index )
///////////////////////////////////////////////////////////////////////////////
  {
    Real _.nodes_info[ index ]
  };
  
///////////////////////////////////////////////////////////////////////////////
  Real GetNodeIndex( Real id )
///////////////////////////////////////////////////////////////////////////////
  {
    Text key = @SpatialSubGraph::hashNode( id );
    Real idx = FindIndexByName( _.nodes_info, key )
  };

///////////////////////////////////////////////////////////////////////////////
  Set GetEdgeInfo( Real k )
///////////////////////////////////////////////////////////////////////////////
  {
    Text name = Name( _.edges_info[ k ] );
    Set ids = @SpatialSubGraph::invertHashEdge( name );
    Set [[ ids, Set info = _.edges_info[ k ] ]]
  };
  
///////////////////////////////////////////////////////////////////////////////
  Real GetDistance( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::hashEdge( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

///////////////////////////////////////////////////////////////////////////////
  Real GetEdgeLabel( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::hashEdge( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.

    Ahora mismo es dependiente de la tabla dens_graph_single.
   */
///////////////////////////////////////////////////////////////////////////////
  Static @SpatialSubGraph NewSQL( NameBlock dbconn, Real EdgeThreshold )
///////////////////////////////////////////////////////////////////////////////
  {
    Real dbconn::Activate( ? );

    WriteLn( "Consultando aristas de la base de datos ..." );
    Text query_edges =
      "SELECT * FROM dens_graph_single_new WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query_edges );
    WriteLn( "Indexando aristas ..." );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::hashEdge( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );

    WriteLn( "Consultando nodos de la base de datos" );
    Text query_nodes =
      "SELECT ID_EMP_1 FROM dens_graph_new WHERE dist < " <<
      EdgeThreshold + " GROUP BY id_emp_1";
    Set nodes = DBTable( query_nodes );
    Set nodes_info = EvalSet( nodes, Real( Set node ) {
        Real id = node[ 1 ];
        Text name = FormatReal( id, "%.0f" );
        Real PutName( name, id )
      } );
    Real SetIndexByName( nodes_info );
   

    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.nodes_info = nodes_info;
      Set _.edges_info = edges_info
    ]]
  };

///////////////////////////////////////////////////////////////////////////////
  Static Text hashNode(  Real id )
///////////////////////////////////////////////////////////////////////////////
  {
    Text FormatReal( id, "%.0f")
  };

///////////////////////////////////////////////////////////////////////////////
  Static Text hashEdge(  Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  };

///////////////////////////////////////////////////////////////////////////////
  Static Set invertHashEdge(  Text hash  )
///////////////////////////////////////////////////////////////////////////////
  {
    Set Eval( "SetOfReals(" + hash + ")" )
  }

};

Class @EdgesBin
{
  Set _.edges_bin;
  @DiscreteDistance _.partition;
  
  Set _.rank1;                    // Contiene para cada nodo el
                                  // conjunto de vecinos de primer
                                  // rango.
  
///////////////////////////////////////////////////////////////////////////////
  @DiscreteDistance GetPartition( Real void ) { _.partition };
///////////////////////////////////////////////////////////////////////////////
  
///////////////////////////////////////////////////////////////////////////////
  Set GetEdgesInBin( Real bin )
///////////////////////////////////////////////////////////////////////////////
  {
    Set _.edges_bin[ bin ]
  };

///////////////////////////////////////////////////////////////////////////////
  Static @EdgesBin New( @SpatialSubGraph subgraph, @DiscreteDistance partition )
///////////////////////////////////////////////////////////////////////////////
  {
    // inicializo vecinos de primer orden de los nodos
    Set rank1 = For( 1, subgraph::GetNumberOfNodes(?), Set( Real k ) {
        Copy( Empty )
      } );
    
    // inicializo particionamiento de las aristas segun longitud
    Set edges_bin =
      For( 1, partition::GetNumberOfIntervals(?), Set( Real k ) {
          Set Copy( Empty )
        } );

    // recorro las aristas del grafo particionandolas y creando los
    // vecinos de primer orden.
    Set For( 1, subgraph::GetNumberOfEdges(?), Real( Real k ) {
        // [[ [[ n1, n2 ]], [[ dist, rank ]] ]]
        Set edge_info = subgraph::GetEdgeInfo( k );
        Set edge_nodes = edge_info[ 1 ];
        Set info = edge_info[ 2 ];
        Real rank = partition::FindRankDistance( info[ 1 ] );
        // actualizo el rank de la arista.
        Real info[ 2 ] := rank;
        // inserto la arista k-esima en el bin de rango 'rank'
        Set Append( edges_bin[ rank ], [[ k ]] );
        // si el rank es 1 guardo tambien la arista vecina de los
        // nodos, necesario para el aplicar el operador Difference
        If( EQ( rank, 1 ), {
            Real n1 = subgraph::GetNodeIndex( edge_nodes[ 1 ] );
            Real n2 = subgraph::GetNodeIndex( edge_nodes[ 2 ] );
            // k = (n1,n2) es arista de primer orden de n1
            Set Append( rank1[ n1 ], [[ k ]] );
            // k = (n2,n1) es arista de primer orden de n2
            Set Append( rank1[ n2 ], [[ k ]] )
          } );
        Real 0
      } );
    @EdgesBin obj =
    [[
      Set _.rank1 = rank1;
      Set _.edges_bin = edges_bin;
      @DiscreteDistance _.partition = partition 
    ]]
  }
};

  @DiscreteDistance partition = @DiscreteDistance::New( Range( 300, 1000, 100 ) ); 
  @SpatialSubGraph subgraph = @SpatialSubGraph::NewSQL( RaDe3G.DB::rade3g, 1000 );
  @EdgesBin edges_bin = @EdgesBin::New( subgraph, partition );



// Martes, 2009/11/03 17:50:22.00
/*
  @DiscreteDistance -- discretiza un intervalo segun un conjunto de puntos
 */
Class @DiscreteDistance
{
  Set _.knots;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfIntervals( Real void ) { Real Card( _.knots ) - 1 };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetRankDistance( Real dist )
///////////////////////////////////////////////////////////////////////////////
  {
    Real _bin_search( dist, 1, Card( _.knots ) )
  };

///////////////////////////////////////////////////////////////////////////////
  Real _bin_search( Real dist, Real low, Real high )
///////////////////////////////////////////////////////////////////////////////
  {
    Real If( EQ( high - low, 1 ), low, {
        Real mid = Floor( ( low + high ) / 2 );
        Real knot = _.knots[ mid ];
        If( dist < knot,
            _bin_search( dist, low, mid ),
            _bin_search( dist, mid, high ) )
      } )
  };
  
  Static @DiscreteDistance New( Set knots )
  {
    @DiscreteDistance obj =
      [[
        Set _.knots = [[ 0 ]] << knots
      ]]  
  }
};

Class @SpatialSubGraph
{
  Set _.nodes_info;
  Set _.edges_info;
  Real _.radius = 3000;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfNodes( Real void ) { Real Card( _.nodes_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfEdges( Real void ) { Real Card( _.edges_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetNodeId( Real index )
///////////////////////////////////////////////////////////////////////////////
  {
    Real _.nodes_info[ index ]
  };
  
///////////////////////////////////////////////////////////////////////////////
  Real GetNodeIndex( Real id )
///////////////////////////////////////////////////////////////////////////////
  {
    Text key = @SpatialSubGraph::hashNode( id );
    Real idx = FindIndexByName( _.nodes_info, key )
  };

///////////////////////////////////////////////////////////////////////////////
  Set GetEdgeInfo( Real k )
///////////////////////////////////////////////////////////////////////////////
  {
    Text name = Name( _.edges_info[ k ] );
    Set ids = @SpatialSubGraph::invertHashEdge( name );
    Set [[ ids, Set info = _.edges_info[ k ] ]]
  };
  
///////////////////////////////////////////////////////////////////////////////
  Real GetDistance( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::hashEdge( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

///////////////////////////////////////////////////////////////////////////////
  Real GetEdgeLabel( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::hashEdge( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.

    Ahora mismo es dependiente de la tabla dens_graph_single.
   */
///////////////////////////////////////////////////////////////////////////////
  Static @SpatialSubGraph NewSQL( NameBlock dbconn, Real EdgeThreshold )
///////////////////////////////////////////////////////////////////////////////
  {
    Real dbconn::Activate( ? );

    WriteLn( "Consultando aristas de la base de datos ..." );
    Text query_edges =
      "SELECT * FROM dens_graph_single_new WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query_edges );
    WriteLn( "Indexando aristas ..." );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::hashEdge( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );

    WriteLn( "Consultando nodos de la base de datos" );
    Text query_nodes =
      "SELECT ID_EMP_1 FROM dens_graph_new WHERE dist < " <<
      EdgeThreshold + " GROUP BY id_emp_1";
    Set nodes = DBTable( query_nodes );
    Set nodes_info = EvalSet( nodes, Real( Set node ) {
        Real id = node[ 1 ];
        Text name = FormatReal( id, "%.0f" );
        Real PutName( name, id )
      } );
    Real SetIndexByName( nodes_info );
   

    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.nodes_info = nodes_info;
      Set _.edges_info = edges_info
    ]]
  };

///////////////////////////////////////////////////////////////////////////////
  Static Text hashNode(  Real id )
///////////////////////////////////////////////////////////////////////////////
  {
    Text FormatReal( id, "%.0f")
  };

///////////////////////////////////////////////////////////////////////////////
  Static Text hashEdge(  Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  };

///////////////////////////////////////////////////////////////////////////////
  Static Set invertHashEdge(  Text hash  )
///////////////////////////////////////////////////////////////////////////////
  {
    Set Eval( "SetOfReals(" + hash + ")" )
  }

};

Class @EdgesBin
{
  Set _.edges_bin;
  @DiscreteDistance _.partition;
  
  Set _.rank1;                    // Contiene para cada nodo el
                                  // conjunto de vecinos de primer
                                  // rango.
  
///////////////////////////////////////////////////////////////////////////////
  @DiscreteDistance GetPartition( Real void ) { _.partition };
///////////////////////////////////////////////////////////////////////////////
  
///////////////////////////////////////////////////////////////////////////////
  Set GetEdgesInBin( Real bin )
///////////////////////////////////////////////////////////////////////////////
  {
    Set _.edges_bin[ bin ]
  };

///////////////////////////////////////////////////////////////////////////////
  Static @EdgesBin New( @SpatialSubGraph subgraph, @DiscreteDistance partition )
///////////////////////////////////////////////////////////////////////////////
  {
    // inicializo vecinos de primer orden de los nodos
    Set rank1 = For( 1, subgraph::GetNumberOfNodes(?), Set( Real k ) {
        Copy( Empty )
      } );
    
    // inicializo particionamiento de las aristas segun longitud
    Set edges_bin =
      For( 1, partition::GetNumberOfIntervals(?), Set( Real k ) {
          Set Copy( Empty )
        } );

    // recorro las aristas del grafo particionandolas y creando los
    // vecinos de primer orden.
    Set For( 1, subgraph::GetNumberOfEdges(?), Real( Real k ) {
        // [[ [[ n1, n2 ]], [[ dist, rank ]] ]]
        Set edge_info = subgraph::GetEdgeInfo( k );
        Set edge_nodes = edge_info[ 1 ];
        Set info = edge_info[ 2 ];
        Real rank = partition::FindRankDistance( info[ 1 ] );
        // actualizo el rank de la arista.
        Real info[ 2 ] := rank;
        // inserto la arista k-esima en el bin de rango 'rank'
        Set Append( edges_bin[ rank ], [[ k ]] );
        // si el rank es 1 guardo tambien la arista vecina de los
        // nodos, necesario para el aplicar el operador Difference
        If( EQ( rank, 1 ), {
            Real n1 = subgraph::GetNodeIndex( edge_nodes[ 1 ] );
            Real n2 = subgraph::GetNodeIndex( edge_nodes[ 2 ] );
            // k = (n1,n2) es arista de primer orden de n1
            Set Append( rank1[ n1 ], [[ k ]] );
            // k = (n2,n1) es arista de primer orden de n2
            Set Append( rank1[ n2 ], [[ k ]] )
          } );
        Real 0
      } );
    @EdgesBin obj =
    [[
      Set _.rank1 = rank1;
      Set _.edges_bin = edges_bin;
      @DiscreteDistance _.partition = partition 
    ]]
  }
};

  @DiscreteDistance @DiscreteDistance::New( Range( 300, 1000, 100 ) ); 
  @SpatialSubGraph subgraph = @SpatialSubGraph::NewSQL( RaDe3G.DB::rade3g, 1000 );
  @EdgesBin edges_bin = @EdgesBin::New( subgraph, partition );



// Martes, 2009/11/03 16:33:33.00
Class @SpatialSubGraph
{
  Set _.nodes_info;
  Set _.edges_info;
  Real _.radius = 3000;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfNodes( Real void ) { Real Card( _.nodes_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfEdges( Real void ) { Real Card( _.edges_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Set GetEdgeInfo( Real k )
///////////////////////////////////////////////////////////////////////////////
  {
    Text name = Name( _.edges_info[ k ] );
    Set ids = @SpatialSubGraph::invertHash( name );
    Set _.edges_info[ k ] };
  
///////////////////////////////////////////////////////////////////////////////
  Real GetDistance( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

///////////////////////////////////////////////////////////////////////////////
  Real GetEdgeLabel( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.

    Ahora mismo es dependiente de la tabla dens_graph_single.
   */
  Static @SpatialSubGraph NewSQL( NameBlock dbconn, Real EdgeThreshold )
  {
    Real dbconn::Activate( ? );

    WriteLn( "Consultando nodos de la base de datos" );
    Text query_edges =
      "SELECT * FROM dens_graph_single_new WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query_edges );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::getHashKey( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );

    WriteLn( "Consultando nodos de la base de datos" );
    Text query_nodes =
      "SELECT ID_EMP_1 FROM DENS_GRAPH_NEW WHERE dist < " <<
      EdgeThreshold + " GROUP BY id_emp_1";
    Set nodes = DBTable( query_nodes );
    Set nodes_info = EvalSet( nodes, Real( Set node ) {
        Real id = node[ 1 ];
        Text name = FormatReal( id, "%.0f" );
        Real PutName( name, id )
      } );
    Real SetIndexByName( nodes_info );
   

    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.nodes_info = nodes_info;
      Set _.edges_info = edges_info
    ]]
  };

  Static Text getHashKey(  Real id1, Real id2 )
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  };

  Static Set invertHash(  Text hash  )
  {
    Set Eval( "SetOfReals(" + hash + ")" )
  }

};

@SpatialSubGraph obj = @SpatialSubGraph::NewSQL( RaDe3G.DB::rade3g, 1000 );



// Martes, 2009/11/03 16:32:28.00
Class @SpatialSubGraph
{
  Set _.nodes_info;
  Set _.edges_info;
  Real _.radius = 3000;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfNodes( Real void ) { Real Card( _.nodes_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfEdges( Real void ) { Real Card( _.edges_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Set GetEdgeInfo( Real k )
///////////////////////////////////////////////////////////////////////////////
  {
    Text name = Name( _.edges_info[ k ] );
    Set ids = @SpatialSubGraph::invertHash( name );
    Set _.edges_info[ k ] };
  
///////////////////////////////////////////////////////////////////////////////
  Real GetDistance( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

///////////////////////////////////////////////////////////////////////////////
  Real GetEdgeLabel( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.

    Ahora mismo es dependiente de la tabla dens_graph_single.
   */
  Static @SpatialSubGraph NewSQL( NameBlock dbconn, Real EdgeThreshold )
  {
    Real dbconn::Activate( ? );

    WriteLn( "Consultando nodos de la base de datos" );
    Text query_edges =
      "SELECT * FROM dens_graph_single_new WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query_edges );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::getHashKey( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );

    WriteLn( "Consultando nodos de la base de datos" );
    Text query_nodes =
      "SELECT ID_EMP_1 FROM DENS_GRAPH_NEW WHERE dist < " <<
      EdgeThreshold + " GROUP BY id_emp_1";
    Set nodes = DBTable( query_nodes );
    Set nodes_info = EvalSet( nodes, Real( Set node ) {
        Real id = node[ 1 ];
        Text name = FormatReal( id, "%.0f" );
        Set PutName( name, id )
      } );
    Real SetIndexByName( nodes_info );
   

    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.nodes_info = nodes_info;
      Set _.edges_info = edges_info
    ]]
  };

  Static Text getHashKey(  Real id1, Real id2 )
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  };

  Static Set invertHash(  Text hash  )
  {
    Set Eval( "SetOfReals(" + hash + ")" )
  }

};

@SpatialSubGraph obj = @SpatialSubGraph::NewSQL( RaDe3G.DB::rade3g, 1000 );



// Martes, 2009/11/03 16:31:03.00
Class @SpatialSubGraph
{
  Set _.nodes_info;
  Set _.edges_info;
  Real _.radius = 3000;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfNodes( Real void ) { Real Card( _.nodes_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfEdges( Real void ) { Real Card( _.edges_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Set GetEdgeInfo( Real k )
///////////////////////////////////////////////////////////////////////////////
  {
    Text name = Name( _.edges_info[ k ] );
    Set ids = @SpatialSubGraph::invertHash( name );
    Set _.edges_info[ k ] };
  
///////////////////////////////////////////////////////////////////////////////
  Real GetDistance( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

///////////////////////////////////////////////////////////////////////////////
  Real GetEdgeLabel( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.

    Ahora mismo es dependiente de la tabla dens_graph_single.
   */
  Static @SpatialSubGraph NewSQL( NameBlock dbconn, Real EdgeThreshold )
  {
    Real dbconn::Activate( ? );

    WriteLn( "Consultando nodos de la base de datos" );
    Text query_edges =
      "SELECT * FROM dens_graph_new_single WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query_edges );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::getHashKey( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );

    WriteLn( "Consultando nodos de la base de datos" );
    Text query_nodes =
      "SELECT ID_EMP_1 FROM DENS_GRAPH_NEW WHERE dist < " <<
      EdgeThreshold + " GROUP BY id_emp_1";
    Set nodes = DBTable( query_nodes );
    Set nodes_info = EvalSet( nodes, Real( Set node ) {
        Real id = node[ 1 ];
        Text name = FormatReal( id, "%.0f" );
        Set PutName( name, id )
      } );
    Real SetIndexByName( nodes_info );
   

    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.nodes_info = nodes_info;
      Set _.edges_info = edges_info
    ]]
  };

  Static Text getHashKey(  Real id1, Real id2 )
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  };

  Static Set invertHash(  Text hash  )
  {
    Set Eval( "SetOfReals(" + hash + ")" )
  }

};

@SpatialSubGraph obj = @SpatialSubGraph::NewSQL( RaDe3G.DB::rade3g, 1000 );



// Martes, 2009/11/03 16:30:25.00
Class @SpatialSubGraph
{
  Set _.nodes_info;
  Set _.edges_info;
  Real _.radius = 3000;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfNodes( Real void ) { Real Card( _.nodes_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfEdges( Real void ) { Real Card( _.edges_info ) };
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
  Set GetEdgeInfo( Real k )
///////////////////////////////////////////////////////////////////////////////
  {
    Text name = Name( _.edges_info[ k ] );
    Set ids = @SpatialSubGraph::invertHash( name );
    Set _.edges_info[ k ] };
  
///////////////////////////////////////////////////////////////////////////////
  Real GetDistance( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

///////////////////////////////////////////////////////////////////////////////
  Real GetEdgeLabel( Real id1, Real id2 )
///////////////////////////////////////////////////////////////////////////////
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.

    Ahora mismo es dependiente de la tabla dens_graph_single.
   */
  Static @SpatialSubGraph NewSQL( NameBlock dbconn, Real EdgeThreshold )
  {
    Real dbconn::Activate( ? );

    WriteLn( "Consultando nodos de la base de datos" );
    Text query_edges =
      "SELECT * FROM dens_graph_new_single WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query_edges );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::getHashKey( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );

    WriteLn( "Consultando nodos de la base de datos" );
    Text query_nodes =
      "SELECT ID_EMP_1 FROM DENS_GRAPH_NEW WHERE dist < " <<
      EdgeThreshold + " GROUP BY id_emp_1";
    Set nodes = DBTable( query_nodes );
    Set nodes_info = EvalSet( nodes, Real( Set node ) {
        Real id = node[ 1 ];
        Text name = FormatReal( id, "%.0f" );
        Set PutName( name, id )
      } );
    Real SetIndexByName( nodes_info );
   

    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.nodes_info = nodes_info;
      Set _.edges_info = edges_info
    ]]
  };

  Static Text getHashKey(  Real id1, Real id2 )
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  };

  Static Set invertHash(  Text hash  )
  {
    Set Eval( "SetOfReals(" + hash + ")" )
  }

};

@SpatialSubGraph obj = @SpatialSubGraph::New( RaDe3G.DB::rade3g, 1000 );



// Martes, 2009/11/03 13:32:09.00
Text  txt1 = "1234,,198";
Set tok = Tokenizer( txt1, "," );


// Martes, 2009/11/03 13:31:45.00
Text  txt = "1234,198";
Set tok = Tokenizer( txt, "," );


// Martes, 2009/11/03 13:31:37.00
Text  txt = "1234,198";
Set tok = Tokenizer( txt, "," );


// Martes, 2009/11/03 13:31:34.00
Text  txt = "1234,198";
Set tok = Tokenizer( txt, "," );


// Martes, 2009/11/03 13:31:28.00
Text  txt = "1234,198";
Set tok = Tokenizer( txt );


// Martes, 2009/11/03 07:29:54.00
Real TextToReal( Text v )
  {
    WriteLn( "TextToReal( \"" + v + "\" );" );
    Set result = Tcl_EvalEx( [[ "expr", v]] );
    Real If( result::status, Eval( result::result ), ? )
  };

Text _differenceName( Text variable )
///////////////////////////////////////////////////////////////////////////////
  {    
    Text If( TextBeginWith( variable, "DIF" ), {
        Real isep = TextFind( variable, ".",  4 );
        Text If( isep, {
            Real degree = TextToReal( Sub( variable, 4, isep - 1 ) );
            If ( IsUnknown( degree ), {
                Text "DIF1." + variable
              }, {
                Text "DIF" + FormatReal( degree + 1, "%.0f." ) +
                  Sub( variable, isep + 1, TextLength( variable ) )
              } )
          }, {
            Text "DIF1." + variable
          } )
      }, {
        Text "DIF1." + variable
      } )
  };

Text _differenceName( "density" );
Text _differenceName( "DIF.density" );
Text _differenceName( "DIFx.density" );
Text _differenceName( "DIF2.density" );
Text _differenceName( "DIF9.density" );
Text _differenceName( "DIF10.density" );


Set Tcl_EvalEx( [[ "expr", "3" ]] );
Set Tcl_EvalEx( [[ "expr", "3" ]] );
Set Tcl_EvalEx( [[ "expr", "x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.2" ]] );
Set Tcl_EvalEx( [[ "expr", "3." ]] );




// Martes, 2009/11/03 07:29:18.00
Real TextToReal( Text v )
  {
    WriteLn( "TextToReal( \"" + v + "\" );" );
    Set result = Tcl_EvalEx( [[ "expr", v]] );
    Real If( result::status, Eval( result::result ), ? )
  };

Text _differenceName( Text variable )
///////////////////////////////////////////////////////////////////////////////
  {    
    Text If( TextBeginWith( variable, "DIF" ), {
        Real isep = TextFind( variable, ".",  4 );
        Text If( isep, {
            Real degree = TextToReal( Sub( variable, 4, isep - 1 ) );
            If ( IsUnknown( degree ), {
                Text "DIF1." + variable
              }, {
                Text "DIF." + FormatReal( degree + 1, "%.0f" ) +
                  Sub( variable, isep + 1, TextLength( variable ) )
              } )
          }, {
            Text "DIF1." + variable
          } )
      }, {
        Text "DIF1." + variable
      } )
  };

Text _differenceName( "density" );
Text _differenceName( "DIF.density" );
Text _differenceName( "DIFx.density" );
Text _differenceName( "DIF2.density" );
Text _differenceName( "DIF9.density" );
Text _differenceName( "DIF10.density" );


Set Tcl_EvalEx( [[ "expr", "3" ]] );
Set Tcl_EvalEx( [[ "expr", "3" ]] );
Set Tcl_EvalEx( [[ "expr", "x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.2" ]] );
Set Tcl_EvalEx( [[ "expr", "3." ]] );




// Martes, 2009/11/03 07:27:29.00
Real TextToReal( Text v )
  {
    WriteLn( "TextToReal( \"" + v + "\" )" );
    Set result = Tcl_EvalEx( [[ "expr", v]] );
    Real If( result::status, Eval( result::result ), ? )
  };

Text _differenceName( Text variable )
///////////////////////////////////////////////////////////////////////////////
  {    
    Text If( TextBeginWith( variable, "DIF" ), {
        Real isep = TextFind( variable, ".",  4 );
        Text If( isep, {
            Real degree = TextToReal( Sub( variable, 4, isep - 1 ) );
            If ( IsUnknown( degree ), {
                Text "DIF1." + variable
              }, {
                Text "DIF." + FormatReal( degree + 1, ".0f" ) +
                  Sub( variable, isep + 1, TextLength( variable ) )
              } )
          }, {
            Text "DIF1." + variable
          } )
      }, {
        Text "DIF1." + variable
      } )
  };

Text _differenceName( "density" );
Text _differenceName( "DIF.density" );
Text _differenceName( "DIFx.density" );
Text _differenceName( "DIF2.density" );
Text _differenceName( "DIF9.density" );
Text _differenceName( "DIF10.density" );

Real TextToReal( "" );
TextToReal( "x" );
TextToReal( "2" );
TextToReal( "9" );
TextToReal( "10" );


Set Tcl_EvalEx( [[ "expr", "3" ]] );
Set Tcl_EvalEx( [[ "expr", "3" ]] );
Set Tcl_EvalEx( [[ "expr", "x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.2" ]] );
Set Tcl_EvalEx( [[ "expr", "3." ]] );




// Martes, 2009/11/03 07:26:12.00
Real TextToReal( "" );
TextToReal( "x" );
TextToReal( "2" );
TextToReal( "9" );
TextToReal( "10" );


// Martes, 2009/11/03 07:24:47.00
Real TextToReal( Text v )
  {
    WriteLn( "TextToReal( \"" + v + "\" )" );
    Set result = Tcl_EvalEx( [[ "expr", v]] );
    Real If( result::status, Eval( result::result ), ? )
  };

Text _differenceName( Text variable )
///////////////////////////////////////////////////////////////////////////////
  {    
    Text If( TextBeginWith( variable, "DIF" ), {
        Real isep = TextFind( variable, ".",  4 );
        Text If( isep, {
            Real degree = TextToReal( Sub( variable, 4, isep - 1 ) );
            If ( EQ( degree, ? ), {
                Text "DIF1." + variable
              }, {
                Text "DIF." + FormatReal( degree + 1, ".0f" ) +
                  Sub( variable, isep + 1, TextLength( variable ) )
              } )
          }, {
            Text "DIF1." + variable
          } )
      }, {
        Text "DIF1." + variable
      } )
  };

Text _differenceName( "density" );
Text _differenceName( "DIF.density" );
Text _differenceName( "DIFx.density" );
Text _differenceName( "DIF2.density" );
Text _differenceName( "DIF9.density" );
Text _differenceName( "DIF10.density" );


Set Tcl_EvalEx( [[ "expr", "3" ]] );
Set Tcl_EvalEx( [[ "expr", "3" ]] );
Set Tcl_EvalEx( [[ "expr", "x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.2" ]] );
Set Tcl_EvalEx( [[ "expr", "3." ]] );



// Martes, 2009/11/03 07:22:45.00
Real TextToReal( Text v )
  {
    WriteLn( "TextToReal( " + v + " )" );
    Set result = Tcl_EvalEx( [[ "expr", v]] );
    Real If( result::status, Eval( result::result ), ? )
  };

Text _differenceName( Text variable )
///////////////////////////////////////////////////////////////////////////////
  {    
    Text If( TextBeginWith( variable, "DIF" ), {
        Real isep = TextFind( variable, ".",  4 );
        Text If( isep, {
            Real degree = TextToReal( Sub( variable, 4, isep - 1 ) );
            If ( EQ( degree, ? ), {
                Text "DIF1." + variable
              }, {
                Text "DIF." + FormatReal( degree + 1, ".0f" ) +
                  Sub( variable, isep + 1, TextLength( variable ) )
              } )
          }, {
            Text "DIF1." + variable
          } )
      }, {
        Text "DIF1." + variable
      } )
  };

Text _differenceName( "density" );
Text _differenceName( "DIF.density" );
Text _differenceName( "DIFx.density" );
Text _differenceName( "DIF2.density" );
Text _differenceName( "DIF9.density" );
Text _differenceName( "DIF10.density" );


Set Tcl_EvalEx( [[ "expr", "3" ]] );
Set Tcl_EvalEx( [[ "expr", "x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.2" ]] );
Set Tcl_EvalEx( [[ "expr", "3." ]] );



// Martes, 2009/11/03 07:22:21.00
Real TextToReal( Text v )
  {
    WriteLn( "TextToReal( " + v + " )" );
    Set result = Tcl_EvalEx( [[ "expr", v]] );
    Real If( result::status, Eval( result::result ), ? )
  };

Text _differenceName( Text variable )
///////////////////////////////////////////////////////////////////////////////
  {    
    Text If( TextBeginWith( variable, "DIF" ), {
        Real isep = TextFind( variable, ".",  4 );
        Text If( isep, {
            Real degree = TextToReal( Sub( variable, 4, isep - 1 ) );
            If ( EQ( degree, ? ), {
                Text "DIF1." + variable
              }, {
                Text "DIF." + FormatReal( degree + 1, ".0f" ) +
                  Sub( variable, isep + 1, TextLength( variable ) )
              } )
          }, {
            Text "DIF1." + variable
          } )
      }, {
        Text "DIF1." + variable
      } )
  };

Text _differenceName( "density" );
Text _differenceName( "DIF.density" );
Text _differenceName( "DIFx.density" );
Text _differenceName( "DIF2.density" );
Text _differenceName( "DIF9.density" );
Text _differenceName( "DIF10.density" );


Set Tcl_EvalEx( [[ "expr", "3" ]] );
Set Tcl_EvalEx( [[ "expr", "x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.2" ]] );
Set Tcl_EvalEx( [[ "expr", "3." ]] );



// Martes, 2009/11/03 07:20:20.00
Real TextToReal( Text v )
  {
    Set result = Tcl_EvalEx( [[ "expr", v]] );
    Real If( result::status, Eval( result::result ), ? )
  };

Text _differenceName( Text variable )
///////////////////////////////////////////////////////////////////////////////
  {    
    Text If( TextBeginWith( variable, "DIF" ), {
        Real isep = TextFind( variable, ".",  4 );
        Text If( isep, {
            Real degree = TextToReal( Sub( variable, 4, isep - 1 ) );
            If ( EQ( degree, ? ), {
                Text "DIF1." + variable
              }, {
                Text "DIF." + FormatReal( degree + 1, ".0f" ) +
                  Sub( variable, isep + 1, TextLength( variable ) )
              } )
          }, {
            Text "DIF1." + variable
          } )
      }, {
        Text "DIF1." + variable
      } )
  };

Text _differenceName( "density" );
Text _differenceName( "DIF.density" );
Text _differenceName( "DIFx.density" );
Text _differenceName( "DIF2.density" );
Text _differenceName( "DIF9.density" );
Text _differenceName( "DIF10.density" );


Set Tcl_EvalEx( [[ "expr", "3" ]] );
Set Tcl_EvalEx( [[ "expr", "x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.2" ]] );
Set Tcl_EvalEx( [[ "expr", "3." ]] );



// Martes, 2009/11/03 07:19:50.00
Real TextToReal( Text v )
  {
    Set result = Tcl_EvalX( [[ "expr", v]] );
    Real If( result::status, Eval( result::result ), ? )
  };

Text _differenceName( Text variable )
///////////////////////////////////////////////////////////////////////////////
  {    
    Text If( TextBeginWith( variable, "DIF" ), {
        Real isep = TextFind( variable, ".",  4 );
        Text If( isep, {
            Real degree = TextToReal( Sub( variable, 4, isep - 1 ) );
            If ( EQ( degree, ? ), {
                Text "DIF1." + variable
              }, {
                Text "DIF." + FormatReal( degree + 1, ".0f" ) +
                  Sub( variable, isep + 1, TextLength( variable ) )
              } )
          }, {
            Text "DIF1." + variable
          } )
      }, {
        Text "DIF1." + variable
      } )
  };

Text _differenceName( "density" );
Text _differenceName( "DIF.density" );
Text _differenceName( "DIFx.density" );
Text _differenceName( "DIF2.density" );
Text _differenceName( "DIF9.density" );
Text _differenceName( "DIF10.density" );


Set Tcl_EvalEx( [[ "expr", "3" ]] );
Set Tcl_EvalEx( [[ "expr", "x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.2" ]] );
Set Tcl_EvalEx( [[ "expr", "3." ]] );



// Martes, 2009/11/03 07:19:13.00
Real TextToReal( Text v )
  {
    Set result = Tcl_EvalX( [[ "expr", v]] );
    Real If( result::status, Eval( result::result ), ? )
  };

Text _differenceName( Text variable )
///////////////////////////////////////////////////////////////////////////////
  {    
    Text If( TextBeginWith( variable, "DIF" ), {
        Real isep = TextFind( variable, ".",  4 );
        Text If( isep, {
            Real degree = TextToReal( Sub( variable, 4, isep - 1 ) );
            If ( EQ( degree, ? ), {
                Text "DIF1." + variable
              }, {
                Text "DIF." + FormatReal( degree + 1, ".0f" ) +
                  Sub( variable, isep + 1, TextLength( variable ) )
              } )
          }, {
            Text "DIF1." + variable
          } )
      }, {
        Text "DIF1." + variable
      } )
  };

Text _differenceName( "density" );
Text _differenceName( "DIF_density" );
Text _differenceName( "DIFx_density" );
Text _differenceName( "DIF2_density" );
Text _differenceName( "DIF9_density" );
Text _differenceName( "DIF10_density" );


Set Tcl_EvalEx( [[ "expr", "3" ]] );
Set Tcl_EvalEx( [[ "expr", "x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.2" ]] );
Set Tcl_EvalEx( [[ "expr", "3." ]] );



// Martes, 2009/11/03 07:14:52.00
Set Tcl_EvalEx( [[ "expr", "3" ]] );
Set Tcl_EvalEx( [[ "expr", "x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.x" ]] );
Set Tcl_EvalEx( [[ "expr", "3.2" ]] );
Set Tcl_EvalEx( [[ "expr", "3." ]] );


// Martes, 2009/11/03 07:01:11.00
Text ParseError( "Real x" );

// Martes, 2009/11/03 06:58:03.00
Text _differenceName( Text variable )
///////////////////////////////////////////////////////////////////////////////
  {    
    Text If( TextBeginWith( variable, "DIF" ), {
        Real isep = TextFind( variable, "_",  4 );
        Text If( isep, {
            Text degree = Sub( variable, 4, isep - 1 );
            If ( TextLength( ParseError( "Real " + degree ) ), {
                Text "DIF1_" + variable
              }, {
                Real deg = Eval( degree );
                Text "DIF" + FormatReal( deg + 1, ".0f" ) +
                  Sub( variable, isep + 1, TextLength( variable ) )
              } )
          }, {
            Text "DIF1_" + variable
          } )
      }, {
        Text "DIF1_" + variable
      } )
  };

Text _differenceName( "density" );
Text _differenceName( "DIF_density" );
Text _differenceName( "DIFx_density" );
Text _differenceName( "DIF2_density" );
Text _differenceName( "DIF9_density" );
Text _differenceName( "DIF10_density" );





// Lunes, 2009/11/02 18:13:07.00
/*
  @SpatialSubGraph --

  Subgrafo del grafo completo de BTS. El subgrafo se forma eligiendo
  aristas cuya longitud es menor que un umbral dado
*/

Class @SpatialSubGraph
{
  Set _.edges_info;
  Real _.radius = 3000;

  Real GetNumberOfEdges( Real void ) { Real Card( _.edges_info ) };

  Set GetEdgeInfo( Real k ) { Set _.edges_info[ k ] };

  Real GetDistance( Real id1, Real id2 )
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

  Real GetEdgeLabel( Real id1, Real id2 )
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  Static @SpatialSubGraph New( NameBlock dbconn, Real EdgeThreshold )
  {
    Real dbconn::Activate( ? );
    Text query =
      "SELECT * FROM dens_graph_single WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::getHashKey( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );
    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.edges_info = edges_info
    ]]
  };

  Static Text getHashKey(  Real id1, Real id2 )
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  }
};

@SpatialSubGraph obj = @SpatialSubGraph::New( RaDe3G.DB::rade3g, 1000 );

Class @DiscreteDistance
{
  Set _.knots;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfIntervals( Real void ) { Real Card( _.knots ) - 1 };
///////////////////////////////////////////////////////////////////////////////

  Real FindRange( Real dist )
  {
    Real _bin_search( dist, 1, Card( _.knots ) )
  };

///////////////////////////////////////////////////////////////////////////////
  Real _bin_search( Real dist, Real low, Real high )
///////////////////////////////////////////////////////////////////////////////
  {
    Real If( EQ( high - low, 1 ), low, {
        Real mid = Floor( ( low + high ) / 2 );
        Real knot = _.knots[ mid ];
        If( dist < knot,
            _bin_search( dist, low, mid ),
            _bin_search( dist, mid, high ) )
      } )
  };
  
  Static @DiscreteDistance New( Set knots )
  {
    @DiscreteDistance obj =
      [[
        Set _.knots = [[ 0 ]] << knots
      ]]  
  }
};

@DiscreteDistance intervals = @DiscreteDistance::New( Range( 300, 1000, 100 ) );
Real intervals::FindRange( 450 );
Real intervals::FindRange( 500 );

Class @EdgesBin
{
  Set _.edges_bin;
  
  Set GetEdgesInBin( Real bin )
  {
    Set _.edges_bin[ bin ]
  };

  Static @EdgesBin New( @SpatialSubGraph subgraph, @DiscreteDistance partition )
  {
    Set edges_bin =
      For( 1, partition::GetNumberOfIntervals(?), Set( Real k ) {
          Set Copy( Empty )
        } );
    Set For( 1, subgraph::GetNumberOfEdges(?), Real( Real k ) {
        Set edge = subgraph::GetEdgeInfo( k );
        Real range = partition::FindRange( edge[ 1 ] );
        Real edge[ 2 ] := range;
        Set Append( edges_bin[ range ], [[ k ]] );
        Real 0
      } );
    @EdgesBin obj =
    [[
      Set _.edges_bin = edges_bin
    ]]
  }
};

@EdgesBin ebins = @EdgesBin::New( obj, intervals );



// Lunes, 2009/11/02 18:12:01.00
/*
  @SpatialSubGraph --

  Subgrafo del grafo completo de BTS. El subgrafo se forma eligiendo
  aristas cuya longitud es menor que un umbral dado
*/

Class @SpatialSubGraph
{
  Set _.edges_info;
  Real _.radius = 3000;

  Real GetNumberOfEdges( Real void ) { Real Card( _.edges_info ) };

  Real GetDistance( Real id1, Real id2 )
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

  Real GetEdgeLabel( Real id1, Real id2 )
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  Static @SpatialSubGraph New( NameBlock dbconn, Real EdgeThreshold )
  {
    Real dbconn::Activate( ? );
    Text query =
      "SELECT * FROM dens_graph_single WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::getHashKey( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );
    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.edges_info = edges_info
    ]]
  };

  Static Text getHashKey(  Real id1, Real id2 )
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  }
};

@SpatialSubGraph obj = @SpatialSubGraph::New( RaDe3G.DB::rade3g, 1000 );

Class @DiscreteDistance
{
  Set _.knots;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfIntervals( Real void ) { Real Card( _.knots ) - 1 };
///////////////////////////////////////////////////////////////////////////////

  Real FindRange( Real dist )
  {
    Real _bin_search( dist, 1, Card( _.knots ) )
  };

///////////////////////////////////////////////////////////////////////////////
  Real _bin_search( Real dist, Real low, Real high )
///////////////////////////////////////////////////////////////////////////////
  {
    Real If( EQ( high - low, 1 ), low, {
        Real mid = Floor( ( low + high ) / 2 );
        Real knot = _.knots[ mid ];
        If( dist < knot,
            _bin_search( dist, low, mid ),
            _bin_search( dist, mid, high ) )
      } )
  };
  
  Static @DiscreteDistance New( Set knots )
  {
    @DiscreteDistance obj =
      [[
        Set _.knots = [[ 0 ]] << knots
      ]]  
  }
};

@DiscreteDistance intervals = @DiscreteDistance::New( Range( 300, 1000, 100 ) );
Real intervals::FindRange( 450 );
Real intervals::FindRange( 500 );

Class @EdgesBin
{
  Set _.edges_bin;
  
  Set GetEdgesInBin( Real bin )
  {
    Set _.edges_bin[ bin ]
  };

  Static @EdgesBin New( @SpatialSubGraph subgraph, @DiscreteDistance partition )
  {
    Set edges_bin =
      For( 1, partition::GetNumberOfIntervals(?), Set( Real k ) {
          Set Copy( Empty )
        } );
    Set For( 1, subgraph::GetNumberOfEdges(?), Real( Real k ) {
        Set edge = subgraph::GetEdgeInfo( k );
        Real range = partition::FindRange( edge[ 1 ] );
        Real edge[ 2 ] := range;
        Set Append( edges_bin[ range ], [[ k ]] );
        Real 0
      } );
    @EdgesBin obj =
    [[
      Set _.edges_bin = edges_bin
    ]]
  }
};

@EdgesBin ebins = @EdgesBin::New( obj, intervals );



// Lunes, 2009/11/02 18:10:47.00
/*
  @SpatialSubGraph --

  Subgrafo del grafo completo de BTS. El subgrafo se forma eligiendo
  aristas cuya longitud es menor que un umbral dado
*/

Class @SpatialSubGraph
{
  Set _.edges_info;
  Real _.radius = 3000;

  Real GetNumberOfEdges( Real void ) { Real Card( _.edges_info ) };

  Real GetDistance( Real id1, Real id2 )
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

  Real GetEdgeLabel( Real id1, Real id2 )
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  Static @SpatialSubGraph New( NameBlock dbconn, Real EdgeThreshold )
  {
    Real dbconn::Activate( ? );
    Text query =
      "SELECT * FROM dens_graph_single WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::getHashKey( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );
    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.edges_info = edges_info
    ]]
  };

  Static Text getHashKey(  Real id1, Real id2 )
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  }
};

@SpatialSubGraph obj = @SpatialSubGraph::New( RaDe3G.DB::rade3g, 1000 );

Class @DiscreteDistance
{
  Set _.knots;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfIntervals( Real void ) { Real Card( _.knots ) - 1 };
///////////////////////////////////////////////////////////////////////////////

  Real FindRange( Real dist )
  {
    Real _bin_search( dist, 1, Card( _.knots ) )
  };

///////////////////////////////////////////////////////////////////////////////
  Real _bin_search( Real dist, Real low, Real high )
///////////////////////////////////////////////////////////////////////////////
  {
    Real If( EQ( high - low, 1 ), low, {
        Real mid = Floor( ( low + high ) / 2 );
        Real knot = _.knots[ mid ];
        If( dist < knot,
            _bin_search( dist, low, mid ),
            _bin_search( dist, mid, high ) )
      } )
  };
  
  Static @DiscreteDistance New( Set knots )
  {
    @DiscreteDistance obj =
      [[
        Set _.knots = [[ 0 ]] << knots
      ]]  
  }
};

@DiscreteDistance intervals = @DiscreteDistance::New( Range( 300, 1000, 100 ) );
Real intervals::FindRange( 450 );
Real intervals::FindRange( 500 );

Class @EdgesBin
{
  Set _.edges_bin;
  
  Set GetEdgesInBin( Real bin )
  {
    Set _.edges_bin[ bin ]
  };

  Static @EdgesBin New( @SpatialSubGraph subgraph, @DiscreteDistance partition )
  {
    Set edges_bin =
      For( 1, partition::GetNumberOfIntervals(?), Set( Real k ) {
          Set Copy( Empty )
        } );
    Set For( 1, subgraph::GetNumberOfEdges(?), Real( Real k ) {
        Set edge = subgraph::GetEdgeInfo( k );
        Real range = partition::FindRange( edge[ 1 ] );
        Real edge[ 2 ] := range;
        Set Append( edges_bin[ range ], [[ k ]] );
        Real 0
      } );
    @EdgesBin obj =
    [[
      Set _.edges_bin = edges_bin
    ]]
  }
};

@EdgesBin ebins = @EdgesBin::New( obj, intervals );



// Lunes, 2009/11/02 18:09:31.00
Class @EdgesBin
{
  Set _.edges_bin;
  
  Set GetEdgesInBin( Real bin )
  {
    Set _.edges_bin[ bin ]
  };

  Static @EdgesBin New( @SpatialSubGraph subgraph, @DiscreteDistance partition )
  {
    Set edges_bin =
      For( 1, partition::GetNumberOfIntervals(?), Set( Real k ) {
          Set Copy( Empty )
        } );
    Set For( 1, subgraph::GetNumberOfEdges(?), Real( Real k ) {
        Set edge = subgraph::GetEdgeInfo( k );
        Real range = partition::FindRange( edge[ 1 ] );
        Real edge[ 2 ] := range;
        Set Append( edges_bin[ range ], [[ k ]] );
        Real 0
      } );
    @EdgesBin obj =
    [[
      Set _.edges_bin = edges_bin
    ]]
  }
};

@EdgesBin ebins = @EdgesBin::New( obj, intervals );

// Lunes, 2009/11/02 18:07:15.00
Real intervals::FindRange( 500 );

// Lunes, 2009/11/02 18:06:56.00
Class @DiscreteDistance
{
  Set _.knots;

///////////////////////////////////////////////////////////////////////////////
  Real GetNumberOfIntervals( Real void ) { Real Card( _.knots ) - 1 };
///////////////////////////////////////////////////////////////////////////////

  Real FindRange( Real dist )
  {
    Real _bin_search( dist, 1, Card( _.knots ) )
  };

///////////////////////////////////////////////////////////////////////////////
  Real _bin_search( Real dist, Real low, Real high )
///////////////////////////////////////////////////////////////////////////////
  {
    Real If( EQ( high - low, 1 ), low, {
        Real mid = Floor( ( low + high ) / 2 );
        Real knot = _.knots[ mid ];
        If( dist < knot,
            _bin_search( dist, low, mid ),
            _bin_search( dist, mid, high ) )
      } )
  };
  
  Static @DiscreteDistance New( Set knots )
  {
    @DiscreteDistance obj =
      [[
        Set _.knots = [[ 0 ]] << knots
      ]]  
  }
};

@DiscreteDistance intervals = @DiscreteDistance::New( Range( 300, 1000, 100 ) );
Real intervals::FindRange( 450 );


// Lunes, 2009/11/02 17:57:31.00
/*
  @SpatialSubGraph --

  Subgrafo del grafo completo de BTS. El subgrafo se forma eligiendo
  aristas cuya longitud es menor que un umbral dado
*/

Class @SpatialSubGraph
{
  Set _.edges_info;
  Real _.radius = 3000;

  Real GetNumberOfEdges( Real void ) { Real Card( _.edges ) };

  Real GetDistance( Real id1, Real id2 )
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

  Real GetEdgeLabel( Real id1, Real id2 )
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.
   */
  Static @SpatialSubGraph New( NameBlock dbconn, Real EdgeThreshold )
  {
    Real dbconn::Activate( ? );
    Text query =
      "SELECT * FROM dens_graph_single WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::getHashKey( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );
    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.edges_info = edges_info
    ]]
  };

  Static Text getHashKey(  Real id1, Real id2 )
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  }
};

@SpatialSubGraph obj = @SpatialSubGraph::New( RaDe3G.DB::rade3g, 1000 );


// Lunes, 2009/11/02 17:55:16.00
/*
  @SpatialSubGraph --

  Subgrafo del grafo completo de BTS. El subgrafo se forma eligiendo
  aristas cuya longitud es menor que un umbral dado
*/

Class @SpatialSubGraph
{
  Set _.edges_info;
  Real _.radius = 3000;

  Real GetNumberOfEdges( Real void ) { Real Card( _.edges ) };

  Real GetDistance( Real id1, Real id2 )
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

  Real GetEdgeLabel( Real id1, Real id2 )
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.
   */
  Static @SpatialSubGraph New( NameBlock dbconn, Real EdgeThreshold )
  {
    Real dbconn::Activate( ? );
    Text query =
      "SELECT * FROM dens_graph_single WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::getHashKey( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );
    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.edges_info = edges_info
    ]]
  };

  Static Text getHashKey(  Real id1, Real id2 )
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  }
};

@SpatialSubGraph obj = @SpatialSubGraph::New( RaDe3G.DB::rade3g, 4000 );


// Lunes, 2009/11/02 17:54:16.00
/*
  @SpatialSubGraph --

  Subgrafo del grafo completo de BTS. El subgrafo se forma eligiendo
  aristas cuya longitud es menor que un umbral dado
*/

Class @SpatialSubGraph
{
  Set _.edges_info;
  Real _.radius = 3000;

  Real GetNumberOfEdges( Real void ) { Real Card( _.edges ) };

  Set 
  Real GetDistance( Real id1, Real id2 )
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

  Real GetEdgeLabel( Real id1, Real id2 )
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.
   */
  Static @SpatialSubGraph New( NameBlock dbconn, Real EdgeThreshold )
  {
    Real dbconn::Activate( ? );
    Text query =
      "SELECT * FROM dens_graph_single WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::getHashKey( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );
    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.edges_info = edges_info
    ]]
  };

  Static Text getHashKey(  Real id1, Real id2 )
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  }
};

@SpatialSubGraph obj = @SpatialSubGraph::New( RaDe3G.DB::rade3g, 4000 );


// Lunes, 2009/11/02 17:54:00.00
/*
  @SpatialSubGraph --

  Subgrafo del grafo completo de BTS. El subgrafo se forma eligiendo
  aristas cuya longitud es menor que un umbral dado
*/

Class @SpatialSubGraph
{
  Set _.edges_info;
  Real _.radius = 3000;

  Real GetNumberOfEdges( Real void ) { Real Card( _.edges ) };

  Set 
  Real GetDistance( Real id1, Real id2 )
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

  Real GetEdgeLabel( Real id1, Real id2 )
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.
   */
  Static @SpatialSubGraph New( NameBlock dbconn, Real EdgeThreshold )
  {
    Real dbconn::Activate( ? );
    Text query =
      "SELECT * FROM dens_graph_single WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::getHashKey( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );
    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.edges_info = edges_info
    ]]
  };

  Static Text getHashKey(  Real id1, Real id2 )
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  }
};

@SpatialSubGraph obj = @SpatialSubGraph::New( RaDe3G.DB::rade3g, 4000 );


// Lunes, 2009/11/02 17:53:22.00
/*
  @SpatialSubGraph --

  Subgrafo del grafo completo de BTS. El subgrafo se forma eligiendo
  aristas cuya longitud es menor que un umbral dado
*/

Class @SpatialSubGraph
{
  Set _.edges_info;
  Real _.radius = 3000;

  Real GetNumberOfEdges( Real void ) { Real Card( _.edges ) };

  Set 
  Real GetDistance( Real id1, Real id2 )
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

  Real GetEdgeLabel( Real id1, Real id2 )
  {
    Text hash = @SpatialSubGraph::getHashKey( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.
   */
  Static @SpatialSubGraph New( NameBlock dbconn, Real EdgeThreshold )
  {
    Real dbconn::Activate( ? );
    Text query =
      "SELECT * FROM dens_graph_single WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @SpatialSubGraph::getHashKey( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );
    @SpatialSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.edges_info = edges_info
    ]]
  };

  Static Text getHashKey(  Real id1, Real id2 )
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  }
};

@BtsSubGraph obj = @BtsSubGraph::New( RaDe3G.DB::rade3g, 4000 );


// Lunes, 2009/11/02 16:05:39.00
@BtsSubGraph obj1 = @BtsSubGraph::New( RaDe3G.DB::rade3g, 8000 );

// Lunes, 2009/11/02 16:03:53.00
Class @BtsSubGraph
{
  Set _.edges_info;
  Real _.radius = 3000;

  Real GetDistance( Real id1, Real id2 )
  {
    Text hash = @BtsSubGraph::getHashKey( id1, id2 ),
    Real _.edges_info[ hash ][ 1 ]
  };

  Real GetEdgeLabel( Real id1, Real id2 )
  {
    Text hash = @BtsSubGraph::getHashKey( id1, id2 );
    Real _.edges_info[ hash ][ 2 ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.
   */
  Static @BtsSubGraph New( NameBlock dbconn, Real EdgeThreshold )
  {
    Real dbconn::Activate( ? );
    Text query =
      "SELECT * FROM dens_graph_single WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query );
    Set edges_info = EvalSet( edges, Set( Set edge ) {
        Text hash = @BtsSubGraph::getHashKey( edge[ 1 ], edge[ 2 ] );
        Set aux = [[ edge[ 3 ], 0 ]];
        Set PutName( hash, aux )
      } );
    Real SetIndexByName( edges_info );
    @BtsSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.edges_info = edges_info
    ]]
  };

  Static Text getHashKey(  Real id1, Real id2 )
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  }
};

@BtsSubGraph obj = @BtsSubGraph::New( RaDe3G.DB::rade3g, 1000 );


// Lunes, 2009/11/02 16:01:07.00
Class @BtsSubGraph
{
  Set _.edges_label;
  Set _.edges_dist;
  Real _.radius = 3000;

  Real GetDistance( Real id1, Real id2 )
  {
    Text hash = @BtsSubGraph::getHashKey( id1, id2 ),
    Real _.edges_dist[ hash ]
  };

  Real GetEdgeLabel( Real id1, Real id2 )
  {
    Text hash = @BtsSubGraph::getHashKey( id1, id2 );
    Real _edges_label[ hash ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.
   */
  Static @BtsSubGraph New( NameBlock dbconn, Real EdgeThreshold )
  {
    Real dbconn::Activate( ? );
    Text query =
      "SELECT * FROM dens_graph_single WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query );
    Set edges_label = Copy( Empty );
    Set edges_dist = EvalSet( edges, Real( Set edge ) {
        Text hash = @BtsSubGraph::getHashKey( edge[ 1 ], edge[ 2 ] );
        Real info = 0;
        Real PutName( hash, info );
        Set Append( edges_label, [[ info ]] );
        Real aux = edge[ 3 ];
        Real PutName( hash, aux )
      } );
    Real SetIndexByName( edges_label );
    Real SetIndexByName( edges_dist );
    @BtsSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.edges_dist = edges_dist;
      Set _.edges_label = edges_label
    ]]
  };

  Static Text getHashKey(  Real id1, Real id2 )
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  }
};

@BtsSubGraph obj = @BtsSubGraph::New( RaDe3G.DB::rade3g, 1000 );


// Lunes, 2009/11/02 16:00:26.00
Class @BtsSubGraph
{
  Set _.edges_label;
  Set _.edges_dist;
  Real _.radius = 3000;

  Real GetDistance( Real id1, Real id2 )
  {
    Text hash = @BtsSubGraph::getHashKey( id1, id2 ),
    Real _.edges_dist[ hash ]
  };

  Real GetEdgeLabel( Real id1, Real id2 )
  {
    Text hash = @BtsSubGraph::getHashKey( id1, id2 );
    Real _edges_label[ hash ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.
   */
  Static @BtsSubGraph New( NameBlock dbconn, Real EdgeThreshold )
  {
    Real dbconn::Activate( ? );
    Text query =
      "SELECT * FROM dens_graph_single WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query );
    Set edges_label = Copy( Empty );
    Set edges_dist = EvalSet( edges, Real( Set edge ) {
        Text hash = @BtsSubGraph::getHashKey( edge[ 1 ], edge[ 2 ] );
        Real info = 0;
        Real PutName( hash, info );
        Set Append( edges_label, [[ info ]] );
        Real aux = edge[ 3 ];
        Real PutName( hash, aux )
      } );
    Real SetIndexByName( edges_label );
    Real SetIndexByName( edges_dist );
    @BtsSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.edges_dist = edges_dist;
      Set _.edges_map = edges_map
    ]]
  };

  Static Text getHashKey(  Real id1, Real id2 )
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ),
             FormatReal( id1, "%.0f") + "," + FormatReal( id2, "%.0f" ) )
  }
};

@BtsSubGraph obj = @BtsSubGraph::New( RaDe3G.DB::rade3g, 1000 );


// Lunes, 2009/11/02 15:59:16.00
@BtsSubGraph obj = @BtsSubGraph::New( RaDe3G.DB::rade3g, 1000 );

// Lunes, 2009/11/02 15:58:43.00
Class @BtsSubGraph
{
  Set _.edges_label;
  Set _.edges_dist;
  Real _.radius = 3000;

  Real GetDistance( Real id1, Real id2 )
  {
    Text hash = @BtsSubGraph::getHashKey( id1, id2 ),
    Real _.edges_dist[ hash ]
  };

  Real GetEdgeLabel( Real id1, Real id2 )
  {
    Text hash = @BtsSubGraph::getHashKey( id1, id2 );
    Real _edges_label[ hash ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.
   */
  Static @BtsSubGraph New( NameBlock dbconn, Real EdgeThreshold )
  {
    Real dbconn::Activate( ? );
    Text query =
      "SELECT * FROM dens_graph_single WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query );
    Set edges_label = Copy( Empty );
    Set edges_dist = EvalSet( edges, Real( Set edge ) {
        Text hash = @BtsSubGraph::getHashKey( edge[ 1 ], edge[ 2 ] );
        Real info = 0;
        Real PutName( hash, info );
        Set Append( edges_label, [[ info ]] );
        Real aux = edge[ 3 ];
        Real PutName( hash, aux )
      } );
    Real SetIndexByName( edges_label );
    Real SetIndexByName( edges_dist );
    @BtsSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.edges_dist = edges_dist;
      Set _.edges_map = edges_map
    ]]
  };

  Static Text getHashKey(  Real id1, Real id2 )
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%g") + "," + FormatReal( id2, "%g" ),
             FormatReal( id1, "%g") + "," + FormatReal( id2, "%g" ) )
  }
};



// Lunes, 2009/11/02 15:53:33.00
Class @BtsSubGraph
{
  Set _.edges_map;
  Set _.edges_dist;
  Real _.radius = 3000;

  Real GetDistance( Real id1, Real id2 )
  {
    Text hash = @BtsSubGraph::getHashKey( Real id1, Real id2 ),
    Real _.edges_dist[ hash ]
  };

  Real GetEdgeLabel( Real id1, Real id2 )
  {
    Text hash = @BtsSubGraph::getHashKey( id1, id2 );
    Real _edges_map[ hash ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.
   */
  Static @BtsSubGraph New( NameBlock dbconn, Real EdgeThreshold )
  {
    Real dbconn::Activate( ? );
    Text query =
      "SELECT * FROM dens_graph_single WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query );
    Set edges_map = Copy( Empty );
    Set edges_dist = EvalSet( edges, Real( edge ) {
        Text hash = @BtsSubGraph::getHashKey( edge[ 1 ], edge[ 1 ] );
        Real info = 0;
        Real PutName( hash, info );
        Set Append( edges_map, [[ info ]] );
        Real aux = edge[ 3 ];
        Real PutName( hash, aux )
      } );
    Real SetIndexByName( edges_map );
    Real SetIndexByName( edges_dist );
    @BtsSubGraph obj = [[
      Real _.radius = EdgeThreshold;
      Set _.edges_dist = edges_dist;
      Set _.edges_map = edges_map
    ]]
  };

  Static Text getHashKey(  Real id1, Real id2 )
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%g") + "," + FormatReal( id2, "%g" ),
             FormatReal( id1, "%g") + "," + FormatReal( id2, "%g" ) )
  }
};

@BtsSubGraph obj = @BtsSubGraph::New( RaDe3G.DB::rade3g, 4000 );



// Lunes, 2009/11/02 15:31:53.00
Class @BtsSubGraph
{
  Set _.edges_map = Copy( Empty );
  Set _.edges_dist = Copy( Empty );
  Real _.radius = 3000;

  Text getHashKey(  Real id1, Real id2 )
  {
    Text If( id1 < id2, 
             FormatReal( id1, "%g") + "," + FormatReal( id2, "%g" ),
             FormatReal( id1, "%g") + "," + FormatReal( id2, "%g" ) )
           };
  
  Real GetDistance( Real id1, Real id2 )
  {
    Text hash = getHashKey( Real id1, Real id2 ),
    Real _.edges_dist[ hash ]
  };

  Real GetEdgeLabel( Real id1, Real id2 )
  {
    Text hash = getHashKey( id1, id2 );
    Real _edges_map[ hash ]
  };

  /*
    Creo que esta funcion puede hacerse a partir de BtsInfo y no de
    esta tabla reduciendo riesgo de desactualizacion de la tabla.
   */
  Static @BtsSubGraph New( NameBlock dbconn, Real EdgeThreshold )
  {
    @BtsSubGraph obj = [[ Real _.radius = EdgeThreshold ]];
    Real dbconn::Activate( ? );
    Text query =
      "SELECT * FROM dens_graph_single WHERE dist < " << EdgeThreshold;
    Set edges = DBTable( query );
    Set obj::_.edges_dist = EvalSet( edges, Real( edge ) {
        Text hash = getHashKey( edge[ 1 ], edge[ 1 ] );
        Real info = 0;
        Real PutName( hash, info );
        Set Append( _.edges_map, [[ info ]] );
        Real aux = edge[ 3 ];
        Real PutName( hash, aux )
      } );
    Real SetIndexByName( _.edges_map );
    Real SetIndexByName( _.edges_dist );
    obj
  }
};

@BtsSubGraph obj = @BtsSubGraph::New( RaDe3G.DB::rade3g, 4000 );



// Lunes, 2009/11/02 09:51:12.00
Set dens.data::GetVariablesForObsIndex( 1, [[ "X_30", "Y_30" ]] );


// Lunes, 2009/11/02 09:51:04.00
Set dens.data::GetVariablesForObsIndex( 1, [ "X_30", "Y_30" ]] );


// Lunes, 2009/11/02 09:17:20.00
NameBlock df = LoadDensificationData( 0 );
  Set df::GetVariablesForObs( "5001084", [[ "X_30", "Y_30" ]] );

// Lunes, 2009/11/02 09:16:02.00
 NameBlock df = LoadDensificationData( 0 );
  Set df::GetVariablesForObs( "5001084", [[ "X_30", "Y_30" ]] );

// Lunes, 2009/11/02 09:15:05.00
 NameBlock df = LoadDensificationData( 0 );
  Set df::GetVariablesForObs( "5001084", [[ "X_30", "Y_30" ]] );

// Lunes, 2009/11/02 09:14:06.00
 NameBlock df = LoadDensificationData( 0 );
  Set df::GetVariablesForObs( "5001084", [[ "X_30", "Y_30" ]] );

// Lunes, 2009/11/02 09:13:50.00



// Lunes, 2009/11/02 09:12:37.00
 NameBlock df = LoadDensificationData( 0 );
  Set df::GetVariablesForObs( "5001084", [[ "X_30", "Y_30" ]] );


// Lunes, 2009/11/02 09:11:53.00
Set df::GetVariablesForObs( "5001084", [[ "X_30", "Y_30" ]] );

// Lunes, 2009/11/02 09:11:44.00
Set GetVariablesForObs( "5001084", [[ "X_30", "Y_30" ]] );

// Lunes, 2009/11/02 09:11:36.00
Set GetVariablesForObs( "5001084", [[ "X_30", "Y_30" ] );

// Lunes, 2009/11/02 09:09:11.00
NameBlock df = LoadDensificationData( 0 );

// Lunes, 2009/11/02 09:05:25.00
NameBlock df = LoadDensificationData( 0 );

// Lunes, 2009/11/02 09:05:02.00
NameBlock df = LoadDensificationData( 0 );

// Lunes, 2009/11/02 09:03:33.00
Real df::SetIdColumn( "ID_EMPLAZAMIENTO" );


// Lunes, 2009/11/02 09:01:59.00
NameBlock df = LoadDensificationData( 0 );

// Lunes, 2009/11/02 09:01:23.00
NameBlock LoadDensificationData( 0 );

// Lunes, 2009/11/02 00:50:15.00
Set it1 = [[ 1, "1" ]];
Set it2 = [[ 2, "2" ]];
Set cont = [[ it1, it2 ]];

Set ExtractByIndex( cont, [[ 2]] );

// Lunes, 2009/11/02 00:32:38.00
Real N = 20000;
Set pts = For( 1, N, Set ( Real k ) { [[ Real Rand( 0, 1 ), Rand( 0, 1 ) ]] } );
Real size = 0.001;

Set BoundingBox( Set pts )
{
  Set pt1 = pts[1];
  Real min_x = pt1[1];
  Real min_y = pt1[2];
  Real max_x = min_x;
  Real max_y = min_y;
  Set For( 2, Card( pts ), Real( Real k ) {
      Real x = pts[ k ][ 1 ];
      Real y = pts[ k ][ 2 ];
      Real If( x < min_x, min_x := x, If( x > max_x, max_x := x ) );
      Real If( y < min_y, min_y := y, If( y > max_y, max_y := y ) );
      Real 0
    } );
  Set [[ min_x, min_y, max_x, max_y ]]
};

Real DiscretizeCoord( Real C, Real min, Real size ) { Floor( (C  - min ) / size ) };

Set bbox = BoundingBox( pts );

Real min_x = bbox::min_x - size;
Real min_y = bbox::min_y - size;
Set index_pts = For( 1, N, Set( Real k ) {
    Set pt = pts[ k ];
    Real I = DiscretizeCoord( pt[1], min_x, size );
    Real J = DiscretizeCoord( pt[2], min_y, size );
    Set [[ k, I, J ]]
  } );

Real OrderByJ( Set pt1, Set pt2 )
{
  Real Compare( pt1[3], pt2[3] )
};

Real OrderByI( Set pt1, Set pt2 )
{
  Real Compare( pt1[2], pt2[2] )
};

Set cls = Classify( index_pts, OrderByJ );

Set EvalSet( cls, Set( Set row ) {
  Classify( row, OrderByI )
} );






// Lunes, 2009/11/02 00:21:36.00
Real N = 20000;
Set pts = For( 1, N, Set ( Real k ) { [[ Real Rand( 0, 1 ), Rand( 0, 1 ) ]] } );
Real size = 0.001;

Set BoundingBox( Set pts )
{
  Set pt1 = pts[1];
  Real min_x = pt1[1];
  Real min_y = pt1[2];
  Real max_x = min_x;
  Real max_y = min_y;
  Set For( 2, Card( pts ), Real( Real k ) {
      Real x = pts[ k ][ 1 ];
      Real y = pts[ k ][ 2 ];
      Real If( x < min_x, min_x := x, If( x > max_x, max_x := x ) );
      Real If( y < min_y, min_y := y, If( y > max_y, max_y := y ) );
      Real 0
    } );
  Set [[ min_x, min_y, max_x, max_y ]]
};

Real DiscretizeCoord( Real C, Real min, Real size ) { Floor( (C  - min ) / size ) };

Set bbox = BoundingBox( pts );

Real min_x = bbox::min_x - size;
Real min_y = bbox::min_y - size;
Set index_pts = For( 1, N, Set( Real k ) {
    Set pt = pts[ k ];
    Real I = DiscretizeCoord( pt[1], min_x, size );
    Real J = DiscretizeCoord( pt[2], min_y, size );
    Set [[ k, I, J ]]
  } );

Real OrderByJ( Set pt1, Set pt2 )
{
  Real Compare( pt1[3], pt2[3] )
};

Set Classify( index_pts, OrderByJ );






// Lunes, 2009/11/02 00:14:46.00
Real N = 20000;
Set pts = For( 1, N, Set ( Real k ) { [[ Real Rand( 0, 1 ), Rand( 0, 1 ) ]] } );
Real size = 0.001;

Set BoundingBox( Set pts )
{
  Set pt1 = pts[1];
  Real min_x = pt1[1];
  Real min_y = pt1[2];
  Real max_x = min_x;
  Real max_y = min_y;
  Set For( 2, Card( pts ), Real( Real k ) {
      Real x = pts[ k ][ 1 ];
      Real y = pts[ k ][ 2 ];
      Real If( x < min_x, min_x := x, If( x > max_x, max_x := x ) );
      Real If( y < min_y, min_y := y, If( y > max_y, max_y := y ) );
      Real 0
    } );
  Set [[ min_x, min_y, max_x, max_y ]]
};

Real DiscretizeCoord( Real C, Real min, Real size ) { Floor( (C  - min ) / size ) };

Set bbox = BoundingBox( pts );

Real min_x = bbox::min_x; // - size;
Real min_y = bbox::min_y; // - size;
Set index_pts = For( 1, N, Set( Real k ) {
    Set pt = pts[ k ];
    Real I = DiscretizeCoord( pt[1], min_x, size );
    Real J = DiscretizeCoord( pt[2], min_y, size );
    Set [[ k, I, J ]]
  } );

Real OrderByJ( Set pt1, Set pt2 )
{
  Real Compare( pt1[3], pt2[3] )
};

Set Classify( index_pts, OrderByJ );






// Domingo, 2009/11/01 23:06:30.00
Real N = 20000;
Set pts = For( 1, N, Set ( Real k ) { [[ Real Rand( 0, 1 ), Rand( 0, 1 ) ]] } );
Real size = 0.001;

Set BoundingBox( Set pts )
{
  Set pt1 = pts[1];
  Real min_x = pt1[1];
  Real min_y = pt1[2];
  Real max_x = min_x;
  Real max_y = min_y;
  Set For( 2, Card( pts ), Real( Real k ) {
      Real x = pts[ k ][ 1 ];
      Real y = pts[ k ][ 2 ];
      Real If( x < min_x, min_x := x, If( x > max_x, max_x := x ) );
      Real If( y < min_y, min_y := y, If( y > max_y, max_y := y ) );
      Real 0
    } );
  Set [[ min_x, min_y, max_x, max_y ]]
};

Real DiscretizeCoord( Real C, Real min, Real size ) { Floor( (C  - min ) / size ) };

Set bbox = BoundingBox( pts );

Real min_x = bbox::min_x - size;
Real min_y = bbox::min_y - size;
Set index_pts = For( 1, N, Set( Real k ) {
    Set pt = pts[ k ];
    Real I = DiscretizeCoord( pt[1], min_x, size );
    Real J = DiscretizeCoord( pt[2], min_y, size );
    Set [[ k, I, J ]]
  } );

Real OrderByJ( Set pt1, Set pt2 )
{
  Real Compare( pt1[3], pt2[3] )
};

Set Classify( index_pts, OrderByJ );






// Domingo, 2009/11/01 22:41:35.00
Real N = 20000;
Set pts = For( 1, N, Set ( Real k ) { [[ Real Rand( 0, 1 ), Rand( 0, 1 ) ]] } );
Real size = 0.001;

Set BoundingBox( Set pts )
{
  Set pt1 = pts[1];
  Real min_x = pt1[1];
  Real min_y = pt1[2];
  Real max_x = min_x;
  Real max_y = min_y;
  Set For( 2, Card( pts ), Real( Real k ) {
      Real x = pts[ k ][ 1 ];
      Real y = pts[ k ][ 2 ];
      Real If( x < min_x, min_x := x, If( x > max_x, max_x := x ) );
      Real If( y < min_y, min_y := y, If( y > max_y, max_y := y ) );
      Real 0
    } );
  Set [[ min_x, min_y, max_x, max_y ]]
};

Real DiscretizeCoord( Real C, Real min, Real size ) { Floor( (C  - min ) / size ) };

Set bbox = BoundingBox( pts );

Real min_x = bbox::min_x - size;
Real min_y = bbox::min_y - size;
Set index_pts = For( 1, N, Set( Real k ) {
    Set pt = pts[ k ];
    Real I = DiscretizeCoord( pt[1], min_x, size );
    Real J = DiscretizeCoord( pt[2], min_x, size );
    Set [[ k, I, J ]]
  } );

Real OrderByJ( Set pt1, Set pt2 )
{
  Real Compare( pt1[3], pt2[3] )
};

Set Classify( index_pts, OrderByJ );






// Domingo, 2009/11/01 22:40:05.00
Real N = 20000;
Set pts = For( 1, N, Set ( Real k ) { [[ Real Rand( 0, 1 ), Rand( 0, 1 ) ]] } );
Real size = 0.001;

Set BoundingBox( Set pts )
{
  Set pt1 = pts[1];
  Real min_x = pt1[1];
  Real min_y = pt1[2];
  Real max_x = min_x;
  Real max_y = min_y;
  Set For( 2, Card( pts ), Real( Real k ) {
      Real x = pts[ k ][ 1 ];
      Real y = pts[ k ][ 2 ];
      Real If( x < min_x, min_x := x, If( x > max_x, max_x := x ) );
      Real If( y < min_y, min_y := y, If( y > max_y, max_y := y ) );
      Real 0
    } );
  Set [[ min_x, min_y, max_x, max_y ]]
};

Real DiscretizeCoord( Real C, Real min, Real size ) { (C  - min ) / size };

Set bbox = BoundingBox( pts );

Real min_x = bbox::min_x - size;
Real min_y = bbox::min_y - size;
Set index_pts = For( 1, N, Set( Real k ) {
    Set pt = pts[ k ];
    Real I = DiscretizeCoord( pt[1], min_x, size );
    Real J = DiscretizeCoord( pt[2], min_x, size );
    Set [[ k, I, J ]]
  } );

Real OrderByJ( Set pt1, Set pt2 )
{
  Real Compare( pt1[3], pt2[3] )
};

Set Classify( index_pts, OrderByJ );






// Domingo, 2009/11/01 22:39:25.00
Real N = 20000;
Set pts = For( 1, N, Set ( Real k ) { [[ Real Rand( 0, 1 ), Rand( 0, 1 ) ]] } );
Real size = 0.001;

Set BoundingBox( Set pts )
{
  Set pt1 = pts[1];
  Real min_x = pt1[2];
  Real min_y = pt1[3];
  Real max_x = min_x;
  Real max_y = min_y;
  Set For( 2, Card( pts ), Real( Real k ) {
      Real x = pts[ k ][ 2 ];
      Real y = pts[ k ][ 3 ];
      Real If( x < min_x, min_x := x, If( x > max_x, max_x := x ) );
      Real If( y < min_y, min_y := y, If( y > max_y, max_y := y ) );
      Real 0
    } );
  Set [[ min_x, min_y, max_x, max_y ]]
};

Real DiscretizeCoord( Real C, Real min, Real size ) { (C  - min ) / size };

Set bbox = BoundingBox( pts );

Real min_x = bbox::min_x - size;
Real min_y = bbox::min_y - size;
Set index_pts = For( 1, N, Set( Real k ) {
    Set pt = pts[ k ];
    Real I = DiscretizeCoord( pt[1], min_x, size );
    Real J = DiscretizeCoord( pt[2], min_x, size );
    Set [[ k, I, J ]]
  } );

Real OrderByJ( Set pt1, Set pt2 )
{
  Real Compare( pt1[3], pt2[3] )
};

Set Classify( index_pts, OrderByJ );






// Domingo, 2009/11/01 22:38:53.00
Real N = 20000;
Set pts = For( 1, N, Set ( Real k ) { [[ Real Rand( 0, 1 ), Rand( 0, 1 ) ]] } );
Real size = 0.001;

Set ( Set pts )
{
  Set pt1 = pts[1];
  Real min_x = pt1[2];
  Real min_y = pt1[3];
  Real max_x = min_x;
  Real max_y = min_y;
  Set For( 2, Card( pts ), Real( Real k ) {
      Real x = pts[ k ][ 2 ];
      Real y = pts[ k ][ 3 ];
      Real If( x < min_x, min_x := x, If( x > max_x, max_x := x ) );
      Real If( y < min_y, min_y := y, If( y > max_y, max_y := y ) );
      Real 0
    } );
  Set [[ min_x, min_y, max_x, max_y ]]
};

Real DiscretizeCoord( Real C, Real min, Real size ) { (C  - min ) / size };

Set bbox = BoundingBox( pts );

Real min_x = bbox::min_x - size;
Real min_y = bbox::min_y - size;
Set index_pts = For( 1, N, Set( Real k ) {
    Set pt = pts[ k ];
    Real I = DiscretizeCoord( pt[1], min_x, size );
    Real J = DiscretizeCoord( pt[2], min_x, size );
    Set [[ k, I, J ]]
  } );

Real OrderByJ( Set pt1, Set pt2 )
{
  Real Compare( pt1[3], pt2[3] )
};

Set Classify( index_pts, OrderByJ );






// Domingo, 2009/11/01 22:24:41.00
Real N = 10000;
Set pts = For( 1, N, Set ( Real k ) { [[ Real Rand( 0, 1 ), Rand( 0, 1 ) ]] } );
Real size = 0.001;

Real DiscretizeCoord( Real C, Real min, Real size ) { (C  - min ) / size };

Set index_pts = For( 1, N, Set( Real k ) {
    Set pt = pts[ k ];
    Real I = Round( pt[1] / size );
    Real J = Round( pt[2] / size );
    Set [[ k, I, J ]]
  } );

Real OrderByJ( Set pt1, Set pt2 )
{
  Real Compare( pt1[3], pt2[3] )
};

Set Classify( index_pts, OrderByJ );






// Domingo, 2009/11/01 22:19:35.00
Real N = 10000;
Set pts = For( 1, N, Set ( Real k ) { [[ Real Rand( 0, 1 ), Rand( 0, 1 ) ]] } );
Real size = 0.001;

Real DiscretizeCoord( Real C, Real min, Real size ) { (C  - min ) / size };

Set index_pts = For( 1, N, Set( Real k ) {
    Set pt = pts[ k ];
    Real I = Round( pt[1] / size );
    Real J = Round( pt[2] / size );
    Set [[ k, I, J ]]
  } );

Real OrderByJ( Set pt1, Set pt2 )
{
  Real Compare( pt1[2], pt2[2] )
};

Set Classify( index_pts, OrderByJ );






// Domingo, 2009/11/01 22:16:45.00
Real N = 10000;
Set pts = For( 1, N, Set ( Real k ) { [[ Real Rand( 0, 1 ), Rand( 0, 1 ) ]] } );
Real size = 0.001;

Real DiscretizeCoord( Real C, Real min, Real size ) { (C  - min ) / size };

Set index_pts = For( 1, N, Set( Real k ) {
    Set pt = pts[ k ];
    Real I = Round( pt[1] / size );
    Real J = Round( pt[2] / size );
    Set [[ k, I, J ]]
  } );






// Domingo, 2009/11/01 22:12:40.00
Set pts = For( 1, 10000, Set ( Real k ) { [[ Real Rand( 0, 1 ), Rand( 0, 1 ) ]] } );
Real size = 0.001;

Real DiscretizeCoord( Real C, Real min, Real size ) { (C  - min ) / size };






// Domingo, 2009/11/01 22:06:40.00
Set pts = For( 1, 10000, Set ( Real k ) { [[ Real Rand( 0, 1 ), Rand( 0, 1 ) ]] } ); 


// Domingo, 2009/11/01 22:06:38.00
Set pts = For( 1, 10000, Set ( Real k ) { [[ Real Rand( 0, 1 ), Rand( 0, 1 ) ]] } ); 


// Domingo, 2009/11/01 22:06:35.00
Set pts = For( 1, 10000, Set ( Real k ) { [[ Real Rand( 0, 1 ), Rand( 0, 1 ) ]] } ); 


// Domingo, 2009/11/01 22:06:27.00
Set pts = For( 1, 10000, Set ( Real k ) { [[ Real Rand( 0, 1 ), Rand( 0, 1 ) ]] } ); 


// Domingo, 2009/11/01 22:05:58.00
Set pts = For( 1, 10000, Set ( Real k ) { [[ Real Rand( 0, 1 ), Real( 0, 1 ) ]] ); 


// Domingo, 2009/11/01 21:15:18.00
Class @2DPoint
{
  Real x;
  Real y
};

@2DPoint obj = [[ Real x = 0, Real y = 0 ]];


// Domingo, 2009/11/01 21:14:36.00
Class @2DPoint
{
  Real x;
  Real y
};

@2DPoint obj = [[ x = 0, y = 0 ]];


// Domingo, 2009/11/01 21:14:19.00
Class @2DPoint
{
  Real x;
  Real y
};

@2DPoint [[ x = 0, y = 0 ]];


// Domingo, 2009/11/01 21:13:53.00
Class @2DPoint
{
  Real x;
  Real y
};

@2DPoint [[ x = 0, y = 0 ]];


// Domingo, 2009/11/01 21:13:48.00
Class @2DPoint
{
  Real x;
  Real y;
};

@2DPoint [[ x = 0, y = 0 ]];


// Viernes, 2009/10/30 10:01:19.00
@MMS.Results resultsEstimate = matVeh.Estimate::Execute( ? );

// Viernes, 2009/10/30 10:00:59.00
@MMS.Estimation matVeh.Estimate =
@MMS.Estimation::New(
[[
  Text name = "matVeh.Estimation.Estimate",
  @MMS.Model model = MMS::GetModel("Mat.Veh","1.0"),
  @MMS.Strategy strategy = strategyEstimate
]]
);


// Viernes, 2009/10/30 09:54:19.00
@MMS.Estimation matVeh.Estimate =
@MMS.Estimation::New(
[[
  Text name = "matVeh.Estimation.Estimate",
  @MMS.Model model = MMS::GetModel("Mat.Veh","1.0"),
  @MMS.Strategy strategy = strategyEstimate
]]
);


// Jueves, 2009/10/29 11:26:25.00
Class @AA {
  Real _.r;

  Real Print( Real v ) { WriteLn( "AA" ); _.r };
  Static @AA New( Real r ) { @AA [[ Real _.r = r ]] }
};

Class @BB : @AA {
  Real Print( Real v ) {  WriteLn( "BB" ); _.r }
};

@AA aA = @AA::New( 1 );
@BB aB = @BB::New( 2 );

Real aA::Print(?);
Real aB::Print(?);


// Jueves, 2009/10/29 11:25:52.00
Class @AA {
  Real _.r;

  Real Print( Real v ) { WriteLn( "AA" ); _.r };
  Static @AA New( Real r ) { @AA [[ Real _.r = r ]] }
};

Class @BB : @AA {
  Real Print( Real v ) {  WriteLn( "BB" ); _.r }
};

@AA aA = @AA::New( 1 );
@BB aB = @AA::New( 2 );

Real aA::Print(?);
Real aB::Print(?);


// Jueves, 2009/10/29 11:24:56.00
Class @AA {
  Real _.r;

  Real Print( Real v ) { WriteLn( "AA" ) };
  Static @AA New( Real r ) { @AA [[ Real _.r = r ]] }
};

Class @BB : @AA {
  Real Print( Real v ) {  WriteLn( "BB" ) }
};

@AA aA = @AA::New( 1 );
@BB aB = @AA::New( 2 );

Real aA::Print(?);
Real aB::Print(?);


// Jueves, 2009/10/29 11:23:51.00
Class @AA {
  Real _.r;

  Real Print( Real v ) { WriteLn( "AA" ) };
  Static @AA New( Real r ) { @AA [[ Real _.r = r ]] }
};

Class @BB : @AA {
  Real Print( Real v ) {  WriteLn( "BB" ) }
};

@AA aA = @AA::New( 1 );
@BB aB = @AA::New( 2 );

Real aB::Print(?)


// Jueves, 2009/10/29 11:16:22.00


Class @JJ {
  Set CC = Copy( Empty );
  Real MM( Real ll ) { 1 }
  @KK HH( Real dd ) { CC[1] }
};


// Jueves, 2009/10/29 11:16:08.00
Class @KK;

Class @JJ {
  Set CC = Copy( Empty );
  Real MM( Real ll ) { 1 }
  @KK HH( Real dd ) { CC[1] }
};


// Jueves, 2009/10/29 11:15:58.00
Class @KK;

Class JJ {
  Set CC = Copy( Empty );
  Real MM( Real ll ) { 1 }
  @KK HH( Real dd ) { CC[1] }
};


// Jueves, 2009/10/29 11:15:39.00
Class KK;

Class JJ {
  Set CC = Copy( Empty );
  Real MM( Real ll ) { 1 }
  KK HH( Real dd ) { CC[1] }
};

// Miercoles, 2009/10/21 09:31:02.00
@MMS.Results resultsBSR = strategyBSR::Execute(0);

// Miercoles, 2009/10/21 09:19:34.00
@MMS.Results resultsBSR = strategyBSR::Execute(0);

// Miercoles, 2009/10/21 09:08:04.00
Real (SS[1])::Get.ARIMA.Size(?)

// Miercoles, 2009/10/21 09:07:19.00
Set SS = strategyBSR::_.modelShell::_.modelS::GetOutputShells(?);


// Miercoles, 2009/10/21 08:59:57.00
@MMS.Results resultsBSR = strategyBSR::Execute(0);

// Martes, 2009/10/20 18:05:07.00
Text GetUrlContents( "http://tcllib.sourceforge.net/doc/uri.html" );


// Martes, 2009/10/20 18:03:00.00
Text GetUrlContents( "http://tcllib.sourceforge.net/doc/uri.html" );

// Martes, 2009/10/20 18:02:15.00
Text GetUrlContents( "ftp://ftp.ncep.noaa.gov/pub/data/nccf/com/gfs/prod/gfs.2009102012/gfs.t12z.pgrb2bf00.idx" );


// Lunes, 2009/10/19 14:46:08.00
Matrix Rand( 10,2,0,1);


// Viernes, 2009/10/16 18:14:09.00
NameBlock Fun(Set s){
  NameBlock k = SetToNameBlock(s)
};

NameBlock KK = [[
  NameBlock Eco = Fun({[[Text cod = "Eco"]]});
  NameBlock Cli = Fun({[[Text cod = "Cli"]]});
  NameBlock kk = Fun({[[Text cod = "kk"]]})
]];


// Miercoles, 2009/10/14 12:49:26.00
Set shells = resultsBSR::_.results_adapter::_.modelShell::GetOutputShells(0)


// Miercoles, 2009/10/14 11:41:32.00
@MMS.Results resultsEstimate = strategyEstimate::Execute(0);

// Miercoles, 2009/10/14 11:17:36.00
@MMS.Results resultsBSR = strategyBSR::Execute(0);

// Miercoles, 2009/10/14 11:12:29.00
@MMS.Estimation matVeh.Estimate =
@MMS.Estimation::New(
[[
  Text name = "matVeh.Estimation.Estimate",
  @MMS.Model model = MMS::GetModel("Mat.Veh","1.0"),
  @MMS.Strategy strategy = strategyEstimate
]]
);

@MMS.Results resultsEstimate = matVeh.Estimate::Execute( ? );

// Miercoles, 2009/10/14 09:54:55.00
@MMS.Results resultsBSR = strategyBSR::Execute(0);

// Viernes, 2009/10/09 14:46:44.00
@MMS.Estimation matVeh.Estimate =
@MMS.Estimation::New(
[[
  Text name = "matVeh.Estimation.Estimate",
  @MMS.Model model = MMS::GetModel("Mat.Veh","1.0"),
  @MMS.Strategy strategy = strategyEstimate
]]
);

@MMS.Results resultsEstimate = matVeh.Estimate::Execute( ? );

// Jueves, 2009/10/08 21:05:01.00
@MMS.Estimation matVeh.Estimate =
@MMS.Estimation::New(
[[
  Text name = "matVeh.Estimation.Estimate",
  @MMS.Model model = MMS::GetModel("Mat.Veh","1.0"),
  @MMS.Strategy strategy = strategyEstimate
]]
);

@MMS.Results resultsEstimate = matVeh.Estimate::Execute( ? );

// Jueves, 2009/10/08 11:17:13.00
Real MMS::CreateModel([[Text _.type ="ARIMAX";
                        Text _.name ="modA";
                        Text _.version ="1"]]);
Real MMS::CreateModel([[Text _.type ="GeneralizedLinear";
                        Text _.name ="modG";
                        Text _.version ="1"]]);
Set s = MMS::GetModels( 0 );
Text mustbeARIMAX = ClassOf(s[1]);
Text mustbeGeneralizedLinear = ClassOf(s[2]);


// Jueves, 2009/10/08 09:46:22.00
@MMS.Estimation matVeh.Estimate =
@MMS.Estimation::New(
[[
  Text name = "matVeh.Estimation.Estimate",
  @MMS.Model model = MMS::GetModel("Mat.Veh","1.0"),
  @MMS.Strategy strategy = strategyEstimate
]]
);

@MMS.Results resultsEstimate = matVeh.Estimate::Execute( ? );



// Jueves, 2009/10/08 09:43:47.00
@MMS.Results resultsEstimate = matVeh.Estimate::Execute( ? );

// Jueves, 2009/10/08 09:38:36.00
@MMS.Estimation matVeh.Estimate =
@MMS.Estimation::New(
[[
  Text name = "matVeh.Estimation.Estimate",
  @MMS.Model model = MMS::GetModel("Mat.Veh","1.0"),
  @MMS.StrategyBSR strategy = strategyBSR
]]
);

// Jueves, 2009/10/08 09:36:11.00
@MMS.Estimation matVeh.Estimate =
@MMS.Estimation::New(
[[
  Text name = "matVeh.Estimation.Estimate",
  @MMS.Model model = MMS::GetModel("Mat.Veh","1.0"),
  @MMS.StrategyBSR strategy = strategyBSR
]]
);


// Jueves, 2009/10/08 09:32:36.00
@MMS.Estimation matVeh.Estimate =
@MMS.Estimation::New(
[[
  Text name = "matVeh.Estimation.Estimate",
  @MMS.Model model = MMS::GetModel("Mat.Veh","1.0"),
  @MMS.StrategyBSR strategy = strategyBSR
]]
);

// Jueves, 2009/10/08 09:29:32.00
@MMS.Estimation matVeh.Estimate =
@MMS.Estimation::New(
[[
  Text name = "matVeh.Estimation.Estimate",
  @MMS.Model model = MMS::GetModel("Mat.Veh","1.0"),
  @MMS.StrategyBSR strategy = strategyBSR
]]
);

// Jueves, 2009/10/08 09:25:51.00
@MMS.Estimation matVeh.Estimate0;


// Jueves, 2009/10/08 09:23:06.00
@MMS.Estimation matVeh.Estimate =
@MMS.Estimation::New(
[[
  Text name = "matVeh.Estimation.Estimate",
  @MMS.Model model = MMS::GetModel("Mat.Veh","1.0"),
  @MMS.StrategyBSR strategy = strategyBSR
]]
);


// Jueves, 2009/10/08 09:19:18.00
@MMS.Estimation matVeh.Estimate =
@MMS.Estimation::New(
[[
  Text name = "matVeh.Estimation.Estimate",
  @MMS.Model model = MMS::GetModel("Mat.Veh","1.0"),
  @MMS.StrategyBSR strategy = strategyBSR
]]
);

// Jueves, 2009/10/08 09:15:01.00
@MMS.Estimation matVeh.Estimate =
@MMS.Estimation::New(
[[
  Text name = "matVeh.Estimation.Estimate",
  @MMS.Model model = MMS::GetModel("Mat.Veh","1.0"),
  @MMS.StrategyBSR strategy = strategyBSR
]]
);

// Miercoles, 2009/10/07 21:56:09.00
Class @CEjemplo {
	  Code AtributoTipoCode
	};
	
	@CEjemplo ej = [[
	  Code AtributoTipoCode = ( Real(Real x) { x } )
	]];


// Miercoles, 2009/10/07 21:56:00.00
Class CEjemplo {
	  Code AtributoTipoCode
	};
	
	CEjemplo ej = [[
	  Code AtributoTipoCode = ( Real(Real x) { x } )
	]];


// Miercoles, 2009/10/07 14:23:16.00
@MMS.Results resultsEstimate = strategyEstimate::Execute(0);

// Miercoles, 2009/10/07 13:07:01.00
@MMS.Results resultsBSR = strategyBSR::Execute(0);

// Miercoles, 2009/10/07 12:44:48.00
@MMS.Results resultsBSR = strategyBSR::Execute(0);

// Miercoles, 2009/10/07 11:42:03.00
@MMS.Results resultsBSR = strategyBSR::Execute(0);

// Miercoles, 2009/10/07 11:41:21.00
@MMS.Results resultsEstimate = strategyEstimate::Execute(0);

// Martes, 2009/10/06 10:20:38.00
Set s = SetOfText("este esta bien", "pero este \"falla\"");

Text t = TclEvalT("TolObj2TclObjNamed { Set s }");


// Martes, 2009/10/06 10:19:09.00
Set s = SetOfText("este esta bien", "pero este \"falla\"");


// Sabado, 2009/10/03 22:58:35.00
Class CEjemplo {
	  Code AtributoTipoCode
	};
	
	CEjemplo ej = [[
	  Code AtributoTipoCode = ( Real(Real x) { x } )
	]];




// Sabado, 2009/10/03 22:54:42.00
Set GetGlobalFunctions( "Real" );


// Sabado, 2009/10/03 22:53:36.00
Set GetGlobalFunctions( "Real" );


// Viernes, 2009/10/02 15:22:07.00
Class CEjemplo {
	  Code AtributoTipoCode
	};
	
	CEjemplo ej = [[
	  Code AtributoTipoCode = ( Real(Real x) { x } )
	]];


// Viernes, 2009/10/02 15:12:43.00
Serie {
Text OutputName = "Veh.Tur.Mat";
NameBlock _.original_results = resultsBSR::_.results_adapter::_.original_results;
    
    Set segments = _.original_results::eval.average;
    Real idx0 = FindIndexByName( segments, OutputName );
    Anything If( idx0, {
        Set segment = segments[ idx0 ];
        Real idx1 = FindIndexByName( segment, "serResiduals" );
        If( idx1, { Serie segment[ idx1 ] }, { Matrix segment[ "noise" ] } )
      }, {
        Error( "Output '" + OutputName +
               "' no encontrado entre los resultados de Estimate");
        Serie UnknownSerie
      } )
}



// Viernes, 2009/10/02 15:12:26.00
Serie {
Text OutputName = "Veh.Tur.Mat";
NameBlock _.original_results = resultsBSR::_.results_adapter::_.original_results;
    
    NameBlock segments = _.original_results::eval.average;
    Real idx0 = FindIndexByName( segments, OutputName );
    Anything If( idx0, {
        Set segment = segments[ idx0 ];
        Real idx1 = FindIndexByName( segment, "serResiduals" );
        If( idx1, { Serie segment[ idx1 ] }, { Matrix segment[ "noise" ] } )
      }, {
        Error( "Output '" + OutputName +
               "' no encontrado entre los resultados de Estimate");
        Serie UnknownSerie
      } )
}



// Viernes, 2009/10/02 15:09:04.00
Serie resultsBSR::GetResiduals( "Veh.Tur.Mat" );

// Viernes, 2009/10/02 15:03:44.00
MMS.Results resultsBSR = strategyBSR::Execute(0);

// Viernes, 2009/10/02 14:58:39.00
Set Include("/tmp/kk")


// Viernes, 2009/10/02 14:49:55.00
Class A {
  Real v = 1
};

A objA;

Real Ois.Store( [[ objA ]], "/tmp/objA.oza" );



// Viernes, 2009/10/02 14:46:28.00
Real Ois.Store( [[ resultsBSR]], "/tmp/jj" );


// Viernes, 2009/10/02 14:46:01.00
Set Include( "/tmpkk.oza" );


// Viernes, 2009/10/02 14:44:55.00
Real Ois.Store( [[ resultsBSR]], "/tmp/kk.oza" );


// Viernes, 2009/10/02 14:43:10.00
Serie resultsBSR::GetResiduals( "Veh.Tur.Mat" );


// Viernes, 2009/10/02 14:42:45.00
Serie resultBSR::GetResiduals( "Veh.Tur.Mat" );


// Viernes, 2009/10/02 14:42:02.00
MMS.Results resultsBSR = strategyBSR::Execute(0);

// Viernes, 2009/10/02 13:38:38.00
MMS.Results resultsBSR = strategyBSR::Execute(0);

// Miercoles, 2009/09/30 21:59:55.00
MMS.Results resultsBSR = strategyBSR::Execute(0);

// Miercoles, 2009/09/30 21:17:36.00
MMS.Results resultsBSR = strategyBSR::Execute(0);

// Miercoles, 2009/09/30 20:32:29.00
MMS.Results resultsBSR = strategyBSR::Execute(0);

// Miercoles, 2009/09/30 14:54:25.00
MMS.Results resultsBSR = strategyBSR::Execute(0);

// Miercoles, 2009/09/30 09:12:38.00
MMS.Results resultsBSR = strategyBSR::Execute(0);

// Miercoles, 2009/09/30 09:09:53.00
MMS.Results resultsEstimate = strategyEstimate::Execute(0);

// Miercoles, 2009/09/30 09:08:24.00
MMS.Results resultsEstimate = strategyEstimate::Execute(0);

// Miercoles, 2009/09/30 09:05:20.00
MMS.Results resultsEstimate = strategyEstimate::Execute(0);

// Miercoles, 2009/09/30 09:03:01.00
NameBlock eS = MMS.EstimationShell(strategyEstimate::GetModel(?),
                                   resultsEstimate::GetOriginalResults(?));

// Miercoles, 2009/09/30 09:02:07.00
MMS.Results resultsEstimate = strategyEstimate::Execute(0);

// Miercoles, 2009/09/30 08:56:05.00
MMS.Results resultsEstimate = strategyEstimate::Execute(0);

// Miercoles, 2009/09/30 08:32:56.00
Set resultsEstimate = strategyEstimate::Execute(0);

// Martes, 2009/09/29 21:41:01.00
Real KK( Real a ){ a };

Real FunctionExist( "Text", "KK" );


// Martes, 2009/09/29 21:40:47.00
Real KK( Real a ){ a };

Real FunctionExist( "Anything", "KK" );


// Martes, 2009/09/29 21:40:34.00
Real KK( Real a ){ a };

Real FunctionExists( "Anything", "KK" );


// Martes, 2009/09/29 07:41:33.00
NameBlock SplitInputDefAIA( Text InputDefExpr )
{
  // InputDef(Omega,X)
  // posicion de , separando Omega de X
  Real s0 = TextFind( InputDefExpr, "," );
  // Posicion del ultimo )
  Real s1 = TextFind( InputDefExpr, ")", TextLength( InputDefExpr ), -1 );
  // RationExpand(Date desde, TimeSet fechado, Ratio rat)
  Text input_expr = Sub( InputDefExpr, s0 + 1, s1 - 1 );
  Real s2 = TextFind( input_expr, "(" );
  Real s3 = TextFind( input_expr, "," );
  Text date_expr = Sub( input_expr, s2 + 1, s3 - 1 );
  Real ll = TextLength( input_expr );
  Real s4 = TextFind( input_expr, ",", ll, 1, -1 );
  Real s5 = TextFind( input_expr, ")", ll, 1, -1 );
  Text class_aia = Sub( input_expr, s4 + 1, s5 - 1 );
  NameBlock [[ input_expr, date_expr, class_aia, ll, s4, s5 ]]
};

Text txt = " RationExpand(y2007m08d06,Diario,StepOut)";
Real TextFind( txt, ",", 1, -1 );

Serie ser1 = Gaussian(0,1,Diario) + Step(y2007m7d31,Diario)*10;
Serie ser2 = SubSer(ser1,y2006,y2008);
Ratio p = 1/1;

Set aia = AIA( ser2, p, [[Ratio StepOut]]);

NameBlock SplitInputDefAIA( Identify( aia[ 1 ] ) );


// Martes, 2009/09/29 07:41:10.00
NameBlock SplitInputDefAIA( Text InputDefExpr )
{
  // InputDef(Omega,X)
  // posicion de , separando Omega de X
  Real s0 = TextFind( InputDefExpr, "," );
  // Posicion del ultimo )
  Real s1 = TextFind( InputDefExpr, ")", TextLength( InputDefExpr ), -1 );
  // RationExpand(Date desde, TimeSet fechado, Ratio rat)
  Text input_expr = Sub( InputDefExpr, s0 + 1, s1 - 1 );
  Real s2 = TextFind( input_expr, "(" );
  Real s3 = TextFind( input_expr, "," );
  Text date_expr = Sub( input_expr, s2 + 1, s3 - 1 );
  Real ll = TextLength( input_expr );
  Real s4 = TextFind( input_expr, ",", 1, 1, -1 );
  Real s5 = TextFind( input_expr, ")", 1, 1, -1 );
  Text class_aia = Sub( input_expr, s4 + 1, s5 - 1 );
  NameBlock [[ input_expr, date_expr, class_aia, ll, s4, s5 ]]
};

Text txt = " RationExpand(y2007m08d06,Diario,StepOut)";
Real TextFind( txt, ",", 1, -1 );

Serie ser1 = Gaussian(0,1,Diario) + Step(y2007m7d31,Diario)*10;
Serie ser2 = SubSer(ser1,y2006,y2008);
Ratio p = 1/1;

Set aia = AIA( ser2, p, [[Ratio StepOut]]);

NameBlock SplitInputDefAIA( Identify( aia[ 1 ] ) );


// Martes, 2009/09/29 07:37:37.00
NameBlock SplitInputDefAIA( Text InputDefExpr )
{
  // InputDef(Omega,X)
  // posicion de , separando Omega de X
  Real s0 = TextFind( InputDefExpr, "," );
  // Posicion del ultimo )
  Real s1 = TextFind( InputDefExpr, ")", TextLength( InputDefExpr ), -1 );
  // RationExpand(Date desde, TimeSet fechado, Ratio rat)
  Text input_expr = Sub( InputDefExpr, s0 + 1, s1 - 1 );
  Real s2 = TextFind( input_expr, "(" );
  Real s3 = TextFind( input_expr, "," );
  Text date_expr = Sub( input_expr, s2 + 1, s3 - 1 );
  Real ll = TextLength( input_expr );
  Real s4 = TextFind( input_expr, ",", 1, -1 );
  Real s5 = TextFind( input_expr, ")", 1, -1 );
  Text class_aia = Sub( input_expr, s4 + 1, s5 - 1 );
  NameBlock [[ input_expr, date_expr, class_aia, ll, s4, s5 ]]
};

Text txt = " RationExpand(y2007m08d06,Diario,StepOut)";
Real TextFind( txt, ",", 1, -1 );

Serie ser1 = Gaussian(0,1,Diario) + Step(y2007m7d31,Diario)*10;
Serie ser2 = SubSer(ser1,y2006,y2008);
Ratio p = 1/1;

Set aia = AIA( ser2, p, [[Ratio StepOut]]);

NameBlock SplitInputDefAIA( Identify( aia[ 1 ] ) );


// Martes, 2009/09/29 07:36:49.00
Text txt = " RationExpand(y2007m08d06,Diario,StepOut)";
Real TextFind( txt, ",", 1, -1 );


// Martes, 2009/09/29 07:33:25.00
NameBlock SplitInputDefAIA( Text InputDefExpr )
{
  // InputDef(Omega,X)
  // posicion de , separando Omega de X
  Real s0 = TextFind( InputDefExpr, "," );
  // Posicion del ultimo )
  Real s1 = TextFind( InputDefExpr, ")", TextLength( InputDefExpr ), -1 );
  // RationExpand(Date desde, TimeSet fechado, Ratio rat)
  Text input_expr = Sub( InputDefExpr, s0 + 1, s1 - 1 );
  Real s2 = TextFind( input_expr, "(" );
  Real s3 = TextFind( input_expr, "," );
  Text date_expr = Sub( input_expr, s2 + 1, s3 - 1 );
  Real ll = TextLength( input_expr );
  Real s4 = TextFind( input_expr, ",", ll, -1 );
  Real s5 = TextFind( input_expr, ")", ll, -1 );
  Text class_aia = Sub( input_expr, s4 + 1, s5 - 1 );
  NameBlock [[ input_expr, date_expr, class_aia, ll, s4, s5 ]]
};


Serie ser1 = Gaussian(0,1,Diario) + Step(y2007m7d31,Diario)*10;
Serie ser2 = SubSer(ser1,y2006,y2008);
Ratio p = 1/1;

Set aia = AIA( ser2, p, [[Ratio StepOut]]);

NameBlock SplitInputDefAIA( Identify( aia[ 1 ] ) );


// Martes, 2009/09/29 07:30:54.00
NameBlock SplitInputDefAIA( Text InputDefExpr )
{
  // InputDef(Omega,X)
  // posicion de , separando Omega de X
  Real s0 = TextFind( InputDefExpr, "," );
  // Posicion del ultimo )
  Real s1 = TextFind( InputDefExpr, ")", TextLength( InputDefExpr ), -1 );
  // RationExpand(Date desde, TimeSet fechado, Ratio rat)
  Text input_expr = Sub( InputDefExpr, s0 + 1, s1 - 1 );
  Real s2 = TextFind( input_expr, "(" );
  Real s3 = TextFind( input_expr, "," );
  Text date_expr = Sub( input_expr, s2 + 1, s3 - 1 );
  Real ll = TextLength( input_expr );
  Real s4 = TextFind( input_expr, ",", ll, -1 );
  Real s5 = TextFind( input_expr, ")", ll, -1 );
  Text class_aia = Sub( input_expr, s4 + 1, s5 - 1 );
  NameBlock [[ input_expr, date_expr, class_aia ]]
};


Serie ser1 = Gaussian(0,1,Diario) + Step(y2007m7d31,Diario)*10;
Serie ser2 = SubSer(ser1,y2006,y2008);
Ratio p = 1/1;

Set aia = AIA( ser2, p, [[Ratio StepOut]]);

NameBlock SplitInputDefAIA( Identify( aia[ 1 ] ) );


// Martes, 2009/09/29 07:30:00.00
NameBlock SplitInputDefAIA( Text InputDefExpr )
{
  // InputDef(Omega,X)
  // posicion de , separando Omega de X
  Real s0 = TextFind( InputDefExpr, "," );
  // Posicion del ultimo )
  Real s1 = TextFind( InputDefExpr, ")", TextLength( InputDefExpr ), -1 );
  // RationExpand(Date desde, TimeSet fechado, Ratio rat)
  Text input_expr = Sub( InputDefExpr, s0 + 1, s1 - 1 );
  Real s2 = TextFind( input_expr, "(" );
  Real s3 = TextFind( input_expr, "," );
  Text date_expr = Sub( input_expr, s2 + 1, s3 - 1 );
  Real ll = TextLength( input_expr );
  Real s4 = TextFind( input_expr, ",", ll, -1 );
  Real s5 = TextFind( input_expr, ")", ll, -1 );
  Text class_aia = Sub( input_expr, s4 + 1, s5 - 1 );
  NameBlock [[ input_expr, date_expr, class_aia ]]
};


Serie ser1 = Gaussian(0,1,Diario) + Step(y2007m7d31,Diario)*10;
Serie ser2 = SubSer(ser1,y2006,y2008);
Ratio p = 1/1;

Set aia = AIA( ser2, p, [[Ratio StepOut]]);

NameBlock SplitInputDefAIA( Indentify( aia[ 1 ] ) );


// Martes, 2009/09/29 07:07:33.00
Serie ser1 = Gaussian(0,1,Diario) + Step(y2007m7d31,Diario)*10;
Serie ser2 = SubSer(ser1,y2006,y2008);
Ratio p = 1/1;

Set aia = AIA( ser2, p, [[Ratio StepOut]]);


// Lunes, 2009/09/28 23:34:49.00
Text Description( aia[ 1 ] );

// Lunes, 2009/09/28 23:34:19.00
Text Identify( aia[ 1 ] );

// Lunes, 2009/09/28 23:34:08.00
Serie ser1 = Gaussian(0,1,Diario) + Step(y2007m7d31,Diario)*10;
Serie ser2 = SubSer(ser1,y2006,y2008);
Ratio p = 1/1;

Set aia = AIA( ser2, p, [[Ratio StepOut]]);

Text Name( aia[ 1 ] );


// Lunes, 2009/09/28 23:24:19.00
Serie ser1 = Gaussian(0,1,Diario) + Step(y2007m7d31,Diario)*10;
Serie ser2 = SubSer(ser1,y2006,y2008);
Ratio p = 1/1;

Set AIA( ser2, p, [[Ratio StepOut]]);


// Lunes, 2009/09/28 23:23:34.00
Serie ser1 = Gaussian(0,1,Diario) + Step(y2007m7d31,Diario)*10;
Serie ser2 = SubSer(ser1,y2006,y2008);
Ratio p = 1/1;

Set AIA( ser2, p, [[Ratio Step]]);


// Lunes, 2009/09/28 23:23:22.00
Serie ser1 = Gaussian(0,1,Diario) + Step(y2007m7d31,Diario)*10;
Serie ser2 = SubSer(ser1,y2006,y2008);
Ratio p = 1/1;

Set AIA( ser2, p, [[Step]]);


// Lunes, 2009/09/28 23:19:10.00
Serie ser1 = Gaussian(0,1,Diario) + Pulse(y2007m7d31,Diario)*10;
Serie ser2 = SubSer(ser1,y2006,y2008);
Ratio p = 1/1;

Set AIA( ser2, p, [[PulseOut]]);


// Lunes, 2009/09/28 23:19:00.00
Serie ser1 = Gaussian(0,1,Diario) + Pulse(y2007m7d31,Diario)*10;
Serie ser2 = SubSer(ser1,y2006,y2008);
Ratio p = 1/1;

Set AIA( ser, p, [[PulseOut]]);


// Lunes, 2009/09/28 21:35:11.00
Serie ser1 = Gaussian(0,1,Diario) + Pulse(y2007m7d31,Diario)*10;


// Domingo, 2009/09/27 20:21:09.00
Class A {
Real a = 1
};

Class B : A {
  Real b;

  Real PrintB(Real void) {WriteLn(""<<b); Real 0} 
};

B ib = {[[Real b=2,Real a=1]]};
A ia = ib;

Real ia::PrintB(0);



// Domingo, 2009/09/27 20:20:53.00
Class A {
Real a = 1
};

Class B : A {
  Real b;

  Real PrintB(Real void) {WriteLn(""<<b); Real 0} 
};

B ib = {[[Real b=2,Real a=1]]};
A ia = ib;

Real ia::PrintB(0);



// Domingo, 2009/09/27 20:18:25.00
Class A {
Real a = 1
};

Class B : A {
  Real b;

  Real PrintB(Real void) {WriteLn(""<<b); Real 0} 
};

B ib = {[[Real b=2,Real a=1]]};
A ia = ib;

Real ia::PrintB(0);



// Domingo, 2009/09/27 20:17:47.00
Class A {
Real a = 1
};

Class B : A {
  Real b;

  Real PrintB(Real void) {WriteLn(""<<b)} 
};

B ib = {[[Real b=2,Real a=1]]};
A ia = ib;



// Domingo, 2009/09/27 20:17:37.00
Class A {
Real a = 1
};

Class B : A {
  Real b;

  Real PrintB(Real void) {WriteLn(""<<b)} 
};

B ib = {[[b=2,a=1]]};
A ia = ib;



// Domingo, 2009/09/27 20:16:23.00
Class A {
Real a = 1
};

Class B : A {
  Real b;

  Real PrintB(Real void) {WriteLn(""<<b)} 
};




// Sabado, 2009/09/26 16:14:34.00
Set resultsEstimate = strategyEstimate::Execute(0);


// Viernes, 2009/09/25 15:52:49.00
A a := b;

// Viernes, 2009/09/25 15:52:39.00
Class A {
Text name
};

A a = { [[ Text name = "YO" ]] };
A b = { [[ Text name = "TU" ]] };

// A a := b;


// Viernes, 2009/09/25 15:52:34.00
Class A {
Text name;
};

A a = { [[ Text name = "YO" ]] };
A b = { [[ Text name = "TU" ]] };

// A a := b;


// Martes, 2009/09/22 00:34:48.00
Set __layer_var_gui_tmp__ = LayerVariableGUI::GetVariables( 0 )


// Martes, 2009/09/22 00:28:29.00
Set __layer_var_gui_tmp__ = LayerVariableGUI::GetVariables( 0 )


// Lunes, 2009/09/21 19:52:49.00
Set LayerVariableGUI::GetVariables( 0 );


// Lunes, 2009/09/21 19:51:57.00
Set LayerVariableGUI::GetVariables( 0 );


// Lunes, 2009/09/21 19:49:59.00
Set LayerVariableGUI::GetVariables( 0 );


// Lunes, 2009/09/21 13:30:48.00
/* see http://en.wikipedia.org/wiki/Triangular_distribution */
Matrix MatRandomTriangular( Real a, Real b, Real c, Real rows, Real columns )
{
  Matrix A = Rand( rows, columns, a, a );
  Matrix B = Rand( rows, columns, b, b );
  Matrix C = Rand( rows, columns, c, c );

  Matrix FC = ( C - A ) $/ ( B - A );

  Matrix U = Rand( rows, columns, 0, 1 );
  Matrix X0 = A + SqRt( U $* ( B - A ) $* ( C - A ) );
  Matrix X1 = B - SqRt( ( -U + 1 ) $* ( B - A ) $* ( B - C ) );

  Matrix IfMat( LT( U, FC ), X0, X1 )
};

Set SerRandomTriangular( Real a, Real b, Real c, TimeSet D, Date first, Date last, Real n )
{
  Real columns = DateDif( D, first, last ) + 1;
  Matrix sample = MatRandomTriangular( a, b, c, n, columns );
  Set MatSerSet( sample, D, first )
};

Set BuildParamNames( TimeSet D, Date first, Date last )
{
  Set EvalSet( Dates( D, first, last ), Text( Date f ) {
    FormatDate( f, "y%Y_%N" )
  } )
};


NameBlock ComputeSummary( Set mcmc, Set names )
{
  Matrix mat_mcmc = SerSetMat( mcmc );

  Set summary = StdLib::RCODA::summary( mat_mcmc, Empty );
  NameBlock result = [[
    Set stats = Copy( Empty );
    Set quantiles = Copy( Empty )
  ]];

  Set For( 1, Rows( summary[ 1 ] ), Real( Real k ) {
      Set {
        Set aux = MatSet( SubRow( summary[ 1 ], [[ k ]] ) )[ 1 ];
        Real PutName( "mean", aux[ 1 ] );
        Real PutName( "stddev", aux[ 2 ] );
        Real PutName( "SE", aux[ 3 ] );
        Real PutName( "TSSE", aux[ 4 ] );
        Set PutName( names[ k ], aux );
        Set Append( result::stats, [[ aux ]] )
      };
      Set {
        Set aux = MatSet( SubRow( summary[ 2 ], [[ k ]] ) )[ 1 ];
        Real PutName( "q_0_025", aux[ 1 ] );
        Real PutName( "q_0_25", aux[ 2 ] );
        Real PutName( "q_0_5", aux[ 3 ] );
        Real PutName( "q_0_75", aux[ 4 ] );
        Real PutName( "q_0_975", aux[ 5 ] );
        Set PutName( names[ k ], aux );
        Set Append( result::quantiles, [[ aux ]] )
      };
      Real 0
    } );
  NameBlock result
};

Set mcmc = SerRandomTriangular( 1.5, 3, 2, Mensual, y2009, y2009m12, 1000 );

Matrix mat_mcmc = SerSetMat( mcmc );

/* Invoca CODA de R, para cada mes calcula estadisticos*/
Set StdLib::RCODA::summary( mat_mcmc, Empty );

// Set MatSet( Tra( SetCol([[1,2,3,4]]) ) )

Set param_names = BuildParamNames( Mensual, y2009, y2009m12 );

NameBlock ComputeSummary( mcmc, param_names ); 


// Lunes, 2009/09/21 11:53:01.00
NameBlock Projecto = [[
   Class Concepto {
     Real name;
     Real GetName(Real void) { name }
   }
 ]];

 NameBlock Projecto2 = [[
   Text Concepto = "Nombre"
 ]];


// Viernes, 2009/09/18 11:01:03.00
/* see http://en.wikipedia.org/wiki/Triangular_distribution */
Matrix MatRandomTriangular( Real a, Real b, Real c, Real rows, Real columns )
{
  Matrix A = Rand( rows, columns, a, a );
  Matrix B = Rand( rows, columns, b, b );
  Matrix C = Rand( rows, columns, c, c );
  
  Matrix FC = ( C - A ) $/ ( B - A );

  Matrix U = Rand( rows, columns, 0, 1 );
  Matrix X0 = A + SqRt( U $* ( B - A ) $* ( C - A ) );
  Matrix X1 = B - SqRt( ( -U + 1 ) $* ( B - A ) $* ( B - C ) );

  Matrix IfMat( LT( U, FC ), X0, X1 )
};
 
Set SerRandomTriangular( Real a, Real b, Real c, TimeSet D, Date first, Date last, Real n )
{
  Real columns = DateDif( D, first, last ) + 1;
  Matrix sample = MatRandomTriangular( a, b, c, n, columns );
  Set MatSerSet( sample, D, first )
};

Set BuildParamNames( TimeSet D, Date first, Date last )
{
  Set EvalSet( Dates( D, first, last ), Text( Date f ) {
    FormatDate( f, "y%Y_%N" )
  } )
};


NameBlock ComputeSummary( Set mcmc, Set names )
{
  Matrix mat_mcmc = SerSetMat( mcmc );

  Set summary = StdLib::RCODA::summary( mat_mcmc, Empty );
  NameBlock result = [[
    Set stats = Copy( Empty );
    Set quantiles = Copy( Empty )
  ]];

  Set For( 1, Rows( summary[ 1 ] ), Real( Real k ) {
      Set {
        Set aux = MatSet( SubRow( summary[ 1 ], [[ k ]] ) )[ 1 ];
        Real PutName( "mean", aux[ 1 ] );
        Real PutName( "stddev", aux[ 2 ] );
        Real PutName( "SE", aux[ 3 ] ); 
        Real PutName( "TSSE", aux[ 4 ] ); 
        Set PutName( names[ k ], aux );
        Set Append( result::stats, [[ aux ]] )
      };
      Set {
        Set aux = MatSet( SubRow( summary[ 2 ], [[ k ]] ) )[ 1 ];
        Real PutName( "q_0_025", aux[ 1 ] );
        Real PutName( "q_0_25", aux[ 2 ] );
        Real PutName( "q_0_5", aux[ 3 ] ); 
        Real PutName( "q_0_75", aux[ 4 ] ); 
        Real PutName( "q_0_975", aux[ 5 ] ); 
        Set PutName( names[ k ], aux );
        Set Append( result::quantiles, [[ aux ]] )
      };
      Real 0
    } );
  NameBlock result
};

Set mcmc = SerRandomTriangular( 1.5, 3, 2, Mensual, y2009, y2009m12, 1000 );

Matrix mat_mcmc = SerSetMat( mcmc );

/* Invoca CODA de R, para cada mes calcula estadisticos*/
Set StdLib::RCODA::summary( mat_mcmc, Empty );

// Set MatSet( Tra( SetCol([[1,2,3,4]]) ) )

Set param_names = BuildParamNames( Mensual, y2009, y2009m12 );

NameBlock ComputeSummary( mcmc, param_names );


// Viernes, 2009/09/18 11:00:32.00
/* see http://en.wikipedia.org/wiki/Triangular_distribution */
Matrix MatRandomTriangular( Real a, Real b, Real c, Real rows, Real columns )
{
  Matrix A = Rand( rows, columns, a, a );
  Matrix B = Rand( rows, columns, b, b );
  Matrix C = Rand( rows, columns, c, c );
  
  Matrix FC = ( C - A ) $/ ( B - A );

  Matrix U = Rand( rows, columns, 0, 1 );
  Matrix X0 = A + SqRt( U $* ( B - A ) $* ( C - A ) );
  Matrix X1 = B - SqRt( ( -U + 1 ) $* ( B - A ) $* ( B - C ) );

  Matrix IfMat( LT( U, FC ), X0, X1 )
};
 
Set SerRandomTriangular( Real a, Real b, Real c, TimeSet D, Date first, Date last, Real n )
{
  Real columns = DateDif( D, first, last ) + 1;
  Matrix sample = MatRandomTriangular( a, b, c, n, columns );
  Set MatSerSet( sample, D, first )
};

Set BuildParamNames( TimeSet D, Date first, Date last )
{
  Set EvalSet( Dates( D, first, last ), Text( Date f ) {
    FormatDate( f, "y%Y_%N" )
  } )
};


NameBlock ComputeSummary( Set mcmc, Set names )
{
  Matrix mat_mcmc = SerSetMat( mcmc );

  Set summary = StdLib::RCODA::summary( mat_mcmc, Empty );
  NameBlock result = [[
    Set stats = Copy( Empty );
    Set quantiles = Copy( Empty )
  ]];

  Set For( 1, Rows( summary[ 1 ] ), Real( Real k ) {
      Set {
        Set aux = MatSet( SubRow( summary[ 1 ], [[ k ]] ) )[ 1 ];
        Real PutName( "mean", aux[ 1 ] );
        Real PutName( "stddev", aux[ 2 ] );
        Real PutName( "SE", aux[ 3 ] ); 
        Real PutName( "TSSE", aux[ 4 ] ); 
        Set PutName( names[ k ], aux );
        Set Append( result::stats, aux )
      };
      Set {
        Set aux = MatSet( SubRow( summary[ 2 ], [[ k ]] ) )[ 1 ];
        Real PutName( "q_0_025", aux[ 1 ] );
        Real PutName( "q_0_25", aux[ 2 ] );
        Real PutName( "q_0_5", aux[ 3 ] ); 
        Real PutName( "q_0_75", aux[ 4 ] ); 
        Real PutName( "q_0_975", aux[ 5 ] ); 
        Set PutName( names[ k ], aux );
        Set Append( result::quantiles, aux )
      };
      Real 0
    } );
  NameBlock result
};

Set mcmc = SerRandomTriangular( 1.5, 3, 2, Mensual, y2009, y2009m12, 1000 );

Matrix mat_mcmc = SerSetMat( mcmc );

/* Invoca CODA de R, para cada mes calcula estadisticos*/
Set StdLib::RCODA::summary( mat_mcmc, Empty );

// Set MatSet( Tra( SetCol([[1,2,3,4]]) ) )

Set param_names = BuildParamNames( Mensual, y2009, y2009m12 );

NameBlock ComputeSummary( mcmc, param_names );


// Viernes, 2009/09/18 10:59:52.00
/* see http://en.wikipedia.org/wiki/Triangular_distribution */
Matrix MatRandomTriangular( Real a, Real b, Real c, Real rows, Real columns )
{
  Matrix A = Rand( rows, columns, a, a );
  Matrix B = Rand( rows, columns, b, b );
  Matrix C = Rand( rows, columns, c, c );
  
  Matrix FC = ( C - A ) $/ ( B - A );

  Matrix U = Rand( rows, columns, 0, 1 );
  Matrix X0 = A + SqRt( U $* ( B - A ) $* ( C - A ) );
  Matrix X1 = B - SqRt( ( -U + 1 ) $* ( B - A ) $* ( B - C ) );

  Matrix IfMat( LT( U, FC ), X0, X1 )
};
 
Set SerRandomTriangular( Real a, Real b, Real c, TimeSet D, Date first, Date last, Real n )
{
  Real columns = DateDif( D, first, last ) + 1;
  Matrix sample = MatRandomTriangular( a, b, c, n, columns );
  Set MatSerSet( sample, D, first )
};

Set BuildParamNames( TimeSet D, Date first, Date last )
{
  Set EvalSet( Dates( D, first, last ), Text( Date f ) {
    FormatDate( f, "y%Y_%N" )
  } )
};


NameBlock ComputeSummary( Set mcmc, Set names )
{
  Matrix mat_mcmc = SerSetMat( mcmc );

  Set summary = StdLib::RCODA::summary( mat_mcmc, Empty );
  NameBlock result = [[
    Set stats = Copy( Empty );
    Set quantiles = Copy( Empty )
  ]];

  Set For( 1, Rows( summary[ 1 ] ), Real( Real k ) {
      Set {
        Set aux = MatSet( SubRow( summary[ 1 ], [[ k ]] ) )[ 1 ];
        Real PutName( "mean", aux[ 1 ] );
        Real PutName( "stddev", aux[ 2 ] );
        Real PutName( "SE", aux[ 3 ] ); 
        Real PutName( "TSSE", aux[ 4 ] ); 
        Set PutName( names[ k ], aux );
        Set Append( result::stats, aux )
      };
      Set {
        Set aux = MatSet( SubRow( summary[ 2 ], [[ k ]] ) )[ 1 ];
        Real PutName( "q_0_025", aux[ 1 ] );
        Real PutName( "q_0_25", aux[ 2 ] );
        Real PutName( "q_0_5", aux[ 3 ] ); 
        Real PutName( "q_0_75", aux[ 4 ] ); 
        Real PutName( "q_0_975", aux[ 5 ] ); 
        Set PutName( names[ k ], aux );
        Set Append( result::quantiles, aux )
      }
    } );
  NameBlock result
};

Set mcmc = SerRandomTriangular( 1.5, 3, 2, Mensual, y2009, y2009m12, 1000 );

Matrix mat_mcmc = SerSetMat( mcmc );

/* Invoca CODA de R, para cada mes calcula estadisticos*/
Set StdLib::RCODA::summary( mat_mcmc, Empty );

// Set MatSet( Tra( SetCol([[1,2,3,4]]) ) )

Set param_names = BuildParamNames( Mensual, y2009, y2009m12 );

NameBlock ComputeSummary( mcmc, param_names );


// Viernes, 2009/09/18 10:57:02.00
/* see http://en.wikipedia.org/wiki/Triangular_distribution */
Matrix MatRandomTriangular( Real a, Real b, Real c, Real rows, Real columns )
{
  Matrix A = Rand( rows, columns, a, a );
  Matrix B = Rand( rows, columns, b, b );
  Matrix C = Rand( rows, columns, c, c );
  
  Matrix FC = ( C - A ) $/ ( B - A );

  Matrix U = Rand( rows, columns, 0, 1 );
  Matrix X0 = A + SqRt( U $* ( B - A ) $* ( C - A ) );
  Matrix X1 = B - SqRt( ( -U + 1 ) $* ( B - A ) $* ( B - C ) );

  Matrix IfMat( LT( U, FC ), X0, X1 )
};
 
Set SerRandomTriangular( Real a, Real b, Real c, TimeSet D, Date first, Date last, Real n )
{
  Real columns = DateDif( D, first, last ) + 1;
  Matrix sample = MatRandomTriangular( a, b, c, n, columns );
  Set MatSerSet( sample, D, first )
};

Set BuildParamNames( TimeSet D, Date first, Date last )
{
  Set EvalSet( Dates( D, first, last ), Text( Date f ) {
    FormatDate( f, "y%Y_%N" )
  } )
};


NameBlock ComputeSummary( Set mcmc, Set names )
{
  Matrix mat_mcmc = SerSetMat( mcmc );

  Set summary = StdLib::RCODA::summary( mat_mcmc, Empty );
  NameBlock result = [[
    Set stats = Copy( Empty );
    Set quantiles = Copy( Empty )
  ]];

  Set For( 1, Rows( summary[ 1 ] ), Real( Real k ) {
      Set {
        Set aux = MatSet( SubRow( summary[ 1 ], [[ k ]] ) )[ 1 ];
        Real PutName( "mean", aux[ 1 ] );
        Real PutName( "stddev", aux[ 2 ] );
        Real PutName( "SE", aux[ 3 ] ); 
        Real PutName( "TSSE", aux[ 4 ] ); 
        Set PutName( names[ k ], aux );
        Set Append( result::stats, aux )
      };
      Set {
        Set aux = MatSet( SubRow( summary[ 2 ], [[ k ]] ) )[ 1 ];
        Real PutName( "q_0_025", aux[ 1 ] );
        Real PutName( "q_0_25", aux[ 2 ] );
        Real PutName( "q_0_5", aux[ 3 ] ); 
        Real PutName( "q_0_75", aux[ 4 ] ); 
        Real PutName( "q_0_975", aux[ 5 ] ); 
        Set PutName( names[ k ], aux );
        Set Append( result::quantiles, aux )
      }
    } );
  NameBlock result
};

Set mcmc = SerRandomTriangular( 1.5, 3, 2, Mensual, y2009, y2009m12, 1000 );

Matrix mat_mcmc = SerSetMat( mcmc );

/* Invoca CODA de R, para cada mes calcula estadisticos*/
Set StdLib::RCODA::summary( mat_mcmc, Empty );

// Set MatSet( Tra( SetCol([[1,2,3,4]]) ) )

Set param_names = BuildParamNames( Mensual, y2009, y2009m12 );

NameBlock ComputeSummary( mcmc, param_names );


// Viernes, 2009/09/18 10:56:04.00
/* see http://en.wikipedia.org/wiki/Triangular_distribution */
Matrix MatRandomTriangular( Real a, Real b, Real c, Real rows, Real columns )
{
  Matrix A = Rand( rows, columns, a, a );
  Matrix B = Rand( rows, columns, b, b );
  Matrix C = Rand( rows, columns, c, c );
  
  Matrix FC = ( C - A ) $/ ( B - A );

  Matrix U = Rand( rows, columns, 0, 1 );
  Matrix X0 = A + SqRt( U $* ( B - A ) $* ( C - A ) );
  Matrix X1 = B - SqRt( ( -U + 1 ) $* ( B - A ) $* ( B - C ) );

  Matrix IfMat( LT( U, FC ), X0, X1 )
};
 
Set SerRandomTriangular( Real a, Real b, Real c, TimeSet D, Date first, Date last, Real n )
{
  Real columns = DateDif( D, first, last ) + 1;
  Matrix sample = MatRandomTriangular( a, b, c, n, columns );
  Set MatSerSet( sample, D, first )
};

Set BuildParamNames( TimeSet D, Date first, Date last )
{
  Set EvalSet( Dates( D, first, last ), Text( Date f ) {
    FormatDate( f, "y%Y_%N" )
  } )
};


NameBlock ComputeSummary( Set mcmc, Set names )
{
  Matrix mat_mcmc = SerSetMat( mcmc );

  Set summary = StdLib::RCODA::summary( mat_mcmc, Empty );
  NameBlock result = [[
    Set stats = Copy( Empty );
    Set quantiles = Copy( Empty )
  ]];

  Set For( 1, Rows( summary[ 1 ] ), Real( Real k ) {
      Set {
        Set aux = MatSet( SubRow( summary[ 1 ], [[ k ]] ) )[ 1 ];
        Real PutName( "mean", aux[ 1 ] );
        Real PutName( "stddev", aux[ 2 ] );
        Real PutName( "SE", aux[ 3 ] ); 
        Real PutName( "TSSE", aux[ 4 ] ); 
        Set PutName( names[ k ], aux );
        Set Append( result::stats, aux )
      };
      Set {
        Set aux = MatSet( SubRow( summary[ 2 ], [[ k ]] ) )[ 1 ];
        Real PutName( "q_0_025", aux[ 1 ] );
        Real PutName( "q_0_25", aux[ 2 ] );
        Real PutName( "q_0_5", aux[ 3 ] ); 
        Real PutName( "q_0_75", aux[ 4 ] ); 
        Real PutName( "q_0_975", aux[ 5 ] ); 
        Set PutName( names[ k ], aux );
        Set Append( result::quantiles, aux )
      }
    } );
  NameBlock result
};

Set mcmc = SerRandomTriangular( 1.5, 3, 2, Mensual, y2009, y2009m12, 1000 );

Matrix mat_mcmc = SerSetMat( mcmc );

/* Invoca CODA de R, para cada mes calcula estadisticos*/
Set StdLib::RCODA::summary( mat_mcmc, Empty );

// Set MatSet( Tra( SetCol([[1,2,3,4]]) ) )

Set param_names = BuildParamNames( Mensual, y2009, y2009m12 )


// Viernes, 2009/09/18 10:29:55.00
Set MatSet( Tra( SetCol([[1,2,3,4]]) ) )

// Viernes, 2009/09/18 09:13:02.00
Set StdLib::RCODA::summary( mat_mcmc, Empty );

// Viernes, 2009/09/18 09:11:06.00
/* see http://en.wikipedia.org/wiki/Triangular_distribution */
Matrix MatRandomTriangular( Real a, Real b, Real c, Real rows, Real columns )
{
  Matrix A = Rand( rows, columns, a, a );
  Matrix B = Rand( rows, columns, b, b );
  Matrix C = Rand( rows, columns, c, c );
  
  Matrix FC = ( C - A ) $/ ( B - A );

  Matrix U = Rand( rows, columns, 0, 1 );
  Matrix X0 = A + SqRt( U $* ( B - A ) $* ( C - A ) );
  Matrix X1 = B - SqRt( ( -U + 1 ) $* ( B - A ) $* ( B - C ) );

  Matrix IfMat( LT( U, FC ), X0, X1 )
};
 
Set SerRandomTriangular( Real a, Real b, Real c, TimeSet D, Date first, Date last, Real n )
{
  Real columns = DateDif( D, first, last ) + 1;
  Matrix sample = MatRandomTriangular( a, b, c, n, columns );
  Set MatSerSet( sample, D, first )
};

Set mcmc = SerRandomTriangular( 1.5, 3, 2, Mensual, y2009, y2009m12, 1000 );

Matrix mat_mcmc = SerSetMat( mcmc );




// Viernes, 2009/09/18 09:10:49.00
/* see http://en.wikipedia.org/wiki/Triangular_distribution */
Matrix MatRandomTriangular( Real a, Real b, Real c, Real rows, Real columns )
{
  Matrix A = Rand( rows, columns, a, a );
  Matrix B = Rand( rows, columns, b, b );
  Matrix C = Rand( rows, columns, c, c );
  
  Matrix FC = ( C - A ) $/ ( B - A );

  Matrix U = Rand( rows, columns, 0, 1 );
  Matrix X0 = A + SqRt( U $* ( B - A ) $* ( C - A ) );
  Matrix X1 = B - SqRt( ( -U + 1 ) $* ( B - A ) $* ( B - C ) );

  Matrix IfMat( LT( U, FC ), X0, X1 )
};
 
Set SerRandomTriangular( Real a, Real b, Real c, TimeSet D, Date first, Date last, Real n )
{
  Real columns = DateDif( D, first, last ) + 1;
  Matrix sample = MatRandomTriangular( a, b, c, n, columns );
  Set MatSerSet( sample, D, first )
};

Set mcmc = SerRandomTriangular( 1.5, 3, 2, Mensual, y2009, y2009m12, 100 );

Matrix mat_mcmc = SerSetMat( mcmc );


// Viernes, 2009/09/18 09:10:27.00
Matrix mat_mcmc = SerSetMat( mcmc );

// Viernes, 2009/09/18 09:04:34.00
/* see http://en.wikipedia.org/wiki/Triangular_distribution */
Matrix MatRandomTriangular( Real a, Real b, Real c, Real rows, Real columns )
{
  Matrix A = Rand( rows, columns, a, a );
  Matrix B = Rand( rows, columns, b, b );
  Matrix C = Rand( rows, columns, c, c );
  
  Matrix FC = ( C - A ) $/ ( B - A );

  Matrix U = Rand( rows, columns, 0, 1 );
  Matrix X0 = A + SqRt( U $* ( B - A ) $* ( C - A ) );
  Matrix X1 = B - SqRt( ( -U + 1 ) $* ( B - A ) $* ( B - C ) );

  Matrix IfMat( LT( U, FC ), X0, X1 )
};
 
Set SerRandomTriangular( Real a, Real b, Real c, TimeSet D, Date first, Date last, Real n )
{
  Real columns = DateDif( D, first, last ) + 1;
  Matrix sample = MatRandomTriangular( a, b, c, n, columns );
  Set MatSerSet( sample, D, first )
};

Set SerRandomTriangular( 1.5, 3, 2, Mensual, y2009, y2009m12, 100 );


// Viernes, 2009/09/18 09:00:31.00
/* see http://en.wikipedia.org/wiki/Triangular_distribution */
Matrix MatRandomTriangular( Real a, Real b, Real c, Real rows, Real columns )
{
  Matrix A = Rand( rows, columns, a, a );
  Matrix B = Rand( rows, columns, b, b );
  Matrix C = Rand( rows, columns, c, c );
  
  Matrix FC = ( C - A ) $/ ( B - A );

  Matrix U = Rand( rows, columns, 0, 1 );
  Matrix X0 = A + SqRt( U $* ( B - A ) $* ( C - A ) );
  Matrix X1 = B - SqRt( ( -U + 1 ) $* ( B - A ) $* ( B - C ) );

  Matrix IfMat( LT( U, FC ), X0, X1 )
};
 
Set SerRandomTriangular( Real a, Real b, Real c, TimeSet D, Date first, Date last, Real n )
{
  Real columns = DateDif( D, first, last );
  Matrix sample = MatRandomTriangular( a, b, c, n, columns );
  Set MatSerSet( sample, D, first )
};

Set SerRandomTriangular( 1.5, 3, 2, Mensual, y2009, y2009m12, 100 );


// Viernes, 2009/09/18 09:00:02.00
/* see http://en.wikipedia.org/wiki/Triangular_distribution */
Matrix MatRandomTriangular( Real a, Real b, Real c, Real rows, Real columns )
{
  Matrix A = Rand( rows, column, a, a );
  Matrix B = Rand( rows, column, b, b );
  Matrix C = Rand( rows, column, c, c );
  
  Matrix FC = ( C - A ) $/ ( B - A );

  Matrix U = Rand( rows, column, 0, 1 );
  Matrix X0 = A + SqRt( U $* ( B - A ) $* ( C - A ) );
  Matrix X1 = B - SqRt( ( -U + 1 ) $* ( B - A ) $* ( B - C ) );

  Matrix IfMat( LT( U, FC ), X0, X1 )
};
 
Set SerRandomTriangular( Real a, Real b, Real c, TimeSet D, Date first, Date last, Real n )
{
  Real columns = DateDif( D, first, last );
  Matrix sample = MatRandomTriangular( a, b, c, n, columns );
  Set MatSerSet( sample, D, first )
};

Set SerRandomTriangular( 1.5, 3, 2, Mensual, y2009, y2009m12, 100 );


// Viernes, 2009/09/18 08:59:42.00
/* see http://en.wikipedia.org/wiki/Triangular_distribution */
Matrix MatRandomTriangular( Real a, Real b, Real c, Real rows, Real columns )
{
  Matrix A = Rand( rows, column, a, a );
  Matrix B = Rand( rows, column, b, b );
  Matrix C = Rand( rows, column, c, c );
  
  Matrix FC = ( C - A ) $/ ( B - A );

  Matrix U = Rand( rows, column, 0, 1 );
  Matrix X0 = A + SqRt( U $* ( B - A ) $* ( C - A ) );
  Matrix X1 = B - SqRt( ( -U + 1 ) $* ( B - A ) $* ( B - C ) );

  Matrix IfMat( LT( U, FC ), X0, X1 )
};
 
Set SerRandomTriangular( Real a, Real b, Real c, TimeSet D, Date first, Date last, Real n )
{
  Real columns = DateDif( D, first, last );
  Matrix sample = SerRandomTriangular( a, b, c, n, columns );
  Set MatSerSet( sample, D, first )
};

Set SerRandomTriangular( 1.5, 3, 2, Mensual, y2009, y2009m12, 100 );


// Viernes, 2009/09/18 08:59:24.00
/* see http://en.wikipedia.org/wiki/Triangular_distribution */
Matrix MatRandomTriangular( Real a, Real b, Real c, Real rows, Real columns )
{
  Matrix A = Rand( rows, column, a, a );
  Matrix B = Rand( rows, column, b, b );
  Matrix C = Rand( rows, column, c, c );
  
  Matrix FC = ( C - A ) $/ ( B - A );

  Matrix U = Rand( rows, column, 0, 1 );
  Matrix X0 = A + SqRt( U $* ( B - A ) $* ( C - A ) );
  Matrix X1 = B - SqRt( ( -U + 1 ) $* ( B - A ) $* ( B - C ) );

  Matrix IfMat( LT( U, FC ), X0, X1 )
};
 
Set SerRandomTriangular( Real a, Real b, Real c, TimeSet D, Date first, Date last, Real n )
{
  Real columns = DateDif( D, first, last );
  Matrix sample = SerRandomTriangular( a, b, c, n, columns );
  Set MatSerSet( sample, D, first )
};

Set RandomTriangular( 1.5, 3, 2, Mensual, y2009, y2009m12, 100 );


// Viernes, 2009/09/18 08:58:46.00
/* see http://en.wikipedia.org/wiki/Triangular_distribution */
Matrix RandomTriangular( Real a, Real b, Real c, Real rows, Real columns )
{
  Matrix A = Rand( rows, column, a, a );
  Matrix B = Rand( rows, column, b, b );
  Matrix C = Rand( rows, column, c, c );
  
  Matrix FC = ( C - A ) $/ ( B - A );

  Matrix U = Rand( rows, column, 0, 1 );
  Matrix X0 = A + SqRt( U $* ( B - A ) $* ( C - A ) );
  Matrix X1 = B - SqRt( ( -U + 1 ) $* ( B - A ) $* ( B - C ) );

  Matrix IfMat( LT( U, FC ), X0, X1 )
};
 
Set RandomTriangular( Real a, Real b, Real c, TimeSet D, Date first, Date last, Real n )
{
  Real columns = DateDif( D, first, last );
  Matrix sample = RandomTriangular( a, b, c, n, columns );
  Set MatSerSet( sample, D, first )
};

Set RandomTriangular( 1.5, 3, 2, Mensual, y2009, y2009m12, 100 );


// Miercoles, 2009/09/16 19:54:40.00
Set resultsEstimate = strategyEstimate::Execute(0);


// Miercoles, 2009/09/16 10:33:13.00
Set GetArimaFromLabel( "P1_7_364DIF0_1_0AR1_0_364MA0_7_0" );


// Viernes, 2009/09/11 23:08:47.00
Set resultsEstimate = strategyEstimate::Execute(0);


// Miercoles, 2009/09/09 09:16:51.00
Set resultsEstimate = strategyEstimate::Execute(0);


// Miercoles, 2009/09/09 09:16:34.00
Set resultsEstimate = strategyEstimate::Execute(0);


// Miercoles, 2009/09/09 09:16:27.00
Set resultsEstimate = strategyEstimate::Execute(0);


// Miercoles, 2009/09/09 09:16:03.00
Real strategyEstimate::SetModel( MMS::GetModel("Mat.Veh","1.0") );


// Miercoles, 2009/09/09 08:59:37.00
Set resultsEstimate = strategyEstimate::Execute(0);

// Miercoles, 2009/09/09 08:57:58.00
Matrix X = Rand(10,3, 0, 1);
Matrix Y = Rand(10,1, 0, 1);

Set LinReg( Y, X );

// Miercoles, 2009/09/09 08:57:41.00

Matrix X = Rand(10,3);
Matrix Y = Rand(10,1);

Set LinReg( Y, X );

// Miercoles, 2009/09/09 08:50:38.00
Set resultsEstimate = strategyEstimate::Execute(0);


// Miercoles, 2009/09/09 08:45:39.00
Set resultsEstimate = strategyEstimate::Execute(0);


// Viernes, 2009/08/21 19:54:03.00
Class ClsA 
{ 
  Text _.name; 
  Text PutName( Text name ) { Text _.name := name } 
}; 

ClsA ClsA.New( Text name ) 
{ 
  ClsA aux = [[ Text _.name = name ]] 
}; 

Class ClsB 
{ 
  Real v = 0; 
  ClsA A; 
  Set cont = Copy( Empty ) 
}; 

ClsB ClsB.New( Real x, Text name ) 
{ 
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]] 
}; 

ClsB aB = ClsB.New( 1, "kk" ); 

Set Append( aB::cont, [[ ClsA.New( "aa" ) ]] ); 

ClsB aB1 = Copy( aB ); 
Text aB1::A::PutName( "jj" ); 
Text ((aB1::cont)[1])::PutName( "aa copia" ); 

WriteLn( "aB es de clase " << ClassOf( aB ) ); 
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) ); 
Text FF( ClsB B ) { B::A::_.name }; 

Text FF( aB ); 
Text FF( aB1 );


// Viernes, 2009/08/21 19:53:28.00
Class ClsA 
{ 
  Text _.name; 
  Text PutName( Text name ) { Text _.name := name } 
}; 

ClsA ClsA.New( Text name ) 
{ 
  ClsA aux = [[ Text _.name = name ]] 
}; 

Class ClsB 
{ 
  Real v = 0; 
  ClsA A; 
  Set cont = Copy( Empty ) 
}; 

ClsB ClsB.New( Real x, Text name ) 
{ 
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]] 
}; 

ClsB aB = ClsB.New( 1, "kk" ); 

Set Append( aB::cont, [[ ClsA.New( "aa" ) ]] ); 

ClsB aB1 = Copy( aB ); 
Text aB1::A::PutName( "jj" ); 
Text ((aB1::cont)[1])::PutName( "aa copia" ); 

WriteLn( "aB es de clase " << ClassOf( aB ) ); 
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) ); 



// Viernes, 2009/08/21 19:50:40.00
Class ClsA 
{ 
  Text _.name; 
  Text PutName( Text name ) { Text _.name := name } 
}; 

ClsA ClsA.New( Text name ) 
{ 
  ClsA aux = [[ Text _.name = name ]] 
}; 

Class ClsB 
{ 
  Real v = 0; 
  ClsA A; 
  Set cont = Copy( Empty ) 
}; 

ClsB ClsB.New( Real x, Text name ) 
{ 
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]] 
}; 

ClsB aB = ClsB.New( 1, "kk" ); 

Set Append( aB::cont, [[ ClsA.New( "aa" ) ]] ); 

ClsB aB1 = Copy( aB ); 
Text aB1::A::PutName( "jj" ); 
Text ((aB1::cont)[1])::PutName( "aa copia" ); 

WriteLn( "aB es de clase " << ClassOf( aB ) ); 
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) ); 




// Viernes, 2009/08/21 19:45:28.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

Class ClsB
{
  Real v = 0;
  ClsA A;
  Set cont = Copy( Empty )
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );

Set Append( aB::cont, [[ ClsA.New( "aa" ) ]] );

ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );
Text ((aB1::cont)[1])::PutName( "aa copia" );

WriteLn( "aB es de clase " << ClassOf( aB ) );
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) );


//Text FF( ClsB B ) { B::A::_.name };

Text FF( aB );
/*Text FF( aB1 );*/




// Viernes, 2009/08/21 19:45:00.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

Class ClsB
{
  Real v = 0;
  ClsA A;
  Set cont = Copy( Empty )
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );

Set Append( aB::cont, [[ ClsA.New( "aa" ) ]] );

ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );
Text ((aB1::cont)[1])::PutName( "aa copia" );

WriteLn( "aB es de clase " << ClassOf( aB ) );
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) );


Text FF( ClsB B ) { B::A::_.name };

Text FF( aB );
/*Text FF( aB1 );*/




// Viernes, 2009/08/21 19:39:01.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

Class ClsB
{
  Real v = 0;
  ClsA A;
  Set cont = Copy( Empty )
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );

Set Append( aB::cont, [[ ClsA.New( "aa" ) ]] );

ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );
Text ((aB1::cont)[1])::PutName( "aa copia" );

WriteLn( "aB es de clase " << ClassOf( aB ) );
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) ); 


Text FF( ClsB B ) { Text B::A::_.name };

Text FF( aB );
Text FF( aB1 );


// Viernes, 2009/08/21 19:38:48.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

Class ClsB
{
  Real v = 0;
  ClsA A;
  Set cont = Copy( Empty )
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );

Set Append( aB::cont, [[ ClsA.New( "aa" ) ]] );

ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );
Text ((aB1::cont)[1])::PutName( "aa copia" );

WriteLn( "aB es de clase " << ClassOf( aB ) );
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) ); 


Text FF( ClsB B ) { Text B::A::_.name };

Text FF( aB );
/*Text FF( aB1 );*/


// Viernes, 2009/08/21 19:38:36.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

Class ClsB
{
  Real v = 0;
  ClsA A;
  Set cont = Copy( Empty )
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );

Set Append( aB::cont, [[ ClsA.New( "aa" ) ]] );

ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );
Text ((aB1::cont)[1])::PutName( "aa copia" );

WriteLn( "aB es de clase " << ClassOf( aB ) );
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) ); 


Text FF( ClsB B ) { Text B::A::_.name };

Text FF( aB );
*/Text FF( aB1 );*/


// Viernes, 2009/08/21 19:37:28.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

Class ClsB
{
  Real v = 0;
  ClsA A;
  Set cont = Copy( Empty )
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );

Set Append( aB::cont, [[ ClsA.New( "aa" ) ]] );

ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );
Text ((aB1::cont)[1])::PutName( "aa copia" );

WriteLn( "aB es de clase " << ClassOf( aB ) );
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) ); 

/*
Text FF( ClsB B ) { B::A::_.name };

Text FF( aB );
Text FF( aB1 );*/


// Viernes, 2009/08/21 19:37:01.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

Class ClsB
{
  Real v = 0;
  ClsA A;
  Set cont = Copy( Empty )
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );

Set Append( aB::cont, [[ ClsA.New( "aa" ) ]] );

ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );
Text ((aB1::cont)[1])::PutName( "aa copia" );

WriteLn( "aB es de clase " << ClassOf( aB ) );
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) ); 

Text FF( ClsB B ) { B::A::_.name };

Text FF( aB );
Text FF( aB1 );


// Viernes, 2009/08/21 17:57:51.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

Class ClsB 
{
  Real v = 0;
  ClsA A;
  Set cont = Copy( Empty )
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );

Set Append( aB::cont, [[ ClsA.New( "aa" ) ]] );

ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );
Text ((aB1::cont)[1])::PutName( "aa copia" );

WriteLn( "aB es de clase " << ClassOf( aB ) );
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) );



// Viernes, 2009/08/21 17:56:43.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

Class ClsB 
{
  Real v = 0;
  ClsA A;
  Set cont = Copy( Empty )
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );

ClsA aux = ClsA.New( "aa" );
Set Append( aB::cont, [[ ClsA.New( "aa" ) ]] );

ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );

WriteLn( "aB es de clase " << ClassOf( aB ) );
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) );



// Viernes, 2009/08/21 17:56:29.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

Class ClsB 
{
  Real v = 0;
  ClsA A;
  Set cont = Copy( Empty )
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );

ClsA aux = ClsA.New( "aa" );
Set Append( aB::cont, [[ aux ]] );

ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );

WriteLn( "aB es de clase " << ClassOf( aB ) );
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) );



// Viernes, 2009/08/21 17:56:18.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

Class ClsB 
{
  Real v = 0;
  ClsA A;
  Set cont = Copy( Empty )
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );

ClsA aux = ClsA.new( "aa" );
Set Append( aB::cont, [[ aux ]] );

ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );

WriteLn( "aB es de clase " << ClassOf( aB ) );
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) );



// Viernes, 2009/08/21 17:55:34.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

Class ClsB 
{
  Real v = 0;
  ClsA A;
  Set cont = Copy( Empty )
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );

//Set Append( aB::cont, [[ {ClsA aux = ClsA.new( "aa" )} ]] );

ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );

WriteLn( "aB es de clase " << ClassOf( aB ) );
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) );



// Viernes, 2009/08/21 17:55:26.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

Class ClsB 
{
  Real v = 0;
  ClsA A;
  Set cont = Copy( Empty )
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );

//Set Append( aB::cont, [[ {ClsA aux = ClsA.new( "aa" )} ]] );

ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );

WriteLn( "aB es de clase " << ClassOf( aB ) );
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) );



// Viernes, 2009/08/21 17:55:07.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

Class ClsB 
{
  Real v = 0;
  ClsA A;
  Set cont = Copy( Empty )
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );
Set Append( aB::cont, [[ {ClsA aux = ClsA.new( "aa" )} ]] );

ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );

WriteLn( "aB es de clase " << ClassOf( aB ) );
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) );



// Viernes, 2009/08/21 17:54:19.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

Class ClsB 
{
  Real v = 0;
  ClsA A;
  Set cont = Copy( Empty )
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );
Set Append( aB::cont, [[ ClsA.new( "aa" ) ]] );

ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );

WriteLn( "aB es de clase " << ClassOf( aB ) );
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) );



// Viernes, 2009/08/21 12:13:21.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

Class ClsB 
{
  Real v = 0;
  ClsA A
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );

ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );

WriteLn( "aB es de clase " << ClassOf( aB ) );
WriteLn( "aB1 es copia de aB, debe ser de clase ClsB y es:" << ClassOf( aB1 ) );



// Viernes, 2009/08/21 12:10:49.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

Class ClsB 
{
  Real v = 0;
  ClsA A
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );

ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );

WriteLn( "Debe ser ClsB y es:" << ClassOf( aB1 ) );



// Viernes, 2009/08/21 12:09:57.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

ClsA aux = ClsA.New( "ll" );


Class ClsB 
{
  Real v = 0;
  ClsA A
};

/*
ClsB auxB = [[ Real v = 1, ClsA A = ClsA.New( "kk" ) ]];
ClsB aB1 = Copy( auxB );
Text aB1::A::PutName( "jj" );
*/


ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );

ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );



// Viernes, 2009/08/21 12:09:41.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

ClsA aux = ClsA.New( "ll" );


Class ClsB 
{
  Real v = 0;
  ClsA A
};

/*
ClsB auxB = [[ Real v = 1, ClsA A = ClsA.New( "kk" ) ]];
ClsB aB1 = Copy( auxB );
Text aB1::A::PutName( "jj" );
*/


ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );
/*
ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );
*/


// Viernes, 2009/08/21 12:08:35.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name := name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

ClsA aux = ClsA.New( "ll" );


Class ClsB 
{
  Real v = 0;
  ClsA A
};

ClsB auxB = [[ Real v = 1, ClsA A = ClsA.New( "kk" ) ]];
ClsB aB1 = Copy( auxB );
Text aB1::A::PutName( "jj" );

/*
ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );
ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );
*/


// Viernes, 2009/08/21 12:07:31.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name = name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

ClsA aux = ClsA.New( "ll" );


Class ClsB 
{
  Real v = 0;
  ClsA A
};

ClsB auxB = [[ Real v = 1, ClsA A = ClsA.New( "kk" ) ]];
ClsB aB1 = Copy( auxB );
Text aB1::A::PutName( "jj" );

/*
ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );
ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );
*/


// Viernes, 2009/08/21 12:06:50.00
Text aB1::A::PutName( "jj" );

// Viernes, 2009/08/21 12:06:31.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name = name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

ClsA aux = ClsA.New( "ll" );


Class ClsB 
{
  Real v = 0;
  ClsA A
};

ClsB auxB = [[ Real v = 1, ClsA A = ClsA.New( "kk" ) ]];
ClsB aB1 = Copy( auxB );

/*
ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );
ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );
*/


// Viernes, 2009/08/21 12:05:59.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name = name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

ClsA aux = ClsA.New( "ll" );


Class ClsB 
{
  Real v = 0;
  ClsA A
};

ClsB auxB = [[ Real v = 1, ClsA A = ClsA.New( "kk" ) ]];

/*
ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );
ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );
*/


// Viernes, 2009/08/21 12:04:11.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name = name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

ClsA aux = ClsA.New( "ll" );

Real Stop;

/*
Class ClsB 
{
  Real v = 0;
  ClsA A
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );
ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );
*/


// Viernes, 2009/08/21 12:03:22.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name = name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

ClsA aux = ClsA.New( "ll" );

Real Stop;


Class ClsB 
{
  Real v = 0;
  ClsA A
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );
ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );


// Viernes, 2009/08/21 12:02:03.00
Class ClsA
{
  Text _.name;
  Text PutName( Text name ) { Text _.name = name }
};

ClsA ClsA.New( Text name )
{
  ClsA aux = [[ Text _.name = name ]]
};

Class ClsB 
{
  Real v = 0;
  ClsA A
};

ClsB ClsB.New( Real x, Text name )
{
  ClsB aux = [[ Real v = x, ClsA A = ClsA.New( name ) ]]
};

ClsB aB = ClsB.New( 1, "kk" );
ClsB aB1 = Copy( aB );
Text aB1::A::PutName( "jj" );


// Miercoles, 2009/08/19 18:47:39.00
 Set S1 = [[1, 2, 3, 4, 5, 6]];
  Real RemoveObject( S1, 2 );
  Set S2 = {[[ Text a = "sss", Real b = 2, Text kk = "kkll" ]]};
  Real RemoveObject( S2, "a" )


// Miercoles, 2009/08/19 18:47:31.00
//////////////////////////////////////////////////////////////////////////////
Real RemoveObject( Set container, Anything index )
//////////////////////////////////////////////////////////////////////////////
{
  Text gra = Grammar( index );
  Real idx = Case(
    gra == "Real", index,
    gra == "Text", FindIndexByName( container, index ),
    1, {
      Warning( "RemoveObject: index invalido" << index );
      Real -1
    } 
  );
  Real If( idx == Real -1,
  {
    Warning( "RemoveObject: objeto no encontradao" );
    Real 0
  },
  {
    Real k = 1;
    Set aux = Select( container, Real( Anything item ) {
      Real test = (k != idx);
      k := k+1;
      test
    } );
    Set container := aux;
    Real 1
  } )
};
PutDescription(
"Remove an item from a Set. The item can be referenced by a Real index "
"indicating the position of the item or by a Text index indicating the "
"name of the item. The function return 1 if the item could be removed "
"successfully or 0 in case of fail",
 RemoveObject );

/*
  Set S1 = [[1, 2, 3, 4, 5, 6]];
  Real RemoveObject( S1, 2 );
  Set S2 = {[[ Text a = "sss", Real b = 2, Text kk = "kkll" ]]};
  Real RemoveObject( S2, "a" )
 */



// Miercoles, 2009/08/19 18:47:04.00
//////////////////////////////////////////////////////////////////////////////
Real RemoveObject( Set container, Anything index )
//////////////////////////////////////////////////////////////////////////////
{
  Text gra = Grammar( index );
  Real idx = Case(
    gra == "Real", index,
    gra == "Text", FindIndexByName( container, index ),
    1, {
      Warning( "RemoveObject: index invalido" << index );
      Real -1
    } 
  );
  Real If( idx == Real -1,
  {
    Warning( "RemoveObject: objeto no encontradao" );
    Real 0
  },
  {
    Real k = 1;
    Set aux = Select( container, Real( Anything item ) {
      Real test = (k != idx);
      k := k+1;
      test
    } );
    Set container := aux;
    Real 1
  } )
};
PutDescription(
"Remove an item from a Set. The item can be referenced by a Real index "
"indicating the position of the item or by a Text index indicating the "
"name of the item". The function return 1 if the item could be removed "
"successfully or 0 in case of fail",
 RemoveObject );

/*
  Set S1 = [[1, 2, 3, 4, 5, 6]];
  Real RemoveObject( S1, 2 );
  Set S2 = {[[ Text a = "sss", Real b = 2, Text kk = "kkll" ]]};
  Real RemoveObject( S2, "a" )
 */



// Miercoles, 2009/08/19 18:46:38.00
//////////////////////////////////////////////////////////////////////////////
Real RemoveObject( Set container, Anything index )
//////////////////////////////////////////////////////////////////////////////
{
  Text gra = Grammar( index );
  Real idx = Case(
    gra == "Real", index,
    gra == "Text", FindIndexByName( container, index ),
    1, {
      Warning( "RemoveObject: index invalido" << index );
      Real -1
    } 
  );
  Set If( idx == Real -1,
  {
    Warning( "RemoveObject: objeto no encontradao" );
    Real 0
  },
  {
    Real k = 1;
    Set aux = Select( container, Real( Anything item ) {
      Real test = (k != idx);
      k := k+1;
      test
    } );
    Set container := aux;
    Real 1
  } )
};
PutDescription(
"Remove an item from a Set. The item can be referenced by a Real index "
"indicating the position of the item or by a Text index indicating the "
"name of the item". The function return 1 if the item could be removed "
"successfully or 0 in case of fail",
 RemoveObject );

/*
  Set S1 = [[1, 2, 3, 4, 5, 6]];
  Real RemoveObject( S1, 2 );
  Set S2 = {[[ Text a = "sss", Real b = 2, Text kk = "kkll" ]]};
  Real RemoveObject( S2, "a" )
 */



// Miercoles, 2009/08/19 18:45:08.00
//////////////////////////////////////////////////////////////////////////////
Real RemoveObject( Set container, Anything index )
//////////////////////////////////////////////////////////////////////////////
{
  Text gra = Grammar( index );
  Real idx = Case(
    gra == "Real", index,
    gra == "Text", FindIndexByName( container, index ),
    1, {
      Warning( "RemoveObject: index invalido" << index );
      Real -1
    } 
  );
  Real If( idx == Real -1,
  {
    Warning( "RemoveObject: objeto no encontradao" );
    Real 0
  },
  {
    Real k = 1;
    Set aux = Select( container, Real( Anything item ) {
      Real test = (k != idx);
      k := k+1;
      test
    } );
    Set container := aux;
    Real 1
  } )
};
PutDescription(
"Remove an item from a Set. The item can be referenced by a Real index "
"indicating the position of the item or by a Text index indicating the "
"name of the item",
 RemoveObject );

Set S1 = [[1, 2, 3, 4, 5, 6]];
Real RemoveObject( S1, 2 );
Set S2 = {[[ Text a = "sss", Real b = 2, Text kk = "kkll" ]]};
Real RemoveObject( S2, "a" )



// Miercoles, 2009/08/19 18:41:22.00
//////////////////////////////////////////////////////////////////////////////
Real RemoveObject( Set container, Anything index )
//////////////////////////////////////////////////////////////////////////////
{
  Text gra = Grammar( index );
  Real idx = Case(
    gra == "Real", index,
    gra == "Text", FindIndexByName( container, index ),
    1, {
      Warning( "RemoveObject: index invalido" << index );
      Real -1
    } 
  );
  Real If( idx == Real -1,
  {
    Warning( "RemoveObject: objeto no encontradao" );
    Real 0
  },
  {
    Real k = 1;
    Set aux = Select( container, Real( Anything item ) {
      Real test = (k != idx);
      k := k+1;
      test
    } );
    Set container := aux;
    Real 1
  } )
};

Set S1 = [[1, 2, 3, 4, 5, 6]];
Real RemoveObject( S1, 2 );
Set S2 = {[[ Text a = "sss", Real b = 2, Text kk = "kkll" ]]};
Real RemoveObject( S2, "a" )



// Miercoles, 2009/08/19 18:40:36.00
//////////////////////////////////////////////////////////////////////////////
Real RemoveObject( Set container, Anything index )
//////////////////////////////////////////////////////////////////////////////
{
  Text gra = Grammar( index );
  Real idx = Case(
    gra == "Real", index,
    gra == "Text", FindIndexByName( container, index ),
    1, {
      Warning( "RemoveObject: index invalido" << index );
      Real -1
    } 
  );
  Real If( idx == Real -1,
  {
    Warning( "RemoveObject: objeto no encontradao" );
    Real 0
  },
  {
    Real k = 1;
    Set aux = Select( container, Real( Anything item ) {
      Real test = (k != idx);
      k := k+1;
      test
    } );
    Set container := aux;
    Real 1
  } )
};

Real RemoveObject( [[1, 2, 3, 4, 5, 6]], 2 );
Real RemoveObject( {[[ Text a = "sss", Real b = 2, Text kk = "kkll" ]]}, "a" )



// Miercoles, 2009/08/19 18:39:49.00
Real RemoveObject( [[1, 2, 3, 4, 5, 6]], 2 );
Real RemoveObject( {[[ Text a = "sss", Real b = 2, Text kk = "kkll" ]]}, "a" )



// Miercoles, 2009/08/19 18:39:18.00
//////////////////////////////////////////////////////////////////////////////
Real RemoveObject( Set container, Anything index )
//////////////////////////////////////////////////////////////////////////////
{
  Text gra = Grammar( index );
  Real idx = Case(
    gra == "Real", index,
    gra == "Text", FindIndexByName( container, index ),
    1, {
      Warning( "RemoveObject: index invalido" << index );
      Real -1
    } 
  );
  Set If( idx == Real -1,
  {
    Warning( "RemoveObject: objeto no encontradao" );
    Real 0
  },
  {
    Real k = 1;
    Set aux = Select( container, Real( Anything item ) {
      Real test = (k != idx);
      k := k+1;
      test
    } );
    Set container := aux;
    Real 1
  } )
};



// Jueves, 2009/08/06 00:51:24.00
NameBlock MMS;


// Jueves, 2009/08/06 00:51:14.00
NameBlock MMS::Repository;


// Jueves, 2009/08/06 00:41:53.00
MMS::Variable A;


// Miercoles, 2009/08/05 14:04:16.00
Set results = strategy::Execute(0);


// Lunes, 2009/08/03 08:29:19.00
Set results = strategy::Execute(0);


// Lunes, 2009/07/27 13:28:12.00
Set GetArimaFromLabel( "P1_12DIF0_1AR1.3_0MA0_12" );


// Lunes, 2009/07/27 13:27:08.00
Set GetArimaFronLabel( "P1_12DIF0_1AR1.3_0MA0_12" );


// Lunes, 2009/07/27 13:27:03.00
Set GetArimaFronLabel( ""P1_12DIF0_1AR1.3_0MA0_12" );


// Viernes, 2009/07/24 09:19:37.00
Class A { Real a = 1 };

A instA;

Text GetClassOf( instA );


// Viernes, 2009/07/24 08:31:12.00
Text GetClassOf( MMS )


// Viernes, 2009/07/24 07:45:13.00
NameBlock MMS;


// Jueves, 2009/07/23 18:58:20.00
NameBlock MMS


// Jueves, 2009/07/23 16:39:48.00
Set RemoveObject( Set container, Anything index )
{
  Text gra = Grammar( index );
  Real idx = If( gra == "Real",
                 index,
                 If( gra == "Text",
                 {
                   FindIndexByName( container, index )
                 },
                 {
                   Warning( "RemoveObject: index invalido" << index );
                   Real -1
                 } ) );
  Set If( idx == Real -1,
      {
        Warning( "RemoveObject: objeto no encontradao" );
        Set container
      },
      {
        Real k = 1;
        Select( container, Real( Anything item ) {
            Real test = (k != idx);
            k := k+1;
            test
        } )
      } )
};

Set RemoveObject( [[1, 2, 3, 4, 5, 6]], 2 );
Set RemoveObject( {[[ Text a = "sss", Real b = 2, Text kk = "kkll" ]]}, "a" )


// Jueves, 2009/07/23 16:38:57.00
Set RemoveObject( Set container, Anything index )
{
  Text gra = Grammar( index );
  Real idx = If( gra == "Real",
                 index,
                 If( gra == "Text",
                 {
                   FindIndexByName( container, index )
                 },
                 {
                   Warning( "RemoveObject: index invalido" << index );
                   Real -1
                 } ) );
  Set If( idx == Real -1,
      {
        Warning( "RemoveObject: objeto no encontradao" );
        Set container
      },
      {
        Real k = 1;
        Select( container, Real( Anything item ) {
            Real test = (k != idx);
            k := k+1;
            test
        } )
      } )
};

Set RemoveObject( [[1, 2, 3, 4, 5, 6]], 2 );


// Jueves, 2009/07/23 16:38:35.00
Set RemoveObject( Set container, Anything index )
{
  Text gra = Grammar( index );
  Real idx = If( gra == "Real",
                 index,
                 If( gra == "Text",
                 {
                   FindIndexByName( container, index )
                 },
                 {
                   Warning( "RemoveObject: index invalido" << index );
                   Real -1
                 } ) );
  Set If( idx == -1,
      {
        Warning( "RemoveObject: objeto no encontradao" );
        Set container
      },
      {
        Real k = 1;
        Select( container, Real( Anything item ) {
            Real test = (k != idx);
            k := k+1;
            test
        } )
      } )
};

Set RemoveObject( [[1, 2, 3, 4, 5, 6]], 2 );


// Jueves, 2009/07/23 16:38:07.00
Set RemoveObject( Set container, Anything index )
{
  Text gra = Grammar( index );
  Real idx = If( gra == "Real",
                 index,
                 If( gra == "Text",
                 {
                   FindIndexByName( container, index )
                 },
                 {
                   Warning( "RemoveObject: index invalido" << index );
                   Real -1
                 } ) );
  Set If( idx == -1,
      {
        Warning( "RemoveObject: objeto no encontradao" );
        Set container
      },
      {
        Real k = 1;
        Select( container, Real( Anything item ) {
            Real test = (k == idx);
            k := k+1;
            test
        } )
      } )
};

Set RemoveObject( [[1, 2, 3, 4, 5, 6]], 2 );


// Jueves, 2009/07/23 16:23:34.00
Text GetAddressFromObject( MaxIter );
Real MaxIter := 100;
Anything obj = MaxIter;
Text GetAddressFromObject( Eval( "Real MaxIter" ) );
Text GetAddressFromObject( MaxIter );
Text GetAddressFromObject( obj );



// Jueves, 2009/07/23 16:21:42.00
Text GetAddressFromObject( MaxIter );
Real MaxIter := 100;
Anything obj = MaxIter;
Text GetAddressFromObject( MaxIter );
Text GetAddressFromObject( obj );



// Jueves, 2009/07/23 16:19:41.00
Text GetAddressFromObject( MaxIter );
Real MaxIter := 100;
Text GetAddressFromObject( MaxIter );


// Jueves, 2009/07/23 14:44:39.00
Class VarSetting
{
  Text _.grammar;
  Text _.name;
  Anything _.value;
  Text _.description;
  Set _.info = Copy( Empty );

  Text GetGrammar( Real void ) { _.grammar };
  Text GetName( Real void ) { _.name };
  Anything GetValue( Real void ) { _.value };
  Anything SetValue( Anything value ) { _.value := value };
  

  ////////////////////////////////////////////////////////////////////////////    
  Real Activate( Real void )
  ////////////////////////////////////////////////////////////////////////////
  {
    Text op = If( ObjectExists( _.grammar, _.name ), ":=", "=" );
    Anything Eval( _.grammar + " " + _.name + op + "_.value" );
    Real 1
  };
  ////////////////////////////////////////////////////////////////////////////
  PutDescription(
  "Establece el valor dado en '_.value' para el objeto 'grammar name' en el "+
  "ámbito actual."+NL+
  "Vease: Restore, Save",Activate);
  ////////////////////////////////////////////////////////////////////////////
   

  ////////////////////////////////////////////////////////////////////////////
  Real Restore( Real void )
  ////////////////////////////////////////////////////////////////////////////
  {
    Real If( Card( _.info ),
    {
      Text addr = GetAddressFromObject( Eval( _.grammar + " " + _.name ) );
      Real If( addr == _.info::address,
      {
        Anything Eval( _.grammar + " " + _.name + ":=" + "_.info::value" );
        Real 1
      },
      {
        Warning( "El objeto '" + _.grammar + " " + _.name +
                 "' no tiene la misma 'address' que el objeto"
                 " almacenado" );
        Real 0
      })
    })
  };
  ////////////////////////////////////////////////////////////////////////////
  PutDescription(
    "Restablece el valor almacenado del objeto 'grammar name'" + NL +
    " " + NL +
    "Vease: Activate, Save",
    Restore );
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  Real Save( Real 0 )
  ////////////////////////////////////////////////////////////////////////////
  {
    Real If( ObjectExists( _.grammar, _.name ),
      {
        // obj es una referencia a "grammar name"
        Anything obj = Eval( _.grammar + " " + _.name );
        Text addr = GetAddressFromObject( obj );
        // tomo una copia del valor que es lo que se almacenara
        Anything value = Copy( obj );
        Set _.info := [[ addr, value ]];
        Real 0
      },
      {
        Warning( "No se ha encontrado el objeto '" +
                 _.grammar + " " + _.name + "'" );
        Set _.info = Copy( Empty );
        Real 0
      } )
   };
  ////////////////////////////////////////////////////////////////////////////
  PutDescription(
    "Almacena en _.info el valor del objeto 'grammar name' definido" + NL + 
    "para el ambito actual. Si el objeto no existe emite un mensaje" + NL + 
    "Warning. El valor se almacena en info de forma tal que pueda ser" + NL + 
    "restaurado con Restore." + NL +
    " " + NL + 
    "Vease: Activate, Restore."
   ,Save)
  ////////////////////////////////////////////////////////////////////////////
};



// Jueves, 2009/07/23 08:46:11.00
Text _build_name_index( [[ "Real", "Pi", "1.0", "34566" ]] );

// Jueves, 2009/07/23 08:45:39.00
Text _build_name_index( [[ "Real", "Pi", "1.0" ]] );

// Jueves, 2009/07/23 08:45:21.00
Text _build_name_index( [[ "Real", "Pi" ]] );

// Jueves, 2009/07/23 08:45:11.00
Text _build_name_index( [[ "Real", "Pi" ]];

// Jueves, 2009/07/23 08:44:45.00
  Text _build_name_index0( Set keys, Real f )
  {
    Real c = Card( keys );

    If( f > c, "",
      {
        Text f_item = keys[ f ];
        If( f == c, f_item, f_item + "__" + _build_name_index0( keys, f + 1 ) )
      } )
  };
  
  Text _build_name_index( Set keys )
  {
    Real c = Card( keys );
    Text If( c, _build_name_index0( keys, 1 ), "" )
  };



// Miercoles, 2009/07/22 11:11:40.00
Real kk = 1;
Text addr_kk = GetAddressFromObject( kk );
Text addr_eval = GetAddressFromObject( Eval( "Real kk" ) );
Anything oo = Eval( "Real kk" );
Text addr_oo = GetAddressFromObject( oo );

NameBlock [[ Real a = 1, Real b = 2 ]]


// Miercoles, 2009/07/22 11:11:29.00
Real kk = 1;
Text addr_kk = GetAddressFromObject( kk );
Text addr_eval = GetAddressFromObject( Eval( "Real kk" ) );
Anything oo = Eval( "Real kk" );
Text addr_oo = GetAddressFromObject( oo );

NameBlock [[ a = 1, b = 2 ]]


// Miercoles, 2009/07/22 11:03:36.00
Real kk = 1;
Text addr_kk = GetAddressFromObject( kk );
Text addr_eval = GetAddressFromObject( Eval( "Real kk" ) );
Anything oo = Eval( "Real kk" );
Text addr_oo = GetAddressFromObject( oo );


// Miercoles, 2009/07/22 11:03:21.00
Real kk = 1;
Text addr_kk = GetAddressfromObject( kk );
Text addr_eval = GetAddressfromObject( Eval( "Real kk" ) );
Anything oo = Eval( "Real kk" );
Text addr_oo = GetAddressfromObject( oo );


// Miercoles, 2009/07/22 11:00:01.00
Real kk = 1;

Anything oo = Copy( Eval( "Real kk" ) );


// Miercoles, 2009/07/22 10:59:11.00
Real kk = 1;

Anything Eval( "Real kk" )


// Miercoles, 2009/07/22 10:59:04.00
Reak kk = 1;

Anything Eval( "Real kk" )


// Miercoles, 2009/07/22 10:56:42.00
Text GetAddressFromObject( "Real", "kk" );


// Miercoles, 2009/07/22 10:56:33.00
Text GetAddressfromObject( "Real", "kk" );


// Miercoles, 2009/07/22 10:37:34.00
Anything a = Find("MaxIter")


// Miercoles, 2009/07/22 10:37:19.00
Anything Find("MaxIter")


// Martes, 2009/07/21 09:07:15.00
Class CA {
  Real a = 1
};

CA a;
CA b = a;
Real b::a := 2;



// Martes, 2009/07/21 09:05:37.00
Class CA {
  Real a = 1
};

CA a;
CA b = a;
Real b::a := 2;


// Martes, 2009/07/21 09:05:28.00
Class CA {
  Real a = 1
};

CA a;
CA b = a;
Real b::a = 2;


// Viernes, 2009/07/17 12:33:59.00
NameBlock a = [[

  Text _.valor = "Inicial";

  Text GetValor (Real void) {

    _.valor

  };

  Text SetValor (Text valor) {

    Text _.valor := valor

  }

]];

 

NameBlock b = Copy(a);

 

Text b::SetValor("cambiado");

 

Text WriteLn("El valor de b es "+b::GetValor(0));

Text WriteLn("El valor de a es "+a::GetValor(0));


// Viernes, 2009/07/17 12:06:50.00
NameBlock A = 
[[
  Real _.aReal = 1.0;
  Set _.aSet = [[ 3, 4 ]];

  Real SetReal( Real a ) { _.aReal = a };
  Set Append( Real a ) { Append( _.aSet, [[ a ]] ) }
]];

NameBlock B = 
[[
  NameBlock _.aRef = A
]];

NameBlock aCopy = DeepCopy( B );

// modificamos A
Real A::SetReal( 2.0 );
Set A::Append( 5.0 );


// Viernes, 2009/07/17 12:06:35.00
NameBlock A = 
[[
  Real _.aReal = 1.0;
  Set _.aSet = [[ 3, 4 ]];

  Real SetReal( Real a ) { _.aReal = a };
  Set Append( Real a ) { Append( _.aSet, [[ a ]] }
]];

NameBlock B = 
[[
  NameBlock _.aRef = A
]];

NameBlock aCopy = DeepCopy( B );

// modificamos A
Real A::SetReal( 2.0 );
Set A::Append( 5.0 );


// Lunes, 2009/07/13 15:11:03.00
Class A { Set _.cont = Copy( Empty ); Set cont = [[1]] };

A aA;

Set aA::cont;
Real Card( aA::_.cont );
Set aA::_.cont;


// Lunes, 2009/07/13 15:10:49.00
Class A { Set _.cont = Copy( Empty ); Set cont = [[1]] };

A aA;

Set aA::cont;
Real Card( aA::_.cont );


// Lunes, 2009/07/13 15:10:22.00
Class A { Set _.cont = Copy( Empty ); Set cont = [[1]] };

A aA;

Set aA::cont;


// Lunes, 2009/07/13 15:09:42.00
Class A { Set _.cont = Copy( Empty ) };

A aA;



// Viernes, 2009/07/10 17:04:06.00
Class A {
  Text _.name
};

Class Container {
  Set _.cont;

  Real Append( A objA ) {
    A aux = objA;
    A PutName( objA::_.name, aux );
    Set Append( _.cont, [[ aux ]] );
    Real SetIndexByName( _.cont )
  };

  A GetObj( Text name ) {
    A _.cont[ name ]
  }
};

Container C = [[ Set _.cont = Copy(Empty) ]];

A obj1 = [[ Text _.name = "obj1" ]];

Real C::Append( obj1 );



// Viernes, 2009/07/10 17:03:34.00
Class A {
  Text _.name
};

Class Container {
  Set _.cont = Copy(Empty);

  Real Append( A objA ) {
    A aux = objA;
    A PutName( objA::_.name, aux );
    Set Append( _.cont, [[ aux ]] );
    Real SetIndexbyName( _.cont )
  };

  A GetObj( Text name ) {
    A _.cont[ name ]
  }
};

Container C = [[ Set _.cont = Copy(Empty) ]];

A obj1 = [[ Text _.name = "obj1" ]];

Real C::Append( obj1 );



// Viernes, 2009/07/10 17:02:24.00
Class A {
  Text _.name
};

Class Container {
  Set _.cont;

  Real Append( A objA ) {
    A aux = objA;
    A PutName( objA::_.name, aux );
    Set Append( _.cont, [[ aux ]] );
    Real SetIndexbyName( _.cont )
  };

  A GetObj( Text name ) {
    A _.cont[ name ]
  }
};

Container C = [[ Set _.cont = Copy(Empty) ]];

A obj1 = [[ Text _.name = "obj1" ]];

Real C::Append( obj1 );



// Viernes, 2009/07/10 17:02:13.00
Class A {
  Text _.name
};

Class Container {
  Set _.cont;

  Real Append( A objA ) {
    A aux = objA;
    A PutName( objA::_.name, aux );
    Set Append( _.cont, [[ aux ]] )
    Real SetIndexbyName( _.cont )
  };

  A GetObj( Text name ) {
    A _.cont[ name ]
  }
};

Container C = [[ Set _.cont = Copy(Empty) ]];

A obj1 = [[ Text _.name = "obj1" ]];

Real C::Append( obj1 );



// Viernes, 2009/07/10 16:57:14.00
Class A {
  Text _.name
};

Class Container {
  Set _.cont;

  Real Append( A objA ) {
    A aux = objA;
    A PutName( objA::_.name, aux );
    Set Append( _.cont, [[ aux ]] )
  };

  A GetObj( Text name ) {
    A _.cont[ name ]
  }
};

Container C = [[ Set _.cont = Copy(Empty) ]];

A obj1 = [[ Text _.name = "obj1" ]];

Real C::Append( obj1 );



// Viernes, 2009/07/10 16:52:25.00
Class A {
  Text _.name
};

Class Container {
  Set _.cont;

  Real Append( A objA ) {
    A aux = objA;
    A PutName( objA::_.name, aux );
    Set Append( _.cont, [[ aux ]] )
  };
  A GetObj( Text name ) {
    A _.cont[ name ]
  }
};

Container C = [[ _.cont = Copy(Empty) ]];

A obj1 = [[ Text _.name = "obj1" ]];

Real C::Append( obj1 );



// Viernes, 2009/07/10 16:11:14.00
NameBlock AA = 
[[
  Real J = 1.0;
  Real GetJ( Real void ) { Real J };
  Real SetJ( Real _j ) { Real J := _j }
]];

NameBlock BB =
[[
  NameBlock instA = AA;

  Code GetJ = instA::GetJ;
  Code SetJ = instA::SetJ
]];

Real x = BB::GetJ( 0 );
Real y = BB::SetJ( 3.0 );



// Viernes, 2009/07/10 16:10:40.00
NameBlock AA = 
[[
  Real J = 1.0;
  Real GetJ( Real void ) { Real J };
  Real SetJ( Real _j ) { Real J := _j }
]];

NameBlock BB =
[[
  NameBlock instA = AA;

  Code GetJ = instA::GetJ;
  Code SetJ = instA::SetJ
]];

Real BB::GetJ( 0 );
Real BB::SetJ( 3.0 );



// Viernes, 2009/07/10 16:10:31.00
NameBlock AA = 
[[
  Real J = 1.0;
  Real GetJ( Real void ) { Real J };
  Real SetJ( Real _j ) { Real J := _j }
]];

NameBlock BB =
[[
  NameBlock instA = AA;

  Code GetJ = instA::GetJ;
  Code SetJ = instA::SetJ
]];

Real x = BB::GetJ( 0 );
Real BB::SetJ( 3.0 );



// Viernes, 2009/07/10 16:08:11.00
NameBlock AA = 
[[
  Real J = 1.0;
  Real GetJ( Real void ) { Real J };
  Real SetJ( Real _j ) { Real J := _j }
]];

NameBlock BB =
[[
  NameBlock instA = AA;

  Code GetJ = instA::GetJ;
  Code SetJ = instA::SetJ
]];

Real BB::GetJ( 0 );
Real BB::SetJ( 3.0 );



// Viernes, 2009/07/10 16:07:00.00
NameBlock AA = 
[[
  Real J = 1.0;
  Real GetJ( Real void ) { Real J };
  Real SetJ( Real _j ) { Real J := _j }
]];

NameBlock BB =
[[
  NameBlock instA = AA;

  Code GetJ = instA::GetJ;
  Code SetJ = instA::SetJ
]];




// Viernes, 2009/07/10 16:06:49.00
NameBlock AA = 
[[
  Real J = 1.0;
  Real GetJ( Real void ) { Real J };
  Real SetJ( Real _j ) { Real J := _j }
]];

NameBlock BB =
[[
  NameBlock instA = AA;

  Code GetJ = instA::GetJ;
  Code SetJ = instA::SetJ;
]];




// Jueves, 2009/07/09 19:23:09.00
NameBlock AA = [[ Real x = 1 ]];
NameBlock PutName( "BB", AA );


// Jueves, 2009/07/02 15:30:35.00
Set [[ 1, 2, 3, 4 ]];
Set GetConsoleObject( 1 );


// Jueves, 2009/07/02 15:30:24.00
Set [[ 1, 2, 3, 4 ]];



// Jueves, 2009/07/02 15:27:06.00
Set [[1, 2, 3, 4 ]];

Set GetConsoleObject( 1 );


// Jueves, 2009/07/02 15:26:55.00
Set [[1, 2, 3, 4 ]];


// Jueves, 2009/07/02 09:17:22.00
Set [[1, 2, 3]];

//////////////////////////////////////////////////////////////////////////////
Anything GetConsoleObject( Real idx )
//////////////////////////////////////////////////////////////////////////////
{
  Set cmd_info = [[ "tol::info",
                    "address",
                    "Console "+IntText(idx) ]];

  Set View( [[ cmd_info ]], "Std" );
  Set result = Tcl_EvalEx( cmd_info );
  Set View( result, "Std" );
  Anything If( result[ "status" ],
               GetObjectFromAddress( result["result"] ),
               Error( "GetConsoleObject: " +
                      result[ "result" ]   +
                      "\nevaluating tol::info address'" ) )
};

Set SS = GetConsoleObject( 1 );



// Jueves, 2009/07/02 09:15:20.00
Set [[1, 2, 3]];

//////////////////////////////////////////////////////////////////////////////
Anything GetConsoleObject( Real idx )
//////////////////////////////////////////////////////////////////////////////
{
  Set cmd_info = [[ "tol::info",
                    "address",
                    "Console "+IntText(idx) ]];

  Set View( [[ cmd_info ]], "Std" );
  Set result = Tcl_EvalEx( cmd_info );
  Set View( result, "Std" );
  Anything If( result[ "status" ],
               GetObjectFromAddress( result["result"] ),
               Error( "GetConsoleObject: " +
                      result[ "result" ]   +
                      "\nevaluating tol::info address'" ) )
};

Set SS = GetConsoleObject( 1 );



// Jueves, 2009/07/02 09:13:57.00
Set [[1, 2, 3]];

//////////////////////////////////////////////////////////////////////////////
Anything GetConsoleObject( Real idx )
//////////////////////////////////////////////////////////////////////////////
{
  Set cmd_info = [[ "tol::info",
                    "address",
                    "{Console "+IntText(idx)+"}" ]];

  Set View( [[ cmd_info ]], "Std" );
  Set result = Tcl_EvalEx( cmd_info );
  Set View( result, "Std" );
  Anything If( result[ "status" ],
               GetObjectFromAddress( result["result"] ),
               Error( "GetConsoleObject: " +
                      result[ "result" ]   +
                      "\nevaluating tol::info address'" ) )
};

Set SS = GetConsoleObject( 1 );



// Jueves, 2009/07/02 09:02:21.00
Set [[1, 2, 3]];

//////////////////////////////////////////////////////////////////////////////
Anything GetConsoleObject( Real idx )
//////////////////////////////////////////////////////////////////////////////
{
  Set cmd_info = [[ "tol::info",
                    "address",
                    "{Console "+IntText(idx)+"}" ]];

  Set View( [[ cmd_info ]], "Std" );
  Set result = Tcl_EvalEx( cmd_info );
  Set View( result, "Std" );
  Anything If( result[ "status" ],
               GetObjectFromAddress( result["result"] ),
               Error( "GetConsoleObject: " +
                      result[ "result" ]   +
                      "\nevaluating tol::info address'" ) )
};

Set SS = GetConsoleObject( 1 );



// Jueves, 2009/07/02 09:00:05.00
Set [[1, 2, 3]];

//////////////////////////////////////////////////////////////////////////////
Anything GetConsoleObject( Real idx )
//////////////////////////////////////////////////////////////////////////////
{
  Set cmd_info = [[ "tol::info",
                    "address",
                    "{Console "+IntText(idx)+"}" ]];
  Set result = Tcl_EvalEx( cmd_info );
  Set View( result, "Std" );
  Anything If( result[ "status" ],
               GetObjectFromAddress( result["result"] ),
               Error( "GetConsoleObject: " +
                      result[ "result" ]   +
                      "\nevaluating tol::info address'" ) )
};

Set SS = GetConsoleObject( 1 );



// Jueves, 2009/07/02 08:59:30.00
Set [[1, 2, 3]];

//////////////////////////////////////////////////////////////////////////////
Anything GetConsoleObject( Real idx )
//////////////////////////////////////////////////////////////////////////////
{
  Set cmd_info = [[ "tol::info",
                    "address",
                    "{Console "+IntText(idx)+"}" ]];
  Set result = Tcl_EvalEx( cmd_info );
  Anything If( result[ "status" ],
               GetObjectFromAddress( result["result"] ),
               Error( "GetConsoleObject: " +
                      result[ "result" ]   +
                      "\nevaluating tol::info address'" ) )
};

Set SS = GetConsoleObject( 1 );



// Jueves, 2009/07/02 08:58:18.00
Set [[1, 2, 3]];

//////////////////////////////////////////////////////////////////////////////
Anything GetConsoleObject( Real idx )
//////////////////////////////////////////////////////////////////////////////
{
  Set cmd_info = [[ "tol::info",
                    "address",
                    "{Console "+IntText(idx)+"}" ]];
  Set result = Tcl_EvalEx( cmd_info );
  Anything If( result[ "status" ],
               GetObjectFromAddress( result["result"] ),
               Error( "GetConsoleObject: " +
                      result[ "result" ]   +
                      "\nevaluating '"     + cmd + "'" ) )
};

Set SS = GetConsoleObject( 1 );



// Jueves, 2009/07/02 08:56:51.00
Set SS = GetConsoleObject( 1 );

// Jueves, 2009/07/02 08:56:18.00
Set [[1, 2, 3]];

//////////////////////////////////////////////////////////////////////////////
Anything GetConsoleObject( Real idx )
//////////////////////////////////////////////////////////////////////////////
{
  Set result = Tcl_EvalEx( "tol::info",
                           "address",
                           "{Console "+IntText(idx)+"}" );
  Anything If( result[ "status" ],
               GetObjectFromAddress( result["result"] ),
               Error( "GetConsoleObject: " +
                      result[ "result" ]   +
                      "\nevaluating '"     + cmd + "'" ) )
};




// Jueves, 2009/07/02 08:56:17.00
Set [[1, 2, 3]];

//////////////////////////////////////////////////////////////////////////////
Anything GetConsoleObject( Real idx )
//////////////////////////////////////////////////////////////////////////////
{
  Set result = Tcl_EvalEx( "tol::info",
                           "address",
                           "{Console "+IntText(idx)+"}" );
  Anything If( result[ "status" ],
               GetObjectFromAddress( result["result"] ),
               Error( "GetConsoleObject: " +
                      result[ "result" ]   +
                      "\nevaluating '"     + cmd + "'" ) )
};




// Jueves, 2009/07/02 08:43:06.00
Set [[1, 2, 3]];



// Lunes, 2009/06/22 15:21:15.00
Matrix SetMat( [[ [[ 28999, 100e+6 ]],
                       	    [[ 8999, 80e+6 ]] ]] );

// Lunes, 2009/06/22 15:18:49.00
Set TM = Include( "/tmp/v3g_estim_tree.oza" );


// Viernes, 2009/06/12 09:25:51.00

Set TM = Include( "/tmp/estim_BTS_jan09_Desag.oza" );
  
Set TD = Include( "/tmp/forecast_BTS_jan09_Desag.oza" );

NameBlock SimulateTreeModel_( TM[1], TD[1], "IDEMP", 50 );


// Viernes, 2009/06/12 09:24:03.00
NameBlock SimulateTreeModel_( TM[1], TD[1], "IDEMP", 50 );

// Viernes, 2009/06/12 09:22:51.00

Set TM = Include( "/tmp/estim_BTS_jan09_Desag.oza" );
  
Set TD = Include( "/tmp/forecast_BTS_jan09_Desag.oza" );

NameBlock SimulateTreeModel_( TM[1], TD[1], "CO_MUNI", 50 );


// Viernes, 2009/06/12 09:12:39.00
Set TM = Include( "/tmp/v3g_estim_tree.oza" );
Set TD = Include( "/tmp/v3g_data_tree.oza" );

NameBlock SimulateTreeModel_( TM[1], TD[1], "CO_MUNI", 100 );


// Viernes, 2009/06/12 09:11:51.00
Set TM = Include( "/tmp/v3g_estim_tree.oza" );
Set TD = Include( "/tmp/v3g_data_tree.oza" );

NameBlock SimulateTreeModel_( TM[1], TD[1], "CO_MUNI", 100 );


// Viernes, 2009/06/12 09:11:20.00
Set TM = Include( "/tmp/v3g_estim_tree.oza" );
Set TD = Include( "/tmp/v3g_data_tree.oza" );

NameBlock SimulateTreeModel_( TM[1], TD[1], "CO_MUNI", 100 );


// Viernes, 2009/06/12 09:10:53.00
Set TM = Include( "/tmp/v3g_estim_tree.oza" );
Set TD = Include( "/tmp/v3g_data_tree.oza" );

SimulateTreeModel_( TM[1], TD[1], "CO_MUNI", 100 );


// Viernes, 2009/06/12 09:09:02.00
Set TM = Include( "/tmp/v3g_estim_tree.oza" );
Set TD = Include( "/tmp/v3g_data_tree.oza" );

SimulateTreeModel_( TM[1], TD[1], "CO_MUNI", 100 );


// Viernes, 2009/06/12 09:07:30.00
Set TD = Include( "/tmp/v3g_data_tree.oza" );

// Viernes, 2009/06/12 09:07:20.00
Set TM = Include( "/tmp/v3g_estim_tree.oza" );


// Viernes, 2009/06/12 00:19:51.00
Serie GuiDatChSemSum (GetObjectFromAddress("A87C770:0:9CC2E00:0:9ACF4F8:0:2:4:3") )

// Viernes, 2009/06/12 00:19:17.00
Serie GuiApplyPolyn (GetObjectFromAddress("A87CA30:0:9CC2E00:0:9ACF4F8:0:2:4:3") ,1-B)

// Viernes, 2009/06/12 00:18:34.00
Serie GuiApplyPolyn (GetObjectFromAddress("A87CA30:0:9CC2E00:0:9ACF4F8:0:2:4:3") ,B)

// Jueves, 2009/06/11 00:29:12.00
Set Traspose (Ois.DefDoc )

// Jueves, 2009/06/11 00:16:59.00
Set Traspose (a )

// Jueves, 2009/06/11 00:16:12.00
Serie GuiApplyPolyn (ser ,B)

// Jueves, 2009/06/11 00:15:42.00


Set Fun(Real real)
{
 SetOfSerie(Serie ser = real*CalInd(C, Diario))
};
Set a = Fun(8); 


// Miercoles, 2009/06/10 18:52:45.00
Set EST = Include("/tmp/estim_BTS_jan09_Desag.oza");

Set FORE = Include("/tmp/forecast_BTS_jan09_Desag.oza");